{
  "mode": "replace",
  "lessons": [
    {
      "id": 1,
      "title": "1. Hello, World!",
      "description": "The classic first step in programming. Your goal is to print the exact text \"Hello, World!\" to the console. Use `System.out.println()` to achieve this.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        // Your code here. Print \"Hello, World!\"\n        \n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        // Your code here. Print \"Hello, World!\"\n        System.out.println(\"Hello, World!\");\n    }\n}",
      "expectedOutput": "Hello, World!",
      "tutorial": "<p class=\"mb-4 text-gray-300\">In Java, the console is a text output window. To print text to it, we use a built-in command from the System library.</p><p class=\"mb-4 text-gray-300\">The command is <code>System.out.println()</code>. The <code>ln</code> part means \"line,\" so it prints the text and then moves to the next line.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// This line will print \"Welcome to Java!\" to the console.\nSystem.out.println(\"Welcome to Java!\");\n\n// This will print a number. Numbers don't need quotes.\nSystem.out.println(123);</pre></div><p class=\"mt-4 text-gray-300\">For this lesson, you need to print the specific phrase \"Hello, World!\".</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding hello, world! is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying hello, world!, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply hello, world! will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with hello, world!, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "OOP"
      ]
    },
    {
      "id": 2,
      "title": "2. Variables & Data Types",
      "description": "Variables are containers for storing data. Declare an integer variable named `myNumber`, assign it the value `42`, and then print the variable to the console.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        // Declare an integer variable named myNumber with value 42\n        \n\n        // Print the myNumber variable\n        \n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        // Declare an integer variable named myNumber with value 42\n        int myNumber = 42;\n\n        // Print the myNumber variable\n        System.out.println(myNumber);\n    }\n}",
      "expectedOutput": "42",
      "tutorial": "<p class=\"mb-4 text-gray-300\">In Java, a variable is like a labeled box where you can store information. You must first <strong>declare</strong> it by giving it a data type and a name.</p><ul class=\"list-disc list-inside mb-4 text-gray-300 space-y-1\"><li><code>int</code>: for whole numbers (e.g., 5, -10, 42).</li><li><code>String</code>: for text (e.g., \"Hello, World!\").</li><li><code>double</code>: for decimal numbers (e.g., 3.14).</li><li><code>boolean</code>: for true or false values.</li></ul><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// 1. Declare a variable 'age' of type 'int'\nint age;\n\n// 2. Assign the value 25 to it\nage = 25;\n\n// You can also declare and assign in one line (which is common):\nint score = 100;\n\n// 3. Print the value stored in the variable (notice no quotes)\nSystem.out.println(score); // This will print 100</pre></div><p class=\"mt-4 text-gray-300\">In this lesson, create an <code>int</code> variable named <code>myNumber</code>, give it the value <code>42</code>, and print it.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding variables & data types is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying variables & data types, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply variables & data types will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with variables & data types, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "OOP",
        "Math and Stats"
      ]
    },
    {
      "title": "3. Arithmetic & Assignment",
      "language": "java",
      "description": "Update the balance by adding the deposit and subtracting the withdrawal using compound assignment, then print the result.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        int balance = 100;\n        int deposit = 35;\n        int withdrawal = 20;\n\n        // Use compound assignment to add the deposit and subtract the withdrawal\n        // Then print the balance\n\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        int balance = 100;\n        int deposit = 35;\n        int withdrawal = 20;\n\n        balance += deposit;\n        balance -= withdrawal;\n        System.out.println(balance);\n    }\n}\n",
      "expectedOutput": "115",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>) for calculations. Compound assignment like <code>+=</code> and <code>-=</code> updates a variable without rewriting its name.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">int total = 10;\ntotal += 5;  // same as total = total + 5\ntotal -= 2;\ntotal++;    // adds one (same as total += 1)\nSystem.out.println(total);</pre></div><p class=\"mt-4 text-gray-300\">This shorthand is essential for counters such as <code>i++</code> that you'll rely on in loops.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding arithmetic & assignment is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying arithmetic & assignment, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply arithmetic & assignment will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with arithmetic & assignment, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 3,
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "OOP"
      ]
    },
    {
      "title": "4. Increment & Decrement",
      "language": "java",
      "description": "Increase the counter to 3 using the ++ operator, then print it.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        int counter = 0;\n\n        // Use the ++ operator to bring counter up to 3\n\n        System.out.println(counter);\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        int counter = 0;\n\n        counter++;\n        counter++;\n        counter++;\n\n        System.out.println(counter);\n    }\n}\n",
      "expectedOutput": "3",
      "tutorial": "<p class=\"mb-4 text-gray-300\">The increment (<code>++</code>) and decrement (<code>--</code>) operators add or subtract 1. They are shorthand for <code>counter = counter + 1</code> and <code>counter = counter - 1</code>.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">int lives = 3;\nlives--;   // now 2\nint score = 0;\nscore++;  // now 1</pre></div><p class=\"mt-4 text-gray-300\">You'll use <code>i++</code> constantly when writing loop counters.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding increment & decrement is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying increment & decrement, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply increment & decrement will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with increment & decrement, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 4,
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "OOP"
      ]
    },
    {
      "title": "5. Comparison Operators",
      "language": "java",
      "description": "Compare the score to the passingScore to create a boolean named isPassing, then print it.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        int score = 88;\n        int passingScore = 70;\n\n        // Create a boolean isPassing using a comparison and print it\n\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        int score = 88;\n        int passingScore = 70;\n\n        boolean isPassing = score >= passingScore;\n        System.out.println(isPassing);\n    }\n}\n",
      "expectedOutput": "true",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Comparison operators (<code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>) evaluate to boolean results.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">int temperature = 72;\nboolean isWarm = temperature &gt;= 70;\nSystem.out.println(isWarm); // true</pre></div><p class=\"mt-4 text-gray-300\">These boolean expressions power <code>if</code> statements and loop conditions.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding comparison operators is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying comparison operators, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply comparison operators will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with comparison operators, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 5,
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "OOP"
      ]
    },
    {
      "id": 6,
      "title": "6. While Loops",
      "description": "A `while` loop executes a block of code as long as a specified condition is true. Create a loop that prints numbers from 1 to 5, each on a new line.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        int i = 1;\n\n        // Create a while loop that runs as long as i is less than or equal to 5\n        // Inside the loop, print the value of i and then increment it.\n\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        int i = 1;\n\n        // Create a while loop that runs as long as i is less than or equal to 5\n        // Inside the loop, print the value of i and then increment it.\n        while (i <= 5) {\n            System.out.println(i);\n            i++;\n        }\n    }\n}",
      "expectedOutput": "1\n2\n3\n4\n5",
      "tutorial": "<p class=\"mb-4 text-gray-300\">A <code>while</code> loop is used to repeat a block of code as long as a condition is met. It's useful when you don't know exactly how many times you need to loop.</p><p class=\"mb-4 text-gray-300\"><strong>Crucially</strong>, you must ensure the condition eventually becomes false, otherwise you'll create an infinite loop!</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">int countdown = 3;\n\nwhile (countdown > 0) {\n    System.out.println(countdown);\n    countdown--; // This is essential to avoid an infinite loop!\n}\n\nSystem.out.println(\"Blast off!\");</pre></div><p class=\"mt-4 text-gray-300\">For this lesson, initialize a counter and use a <code>while</code> loop to print numbers 1 through 5. Don't forget to increment your counter inside the loop!</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding while loops is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying while loops, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply while loops will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with while loops, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "OOP",
        "Concurrency"
      ]
    },
    {
      "id": 7,
      "title": "7. For Loops",
      "description": "A `for` loop is ideal when you know exactly how many times you want to loop. Use a for loop to print the numbers from 0 to 4, each on a new line.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        // Create a for loop that initializes a counter at 0,\n        // continues as long as it's less than 5, and increments by 1.\n\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        // Create a for loop that initializes a counter at 0,\n        // continues as long as it's less than 5, and increments by 1.\n        for (int i = 0; i < 5; i++) {\n            System.out.println(i);\n        }\n    }\n}",
      "expectedOutput": "0\n1\n2\n3\n4",
      "tutorial": "<p class=\"mb-4 text-gray-300\">A <strong>for loop</strong> provides a concise way to write a loop structure. It consists of three parts, separated by semicolons:</p><ol class=\"list-decimal list-inside mb-4 text-gray-300 space-y-2\"><li><strong>Initialization:</strong> Executed once at the beginning (e.g., <code>int i = 0</code>).</li><li><strong>Condition:</strong> Evaluated before each loop iteration. If it's false, the loop stops (e.g., <code>i < 5</code>).</li><li><strong>Increment/Decrement:</strong> Executed at the end of each iteration (e.g., <code>i++</code>).</li></ol><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// This loop will print \"Iteration 0\" through \"Iteration 4\"\nfor (int i = 0; i < 5; i++) {\n    System.out.println(\"Iteration \" + i);\n}</pre></div><p class=\"mt-4 text-gray-300\">Your task is to create a for loop that prints the value of the counter <code>i</code> on each iteration, from 0 up to (but not including) 5.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding for loops is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying for loops, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply for loops will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with for loops, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "OOP",
        "Async"
      ]
    },
    {
      "id": 8,
      "title": "8. Introduction to Arrays",
      "description": "An array is a collection of similar types of data. Create an array of integers, store some numbers in it, and then print the second element from the array.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        // Declare and initialize an integer array named 'numbers'\n        // with the values 10, 20, 30, 40, 50.\n\n        // Print the element at index 1 of the array.\n\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        // Declare and initialize an integer array named 'numbers'\n        // with the values 10, 20, 30, 40, 50.\n        int[] numbers = {10, 20, 30, 40, 50};\n\n        // Print the element at index 1 of the array.\n        System.out.println(numbers[1]);\n    }\n}",
      "expectedOutput": "20",
      "tutorial": "<p class=\"mb-4 text-gray-300\">An <strong>array</strong> is a container object that holds a fixed number of values of a single type. The length of an array is established when the array is created.</p><p class=\"mb-4 text-gray-300\">Array elements are accessed by their <strong>index</strong>, which starts at <strong>0</strong>. So, the first element is at index 0, the second at index 1, and so on.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Declare and initialize an array of Strings\nString[] fruits = {\"Apple\", \"Banana\", \"Cherry\"};\n\n// Access and print the first element (index 0)\nSystem.out.println(fruits[0]); // Prints \"Apple\"\n\n// Access and print the third element (index 2)\nSystem.out.println(fruits[2]); // Prints \"Cherry\"</pre></div><p class=\"mt-4 text-gray-300\">Your task is to create an integer array and print the element at index 1, which is the second value in the list.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding introduction to arrays is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying introduction to arrays, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply introduction to arrays will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with introduction to arrays, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Collections",
        "OOP",
        "Async"
      ]
    },
    {
      "id": 9,
      "title": "9. Intro to Classes & Objects",
      "description": "Java is an Object-Oriented language. A `class` is a blueprint for creating `objects`. Create a simple `Dog` class with a `bark()` method, then create an object of that class and call its method.",
      "initialCode": "// First, define the Dog class outside of the Main class\nclass Dog {\n    // Add a public void method named bark() that prints \"Woof!\"\n\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create an instance (an object) of the Dog class\n\n        // Call the bark() method on your new dog object\n\n    }\n}",
      "fullSolution": "// First, define the Dog class outside of the Main class\nclass Dog {\n    // Add a public void method named bark() that prints \"Woof!\"\n    public void bark() {\n        System.out.println(\"Woof!\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create an instance (an object) of the Dog class\n        Dog myDog = new Dog();\n\n        // Call the bark() method on your new dog object\n        myDog.bark();\n    }\n}",
      "expectedOutput": "Woof!",
      "tutorial": "<p class=\"mb-4 text-gray-300\">A <strong>class</strong> is a template for creating objects. It defines an object's properties (fields) and behaviors (methods).</p><p class=\"mb-4 text-gray-300\">An <strong>object</strong> is an instance of a class. You can create many objects from a single class blueprint.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// The blueprint for a Car\nclass Car {\n    // A behavior (method) of the Car\n    public void startEngine() {\n        System.out.println(\"Engine started!\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create an object (an instance) from the Car class\n        Car myCar = new Car();\n        \n        // Call a method on the object\n        myCar.startEngine(); // Prints \"Engine started!\"\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding intro to classes & objects is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying intro to classes & objects, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply intro to classes & objects will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with intro to classes & objects, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Functions",
        "OOP"
      ]
    },
    {
      "id": 10,
      "title": "10. Advanced Conditionals (Else If)",
      "description": "Check multiple conditions using `if`, `else if`, and `else`. Based on the `score` variable, print 'Excellent' for scores > 90, 'Good' for scores > 75, and 'Needs Improvement' for all others.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        int score = 85;\n\n        // Your if-else if-else statement here\n\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        int score = 85;\n\n        // Your if-else if-else statement here\n        if (score > 90) {\n            System.out.println(\"Excellent\");\n        } else if (score > 75) {\n            System.out.println(\"Good\");\n        } else {\n            System.out.println(\"Needs Improvement\");\n        }\n    }\n}",
      "expectedOutput": "Good",
      "tutorial": "<p class=\"mb-4 text-gray-300\">The <strong>if-else if-else</strong> statement is perfect for when you have multiple conditions to check in sequence. Java checks them from top to bottom and runs the code for the first one that is true.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">int number = 0;\n\nif (number > 0) {\n    System.out.println(\"The number is positive.\");\n} else if (number < 0) {\n    System.out.println(\"The number is negative.\");\n} else {\n    System.out.println(\"The number is zero.\");\n}</pre></div><p class=\"mt-4 text-gray-300\">Notice how only one of the blocks can ever run. The final <code>else</code> is a catch-all if none of the previous conditions were met.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding advanced conditionals (else if) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying advanced conditionals (else if), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply advanced conditionals (else if) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with advanced conditionals (else if), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "OOP",
        "Concurrency"
      ]
    },
    {
      "title": "11. Else-If Chains with &&",
      "language": "java",
      "description": "Decide a student outcome using if/else-if/else and the && operator. Score >= 90 prints \"Honors\"; score >= 75 with bonus prints \"Pass\"; everything else prints \"Retake\".",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        int score = 82;\n        boolean hasBonus = true;\n\n        // Write an if/else-if/else chain that matches the description\n        \n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        int score = 82;\n        boolean hasBonus = true;\n\n        if (score >= 90) {\n            System.out.println(\"Honors\");\n        } else if (score >= 75 && hasBonus) {\n            System.out.println(\"Pass\");\n        } else {\n            System.out.println(\"Retake\");\n        }\n    }\n}\n",
      "expectedOutput": "Pass",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Check conditions in priority order. Combine requirements with <code>&&</code> so a branch runs only when <em>both</em> parts are true.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">int age = 17;\nboolean hasPermit = true;\nif (age >= 18) {\n    System.out.println(\"Full License\");\n} else if (age >= 16 && hasPermit) {\n    System.out.println(\"Learner Permit\");\n} else {\n    System.out.println(\"Not eligible\");\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding else-if chains with && is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying else-if chains with &&, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply else-if chains with && will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with else-if chains with &&, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 11,
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "OOP"
      ]
    },
    {
      "id": 12,
      "title": "12. Logical Operators",
      "description": "Combine conditions using logical operators. Use the `&&` (AND) operator to check if a user is both `loggedIn` and an `isAdmin`. To pass, change `isAdmin` to `true` and print 'Admin Access Granted'.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        boolean loggedIn = true;\n        boolean isAdmin = false;\n\n        // Change isAdmin to true on this line\n\n        // Use an if statement with the && operator to check both variables\n        // If the condition is true, print \"Admin Access Granted\"\n\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        boolean loggedIn = true;\n        boolean isAdmin = false;\n\n        // Change isAdmin to true on this line\n        isAdmin = true;\n\n        // Use an if statement with the && operator to check both variables\n        // If the condition is true, print \"Admin Access Granted\"\n        if (loggedIn && isAdmin) {\n            System.out.println(\"Admin Access Granted\");\n        }\n    }\n}",
      "expectedOutput": "Admin Access Granted",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Logical operators let you create more complex conditions:</p><ul class=\"list-disc list-inside mb-4 text-gray-300 space-y-2\"><li><code>&&</code> (AND): True only if <strong>both</strong> conditions are true.</li><li><code>||</code> (OR): True if <strong>at least one</strong> condition is true.</li><li><code>!</code> (NOT): Inverts the boolean value (true becomes false, false becomes true).</li></ul><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">int age = 25;\nboolean hasLicense = true;\n\nif (age >= 18 && hasLicense) {\n    System.out.println(\"You are eligible to drive.\");\n}</pre></div><p class=\"mt-4 text-gray-300\">For this lesson, you'll need to write an <code>if</code> statement that checks if both <code>loggedIn</code> and <code>isAdmin</code> are true. To make the condition pass, you will also need to change the value of <code>isAdmin</code> from <code>false</code> to <code>true</code>.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding logical operators is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying logical operators, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply logical operators will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with logical operators, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "OOP"
      ]
    },
    {
      "id": 13,
      "title": "13. Creating Methods",
      "description": "Write a reusable block of code called a method. Create a method named `greetUser` that takes a `String` name as a parameter and prints 'Hello, [name]!'. Call this method from `main` with your own name.",
      "initialCode": "public class Main {\n\n    // Define your greetUser method here. It should be public and static.\n\n\n    public static void main(String[] args) {\n        // Call your greetUser method with your name (e.g., \"Alex\")\n\n    }\n}",
      "fullSolution": "public class Main {\n\n    // Define your greetUser method here. It should be public and static.\n    public static void greetUser(String name) {\n        System.out.println(\"Hello, \" + name + \"!\");\n    }\n\n    public static void main(String[] args) {\n        // Call your greetUser method with your name (e.g., \"Alex\")\n        greetUser(\"Alex\");\n    }\n}",
      "expectedOutput": "Hello, Alex!",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Methods (also called functions in other languages) help you organize code and avoid repetition. You define it once and can call it many times.</p><p class=\"mb-4 text-gray-300\">A method signature has a few parts: visibility (<code>public</code>), other modifiers (<code>static</code>), return type (<code>void</code> if it returns nothing), the method name, and parameters in parentheses.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">public class Main {\n\n    // A method that takes two integers and prints their sum\n    public static void add(int a, int b) {\n        System.out.println(a + b);\n    }\n\n    public static void main(String[] args) {\n        // Call the add method with different arguments\n        add(5, 3);   // Prints 8\n        add(10, 20); // Prints 30\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding creating methods is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying creating methods, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply creating methods will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with creating methods, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Functions",
        "OOP"
      ]
    },
    {
      "id": 14,
      "title": "14. Methods with Return Values",
      "description": "Methods can compute and return a value. Create a method `add` that takes two integers, returns their sum, and then print the returned result from the `main` method.",
      "initialCode": "public class Main {\n\n    // Create a public static method named 'add' that takes two ints (a, b)\n    // and returns an int which is their sum.\n\n\n    public static void main(String[] args) {\n        // Call the add method with 15 and 27, store the result in a variable,\n        // and then print that result variable.\n\n    }\n}",
      "fullSolution": "public class Main {\n\n    // Create a public static method named 'add' that takes two ints (a, b)\n    // and returns an int which is their sum.\n    public static int add(int a, int b) {\n        return a + b;\n    }\n\n    public static void main(String[] args) {\n        // Call the add method with 15 and 27, store the result in a variable,\n        // and then print that result variable.\n        int result = add(15, 27);\n        System.out.println(result);\n    }\n}",
      "expectedOutput": "42",
      "tutorial": "<p class=\"mb-4 text-gray-300\">So far, our methods have used <code>void</code>, meaning they don't return any information. By changing <code>void</code> to a data type (like <code>int</code> or <code>String</code>), we can make the method send a value back to where it was called.</p><p class=\"mb-4 text-gray-300\">The <code>return</code> keyword is used to specify what value to send back. When <code>return</code> is executed, the method stops immediately.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">public class Main {\n\n    // This method takes a number and returns that number doubled.\n    public static int doubleValue(int number) {\n        return number * 2;\n    }\n\n    public static void main(String[] args) {\n        // We call the method and store its return value in a variable.\n        int answer = doubleValue(5);\n\n        // Now we can use the result.\n        System.out.println(answer); // Prints 10\n    }\n}</pre></div><p class=\"mt-4 text-gray-300\">Your task is to create an <code>add</code> method that returns the sum of two numbers.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding methods with return values is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying methods with return values, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply methods with return values will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with methods with return values, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Functions",
        "OOP",
        "Async"
      ]
    },
    {
      "title": "15. Array Length & Bounds",
      "language": "java",
      "description": "Use .length to read the first and last elements of an array and print the count.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        int[] values = {5, 9, 14, 20, 25};\n\n        // Print first value\n        // Print last value using values.length - 1\n        // Print the number of items\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        int[] values = {5, 9, 14, 20, 25};\n\n        System.out.println(values[0]);\n        System.out.println(values[values.length - 1]);\n        System.out.println(values.length);\n    }\n}\n",
      "expectedOutput": "5\n25\n5",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Arrays know their size via the <code>length</code> field. Valid indexes run from <code>0</code> up to <code>length - 1</code>.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">int[] nums = {2, 4, 6};\nSystem.out.println(nums[0]);  // 2\nSystem.out.println(nums[nums.length - 1]); // 6\nSystem.out.println(nums.length); // 3</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding array length & bounds is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying array length & bounds, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply array length & bounds will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with array length & bounds, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 15,
      "tags": [
        "Beginner",
        "Basics",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 16,
      "title": "16. Looping Through Arrays",
      "description": "Combine loops and arrays to process each item in a collection. Use a `for` loop to iterate through an array of strings and print each name on a new line.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String[] names = {\"Alice\", \"Bob\", \"Charlie\"};\n\n        // Use a for loop to print each name from the array.\n        // You can get the array's size with 'names.length'.\n\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String[] names = {\"Alice\", \"Bob\", \"Charlie\"};\n\n        // Use a for loop to print each name from the array.\n        // You can get the array's size with 'names.length'.\n        for (int i = 0; i < names.length; i++) {\n            System.out.println(names[i]);\n        }\n    }\n}",
      "expectedOutput": "Alice\nBob\nCharlie",
      "tutorial": "<p class=\"mb-4 text-gray-300\">A very common task is to perform an action on every item in an array. A <code>for</code> loop is perfect for this.</p><p class=\"mb-4 text-gray-300\">You can get the number of items in an array using the <code>.length</code> property. This is extremely useful for setting the loop's condition, ensuring it runs exactly the right number of times.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">int[] scores = {98, 87, 100, 91};\n\n// The loop runs as long as 'i' is less than the array's length.\nfor (int i = 0; i < scores.length; i++) {\n    // We use the loop variable 'i' as the index to get each element.\n    System.out.println(\"Score \" + i + \": \" + scores[i]);\n}</pre></div><p class=\"mt-4 text-gray-300\">Your goal is to loop through the <code>names</code> array and print each element using <code>System.out.println()</code>.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding looping through arrays is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying looping through arrays, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply looping through arrays will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with looping through arrays, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 17,
      "title": "17. String Concatenation",
      "description": "Combine strings using the `+` operator. Create two string variables and combine them with a space in between to form a sentence, then print the result.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String part1 = \"Java is\";\n        String part2 = \"powerful\";\n\n        // Create a new string named 'fullSentence' by combining part1, a space, and part2.\n\n\n        // Print the fullSentence.\n\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String part1 = \"Java is\";\n        String part2 = \"powerful\";\n\n        // Create a new string named 'fullSentence' by combining part1, a space, and part2.\n        String fullSentence = part1 + \" \" + part2;\n\n        // Print the fullSentence.\n        System.out.println(fullSentence);\n    }\n}",
      "expectedOutput": "Java is powerful",
      "tutorial": "<p class=\"mb-4 text-gray-300\">In Java, the <code>+</code> operator does double duty. When used with numbers, it performs addition. When used with strings, it performs <strong>concatenation</strong>, which means it joins them together.</p><p class=\"mb-4 text-gray-300\">You can combine variables and string literals (text in quotes) to build up complex strings.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">String user = \"Alex\";\nint level = 5;\n\n// We can combine strings and other data types.\n// Java automatically converts the number 'level' to a string.\nString message = \"Welcome, \" + user + \"! You are on level \" + level + \".\";\n\nSystem.out.println(message); // Prints \"Welcome, Alex! You are on level 5.\"</pre></div><p class=\"mt-4 text-gray-300\">For this lesson, combine the two provided strings. Don't forget to add a space <code>\" \"</code> in between them!</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding string concatenation is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying string concatenation, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply string concatenation will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with string concatenation, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "OOP",
        "Type System"
      ]
    },
    {
      "id": 18,
      "title": "18. Constructors",
      "description": "A constructor is a special method that is called when an object is created. Add a constructor to the `Car` class that accepts a `String` for the car's color and prints a message.",
      "initialCode": "class Car {\n    String color;\n\n    // Create a constructor for the Car class.\n    // It should accept one String parameter named 'carColor'.\n    // Inside, it should set the instance variable 'color' and\n    // print \"A new [color] car has been created.\"\n\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create a new Car object with the color \"blue\".\n        Car myCar = new Car(\"blue\");\n    }\n}",
      "fullSolution": "class Car {\n    String color;\n\n    // Create a constructor for the Car class.\n    // It should accept one String parameter named 'carColor'.\n    // Inside, it should set the instance variable 'color' and\n    // print \"A new [color] car has been created.\"\n    public Car(String carColor) {\n        this.color = carColor;\n        System.out.println(\"A new \" + this.color + \" car has been created.\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create a new Car object with the color \"blue\".\n        Car myCar = new Car(\"blue\");\n    }\n}",
      "expectedOutput": "A new blue car has been created.",
      "tutorial": "<p class=\"mb-4 text-gray-300\">A <strong>constructor</strong> in Java is a special method used to initialize objects. It is called at the time of object creation. It must have the same name as the class and does not have a return type.</p><p class=\"mb-4 text-gray-300\">Constructors are great for setting up the initial state of an object.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">class Dog {\n    String name;\n\n    // This is the constructor for the Dog class.\n    public Dog(String dogName) {\n        // 'this.name' refers to the instance variable.\n        // 'dogName' refers to the parameter.\n        this.name = dogName;\n        System.out.println(\"Dog created with name: \" + this.name);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        // The constructor is called when we use 'new'.\n        Dog myDog = new Dog(\"Fido\"); // Prints \"Dog created with name: Fido\"\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding constructors is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying constructors, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply constructors will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with constructors, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Functions",
        "Collections"
      ]
    },
    {
      "title": "19. this for Fields in Constructors",
      "language": "java",
      "description": "Use this to assign constructor parameters to fields, then call an instance method that references the field.",
      "initialCode": "class Counter {\n    private int value;\n\n    public Counter(int start) {\n        // Assign the parameter to the field using this\n    }\n\n    public void increment() {\n        value++;\n    }\n\n    public int getValue() {\n        return value;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Counter counter = new Counter(5);\n        counter.increment();\n        System.out.println(counter.getValue());\n    }\n}\n",
      "fullSolution": "class Counter {\n    private int value;\n\n    public Counter(int start) {\n        this.value = start;\n    }\n\n    public void increment() {\n        value++;\n    }\n\n    public int getValue() {\n        return value;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Counter counter = new Counter(5);\n        counter.increment();\n        System.out.println(counter.getValue());\n    }\n}\n",
      "expectedOutput": "6",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>this</code> disambiguates between fields and parameters with the same name. It's common to store constructor arguments on the instance this way.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">class Player {\n    private String name;\n    public Player(String name) {\n        this.name = name;\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding this for fields in constructors is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying this for fields in constructors, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply this for fields in constructors will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with this for fields in constructors, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 19,
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Functions",
        "OOP"
      ]
    },
    {
      "title": "20. Static vs Instance Fields",
      "language": "java",
      "description": "Keep a static count of created sessions while storing each session's user name separately.",
      "initialCode": "class Session {\n    // Declare a static field totalSessions initialized to 0\n    // Declare an instance field user\n\n    public Session(String user) {\n        // Assign user field and increment the static counter\n    }\n\n    public static int getTotalSessions() {\n        // Return the static counter\n        return 0;\n    }\n\n    public String getUser() {\n        return user;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Session first = new Session(\"ada\");\n        Session second = new Session(\"grace\");\n        System.out.println(Session.getTotalSessions());\n        System.out.println(first.getUser());\n    }\n}\n",
      "fullSolution": "class Session {\n    private static int totalSessions = 0;\n    private final String user;\n\n    public Session(String user) {\n        this.user = user;\n        totalSessions++;\n    }\n\n    public static int getTotalSessions() {\n        return totalSessions;\n    }\n\n    public String getUser() {\n        return user;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Session first = new Session(\"ada\");\n        Session second = new Session(\"grace\");\n        System.out.println(Session.getTotalSessions());\n        System.out.println(first.getUser());\n    }\n}\n",
      "expectedOutput": "2\nada",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use <code>static</code> for data shared by every instance (class-level state) and instance fields for per-object details. Access static members through the class name.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">class Counter {\n    static int total = 0;\n    Counter() { total++; }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding static vs instance fields is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying static vs instance fields, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply static vs instance fields will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with static vs instance fields, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 20,
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "OOP"
      ]
    },
    {
      "id": 21,
      "title": "21. Enhanced For Loop",
      "description": "Java provides a simpler `for-each` loop to iterate over arrays or collections. Use an enhanced for loop to print each fruit from the `fruits` array.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String[] fruits = {\"Apple\", \"Orange\", \"Banana\"};\n\n        // Use an enhanced for loop (for-each) to print each fruit.\n\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String[] fruits = {\"Apple\", \"Orange\", \"Banana\"};\n\n        // Use an enhanced for loop (for-each) to print each fruit.\n        for (String fruit : fruits) {\n            System.out.println(fruit);\n        }\n    }\n}",
      "expectedOutput": "Apple\nOrange\nBanana",
      "tutorial": "<p class=\"mb-4 text-gray-300\">The <strong>enhanced for loop</strong> (or for-each loop) is a more readable and concise way to iterate through all the elements of an array or collection, without needing an index variable (like <code>i</code>).</p><p class=\"mb-4 text-gray-300\">The syntax is <code>for (Type variableName : arrayName)</code>. In each iteration, the loop automatically assigns the next element from the array to your variable.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">int[] numbers = {10, 20, 30};\n\n// For each 'number' of type 'int' in the 'numbers' array...\nfor (int number : numbers) {\n    // ...print it out.\n    System.out.println(number);\n}</pre></div><p class=\"mt-4 text-gray-300\">This is often preferred over a standard for loop when you just need to access each element in order and don't need the index.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding enhanced for loop is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying enhanced for loop, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply enhanced for loop will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with enhanced for loop, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 22,
      "title": "22. User Input (Scanner)",
      "description": "Real programs need to interact with users. Use the `Scanner` class to get input. The simulation will provide the input \"World\". Your task is to read it and print \"Hello, World\".",
      "initialCode": "// We need to import the Scanner class to use it.\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create a new Scanner object to read from the console.\n        Scanner scanner = new Scanner(System.in);\n\n        System.out.println(\"Enter a word:\");\n\n        // Read the next line of input and store it in a variable.\n        String input = scanner.nextLine();\n\n        // Print \"Hello, \" followed by the input you received.\n\n    }\n}",
      "fullSolution": "// We need to import the Scanner class to use it.\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create a new Scanner object to read from the console.\n        Scanner scanner = new Scanner(System.in);\n\n        System.out.println(\"Enter a word:\");\n\n        // Read the next line of input and store it in a variable.\n        String input = scanner.nextLine();\n\n        // Print \"Hello, \" followed by the input you received.\n        System.out.println(\"Hello, \" + input);\n    }\n}",
      "userInput": [
        "World"
      ],
      "expectedOutput": "Enter a word:\nHello, World",
      "tutorial": "<p class=\"mb-4 text-gray-300\">To get input from a user in the console, Java provides the <code>Scanner</code> class. It's part of Java's utility library, so you must first import it at the top of your file with <code>import java.util.Scanner;</code>.</p><p class=\"mb-4 text-gray-300\">You then create a <code>Scanner</code> object, telling it to read from the standard input stream, <code>System.in</code>.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner myScanner = new Scanner(System.in);\n        System.out.println(\"What is your name?\");\n\n        // The program will pause here and wait for the user to type.\n        String name = myScanner.nextLine(); \n\n        System.out.println(\"Nice to meet you, \" + name);\n    }\n}</pre></div><p class=\"mt-4 text-gray-300\">For this lesson, the simulator will automatically type \"World\" for you. Your job is to read that input using <code>scanner.nextLine()</code> and use it to construct the final output.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding user input (scanner) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying user input (scanner), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply user input (scanner) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with user input (scanner), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "OOP",
        "Async"
      ]
    },
    {
      "id": 23,
      "title": "23. Switch Statement",
      "description": "Use a `switch` statement to handle different cases for a character variable. Based on the `grade`, set the `comment` variable to the correct string.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        char grade = 'B';\n        String comment = \"\"; // Initialize the variable\n\n        // Use a switch statement to set the 'comment' variable.\n        // case 'A': \"Excellent!\"\n        // case 'B': \"Good job!\"\n        // case 'C': \"You passed.\"\n        // default: \"Invalid grade.\"\n        // Don't forget the 'break' statements!\n\n\n        System.out.println(\"Comment: \" + comment);\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        char grade = 'B';\n        String comment; // It's better to not initialize here\n\n        // Use a switch statement to set the 'comment' variable.\n        // case 'A': \"Excellent!\"\n        // case 'B': \"Good job!\"\n        // case 'C': \"You passed.\"\n        // default: \"Invalid grade.\"\n        // Don't forget the 'break' statements!\n        switch (grade) {\n            case 'A':\n                comment = \"Excellent!\";\n                break;\n            case 'B':\n                comment = \"Good job!\";\n                break;\n            case 'C':\n                comment = \"You passed.\";\n                break;\n            default:\n                comment = \"Invalid grade.\";\n                break;\n        }\n\n        System.out.println(\"Comment: \" + comment);\n    }\n}",
      "expectedOutput": "Comment: Good job!",
      "tutorial": "<p class=\"mb-4 text-gray-300\">The <strong>switch</strong> statement is a cleaner alternative to a long chain of <code>if-else if-else</code> statements when you need to compare one variable against several possible constant values.</p><p class=\"mb-4 text-gray-300\">The <code>break</code> keyword is crucial. If you forget it, the code will \"fall through\" and execute the code in the next <code>case</code> as well, which is usually not what you want.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">int day = 4;\nString dayString;\n\nswitch (day) {\n    case 1:  dayString = \"Monday\";\n             break;\n    case 2:  dayString = \"Tuesday\";\n             break;\n    case 3:  dayString = \"Wednesday\";\n             break;\n    // ... and so on\n    default: dayString = \"Invalid day\";\n             break;\n}\nSystem.out.println(dayString); // Prints \"Wednesday\" if day was 3</pre></div><p class=\"mt-4 text-gray-300\">Your task is to build a switch statement for the character variable <code>grade</code>. Note that you need to declare the <code>comment</code> variable before the switch, but you will assign its value inside the different cases.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding switch statement is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying switch statement, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply switch statement will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with switch statement, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Strings",
        "Collections"
      ]
    },
    {
      "id": 24,
      "title": "24. Modifying Array Elements",
      "description": "Arrays are mutable, meaning you can change their contents. Access an element by its index and assign a new value to it.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String[] heroes = {\"Iron Man\", \"Thor\", \"Captain America\"};\n\n        // The Avengers have a new leader.\n        // Change the element at index 0 to \"Black Panther\".\n\n\n        // Print the first element of the array to confirm the change.\n\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String[] heroes = {\"Iron Man\", \"Thor\", \"Captain America\"};\n\n        // The Avengers have a new leader.\n        // Change the element at index 0 to \"Black Panther\".\n        heroes[0] = \"Black Panther\";\n\n        // Print the first element of the array to confirm the change.\n        System.out.println(heroes[0]);\n    }\n}",
      "expectedOutput": "Black Panther",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Because arrays are mutable (changeable), you can easily update their values. You use the same index syntax you used to read a value, but now you use it on the left side of an assignment operator (<code>=</code>).</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">int[] numbers = {1, 2, 99};\n\n// Print the original third element\nSystem.out.println(numbers[2]); // Prints 99\n\n// Change the value at index 2\nnumbers[2] = 3;\n\n// Print the new third element\nSystem.out.println(numbers[2]); // Prints 3</pre></div><p class=\"mt-4 text-gray-300\">Your task is to change the first element of the <code>heroes</code> array to \"Black Panther\" and then print that first element to the console.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding modifying array elements is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying modifying array elements, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply modifying array elements will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with modifying array elements, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Collections",
        "OOP",
        "Async"
      ]
    },
    {
      "title": "25. Array Loop Accumulators",
      "language": "java",
      "description": "Use a for loop to compute both the total and maximum value from the scores array, then print total followed by max.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        int[] scores = {10, 12, 8, 15, 7};\n\n        // Track running total and max score, then print them\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        int[] scores = {10, 12, 8, 15, 7};\n\n        int total = 0;\n        int max = scores[0];\n        for (int score : scores) {\n            total += score;\n            if (score > max) {\n                max = score;\n            }\n        }\n\n        System.out.println(total);\n        System.out.println(max);\n    }\n}\n",
      "expectedOutput": "52\n15",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Loops often keep state across iterations?running totals, min/max tracking, or flags. Initialize before the loop, update inside, and use the results afterward.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">int min = numbers[0];\nfor (int n : numbers) {\n    if (n < min) {\n        min = n;\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding array loop accumulators is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying array loop accumulators, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply array loop accumulators will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with array loop accumulators, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 25,
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 26,
      "title": "26. Sum of Array Elements",
      "description": "A common task is to iterate through an array to calculate a value. Use a for-each loop to calculate the sum of all numbers in an array.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        int[] numbers = {10, 20, 30, 40};\n        int sum = 0;\n\n        // Use a for-each loop to iterate through the 'numbers' array.\n        // In each iteration, add the current number to the 'sum' variable.\n\n\n        // After the loop, print the final sum.\n\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        int[] numbers = {10, 20, 30, 40};\n        int sum = 0;\n\n        // Use a for-each loop to iterate through the 'numbers' array.\n        // In each iteration, add the current number to the 'sum' variable.\n        for (int number : numbers) {\n            sum = sum + number;\n        }\n\n        // After the loop, print the final sum.\n        System.out.println(sum);\n    }\n}",
      "expectedOutput": "100",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson combines several concepts: arrays, loops, and variable modification. The goal is to create an \"accumulator\" variable (<code>sum</code>) that starts at 0. Then, you loop through each element of the array and add its value to your accumulator.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">int[] scores = {5, 10, 15};\nint total = 0;\n\nfor (int score : scores) {\n    total += score; // This is a shorthand for total = total + score;\n}\n\nSystem.out.println(\"The total is: \" + total); // Prints \"The total is: 30\"</pre></div><p class=\"mt-4 text-gray-300\">Your task is to do the same for the <code>numbers</code> array and print out the final calculated sum.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding sum of array elements is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying sum of array elements, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply sum of array elements will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with sum of array elements, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 27,
      "title": "27. Finding the Maximum Value",
      "description": "Iterate through an array to find the largest value. This is a classic algorithm that combines loops and conditional logic.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        int[] numbers = {1, 44, 7, 99, 23, 42};\n        int max = numbers[0]; // Assume the first element is the largest to start.\n\n        // Loop through the array starting from the SECOND element (index 1).\n        // If the current number is greater than 'max', update 'max'.\n\n\n        // After the loop, print the maximum value.\n        System.out.println(\"The maximum value is: \" + max);\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        int[] numbers = {1, 44, 7, 99, 23, 42};\n        int max = numbers[0]; // Assume the first element is the largest to start.\n\n        // Loop through the array starting from the SECOND element (index 1).\n        // If the current number is greater than 'max', update 'max'.\n        for (int i = 1; i < numbers.length; i++) {\n            if (numbers[i] > max) {\n                max = numbers[i];\n            }\n        }\n\n        // After the loop, print the maximum value.\n        System.out.println(\"The maximum value is: \" + max);\n    }\n}",
      "expectedOutput": "The maximum value is: 99",
      "tutorial": "<p class=\"mb-4 text-gray-300\">To find the maximum value in an array, you need a variable to keep track of the largest number found so far. A good strategy is to initialize this variable with the very first value from the array.</p><p class=\"mb-4 text-gray-300\">Then, you loop through the rest of the array. For each number, you compare it to your \"max so far\" variable. If the current number is larger, you update your max variable with the current number's value. By the end of the loop, your variable will hold the largest value in the entire array.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">int[] temps = {72, 85, 68, 91, 78};\nint highestTemp = temps[0]; // Start with 72\n\nfor (int temp : temps) {\n    if (temp > highestTemp) {\n        highestTemp = temp; // Update if we find a warmer day\n    }\n}\n\nSystem.out.println(highestTemp); // Prints 91</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding finding the maximum value is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying finding the maximum value, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply finding the maximum value will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with finding the maximum value, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 28,
      "title": "28. Finding the Average",
      "description": "Calculate the average of a list of numbers. This requires summing the elements and then performing floating-point division.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        int[] numbers = {10, 15, 20, 25, 30};\n        double sum = 0.0;\n\n        // First, loop through the numbers and calculate the sum.\n\n\n        // Next, calculate the average.\n        // To get an accurate decimal result, make sure to divide by a double.\n        double average = sum / numbers.length;\n\n        System.out.println(\"The average is: \" + average);\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        int[] numbers = {10, 15, 20, 25, 30};\n        double sum = 0.0;\n\n        // First, loop through the numbers and calculate the sum.\n        for (int number : numbers) {\n            sum += number;\n        }\n\n        // Next, calculate the average.\n        // To get an accurate decimal result, make sure to divide by a double.\n        double average = sum / numbers.length;\n\n        System.out.println(\"The average is: \" + average);\n    }\n}",
      "expectedOutput": "The average is: 20.0",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Calculating an average involves two steps: finding the sum of all elements, and then dividing by the number of elements.</p><p class=\"mb-4 text-gray-300\">A key concept in Java is integer division versus floating-point (double) division. If you divide an integer by an integer, Java will truncate the result (e.g., <code>5 / 2</code> is <code>2</code>). To get a precise decimal answer, at least one of the numbers in the division must be a double. We can do this by making our <code>sum</code> variable a double from the start.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">int a = 7;\nint b = 2;\nSystem.out.println(a / b); // Prints 3 (integer division)\n\ndouble c = 7.0;\nSystem.out.println(c / b); // Prints 3.5 (floating-point division)</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding finding the average is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying finding the average, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply finding the average will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with finding the average, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 29,
      "title": "29. Inheritance (extends)",
      "description": "Inheritance allows a new class (subclass) to inherit properties and methods from an existing class (superclass). Create a `Dog` class that inherits from `Animal`.",
      "initialCode": "class Animal {\n    public void eat() {\n        System.out.println(\"This animal eats food.\");\n    }\n}\n\nclass Dog extends Animal {\n    // Add a method called bark() that prints \"Woof!\"\n\n}\n\nclass Cat extends Animal {\n    // Add a method called bark() that prints \"Meow!\"\n\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animal myDog = new Dog();\n        Animal myCat = new Cat();\n        \n        myDog.eat();\n        myDog.bark();\n        myCat.eat();\n        myCat.bark();\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        Dog myDog = new Dog();\n        myDog.eat();\n        myDog.bark();\n    }\n}\n\nclass Animal {\n    void eat() {\n        System.out.println(\"This animal eats food\");\n    }\n}\n\nclass Dog extends Animal {\n    void bark() {\n        System.out.println(\"The dog barks\");\n    }\n}",
      "expectedOutput": "This animal eats food\\nThe dog barks",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><strong>Inheritance</strong> is a core principle of Object-Oriented Programming. It allows us to create a new class that is a modified version of an existing class. The new class (the <em>subclass</em>) inherits the fields and methods of the existing class (the <em>superclass</em>).</p><p class=\"mb-4 text-gray-300\">We use the <code>extends</code> keyword to do this. This promotes code reuse and creates a logical hierarchy.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Superclass\nclass Vehicle {\n    public void drive() {\n        System.out.println(\"Driving a vehicle.\");\n    }\n}\n\n// Subclass\nclass Car extends Vehicle {\n    public void honk() {\n        System.out.println(\"Beep beep!\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Car myCar = new Car();\n        myCar.drive(); // Inherited from Vehicle\n        myCar.honk();  // Defined in Car\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding inheritance (extends) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying inheritance (extends), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply inheritance (extends) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with inheritance (extends), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Functions",
        "OOP"
      ]
    },
    {
      "title": "30. Override toString()",
      "language": "java",
      "description": "Override toString() so printing a Student shows \"Student: <name> (<level>)\".",
      "initialCode": "class Student {\n    private final String name;\n    private final String level;\n\n    public Student(String name, String level) {\n        this.name = name;\n        this.level = level;\n    }\n\n    // Override toString here\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(new Student(\"Ada\", \"junior\"));\n    }\n}\n",
      "fullSolution": "class Student {\n    private final String name;\n    private final String level;\n\n    public Student(String name, String level) {\n        this.name = name;\n        this.level = level;\n    }\n\n    @Override\n    public String toString() {\n        return \"Student: \" + name + \" (\" + level + \")\";\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(new Student(\"Ada\", \"junior\"));\n    }\n}\n",
      "expectedOutput": "Student: Ada (junior)",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Override <code>toString()</code> to give your objects meaningful printouts, which helps debugging and logging.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">@Override\npublic String toString() {\n    return \"Point(\" + x + \", \" + y + \")\";\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding override tostring() is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying override tostring(), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply override tostring() will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with override tostring(), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 30,
      "tags": [
        "Beginner",
        "Basics",
        "OOP",
        "Debugging"
      ]
    },
    {
      "id": 31,
      "title": "31. Polymorphism & Overriding",
      "description": "Polymorphism allows objects of different classes to be treated as objects of a common superclass. This is often achieved by overriding methods.",
      "initialCode": "class Animal {\n    public void makeSound() {\n        System.out.println(\"Some generic animal sound\");\n    }\n}\n\nclass Dog extends Animal {\n    // Override the makeSound method to print \"Bark!\"\n\n}\n\nclass Cat extends Animal {\n    // Override the makeSound method to print \"Meow!\"\n\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animal myDog = new Dog();\n        Animal myCat = new Cat();\n        \n        myDog.makeSound();\n        myCat.makeSound();\n    }\n}",
      "fullSolution": "class Animal {\n    public void makeSound() {\n        System.out.println(\"Some generic animal sound\");\n    }\n}\n\nclass Dog extends Animal {\n    // Override the makeSound method to print \"Bark!\"\n    @Override\n    public void makeSound() {\n        System.out.println(\"Bark!\");\n    }\n}\n\nclass Cat extends Animal {\n    // Override the makeSound method to print \"Meow!\"\n    @Override\n    public void makeSound() {\n        System.out.println(\"Meow!\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animal myDog = new Dog();\n        Animal myCat = new Cat();\n        \n        myDog.makeSound();\n        myCat.makeSound();\n    }\n}",
      "expectedOutput": "Bark!\nMeow!",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><strong>Polymorphism</strong> means \"many forms\". In Java, it means you can perform a single action in different ways. A common way to use it is when a superclass reference variable is used to refer to a subclass object.</p><p class=\"mb-4 text-gray-300\">Method <strong>overriding</strong> is when a subclass provides a specific implementation for a method that is already defined in its superclass. The <code>@Override</code> annotation is used to indicate this; it's not required but is good practice as it helps the compiler catch errors.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">class Shape {\n    public void draw() {\n        System.out.println(\"Drawing a shape\");\n    }\n}\n\nclass Circle extends Shape {\n    @Override\n    public void draw() {\n        System.out.println(\"Drawing a circle\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Shape myShape = new Circle(); // Polymorphism!\n        myShape.draw(); // Calls the Circle's draw() method\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding polymorphism & overriding is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying polymorphism & overriding, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply polymorphism & overriding will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with polymorphism & overriding, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Functions",
        "OOP"
      ]
    },
    {
      "id": 32,
      "title": "32. ArrayList",
      "description": "An `ArrayList` is a resizable array, part of the Java Collections Framework. It's more flexible than a standard array.",
      "initialCode": "import java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create an ArrayList that can hold Strings\n        ArrayList<String> fruits = new ArrayList<>();\n\n        // Add \"Apple\", \"Banana\", and \"Cherry\" to the list\n\n\n        // Print the element at index 1\n\n    }\n}",
      "fullSolution": "import java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create an ArrayList that can hold Strings\n        ArrayList<String> fruits = new ArrayList<>();\n\n        // Add \"Apple\", \"Banana\", and \"Cherry\" to the list\n        fruits.add(\"Apple\");\n        fruits.add(\"Banana\");\n        fruits.add(\"Cherry\");\n\n        // Print the element at index 1\n        System.out.println(fruits.get(1));\n    }\n}",
      "expectedOutput": "Banana",
      "tutorial": "<p class=\"mb-4 text-gray-300\">While arrays are useful, their size is fixed once created. The <code>ArrayList</code> class provides a way to have a dynamic, resizable list of objects.</p><p class=\"mb-4 text-gray-300\">You must import it from <code>java.util.ArrayList</code>. Here are some common methods:</p><ul class=\"list-disc list-inside mb-4 text-gray-300 space-y-1\"><li><code>add(element)</code>: Adds an element to the end of the list.</li><li><code>get(index)</code>: Returns the element at the specified index.</li><li><code>size()</code>: Returns the number of elements in the list.</li><li><code>remove(index)</code>: Removes the element at the specified index.</li><li><code>set(index, element)</code>: Replaces the element at the specified index with a new one.</li></ul><p class=\"mb-4 text-gray-300\">ArrayList is a resizable list. Use add() to append and get() to access by index.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">java.util.List<Integer> list = new java.util.ArrayList<>();\nlist.add(1); list.add(2); list.add(3);\nSystem.out.println(list);</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding arraylist is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying arraylist, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply arraylist will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with arraylist, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 33,
      "title": "33. Interfaces",
      "description": "An interface is a completely abstract type that is used to group related methods with empty bodies. A class can `implement` an interface, promising to provide the code for its methods.",
      "initialCode": "// An interface is a contract for what a class can do.\ninterface Animal {\n    public void makeSound(); // No method body\n    public void sleep();\n}\n\n// This class must provide code for the Animal methods.\nclass Pig implements Animal {\n    // Provide the implementation for makeSound()\n\n    // Provide the implementation for sleep()\n\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Pig myPig = new Pig();\n        myPig.makeSound();\n        myPig.sleep();\n    }\n}",
      "fullSolution": "// An interface is a contract for what a class can do.\ninterface Animal {\n    public void makeSound(); // No method body\n    public void sleep();\n}\n\n// This class must provide code for the Animal methods.\nclass Pig implements Animal {\n    // Provide the implementation for makeSound()\n    public void makeSound() {\n        System.out.println(\"The pig says: wee wee\");\n    }\n    // Provide the implementation for sleep()\n    public void sleep() {\n        System.out.println(\"Zzz\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Pig myPig = new Pig();\n        myPig.makeSound();\n        myPig.sleep();\n    }\n}",
      "expectedOutput": "The pig says: wee wee\nZzz",
      "tutorial": "<p class=\"mb-4 text-gray-300\">An <strong>interface</strong> is like a blueprint for a class. It can only contain abstract methods (methods without a body) and constants. A class can <code>implement</code> one or more interfaces.</p><p class=\"mb-4 text-gray-300\">This is Java's way of achieving full abstraction and is a key part of designing large, flexible applications. It defines a \"contract\" that a class must follow if it implements the interface.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">interface Drivable {\n    public void startEngine();\n}\n\nclass Car implements Drivable {\n    public void startEngine() {\n        System.out.println(\"Car engine started.\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Car myCar = new Car();\n        myCar.startEngine();\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding interfaces is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying interfaces, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply interfaces will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with interfaces, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Functions",
        "OOP"
      ]
    },
    {
      "id": 34,
      "title": "34. Exception Handling (try-catch)",
      "description": "Robust programs must handle potential errors gracefully. Use a `try-catch` block to prevent a crash when trying to divide by zero.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        // Use a try-catch block to handle the potential error.\n        try {\n            int result = 10 / 0;\n            System.out.println(result);\n        } catch (Exception e) {\n            // In the catch block, print \"Error: Cannot divide by zero.\"\n\n        }\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        // Use a try-catch block to handle the potential error.\n        try {\n            int result = 10 / 0;\n            System.out.println(result);\n        } catch (Exception e) {\n            // In the catch block, print \"Error: Cannot divide by zero.\"\n            System.out.println(\"Error: Cannot divide by zero.\");\n        }\n    }\n}",
      "expectedOutput": "Error: Cannot divide by zero.",
      "tutorial": "<p class=\"mb-4 text-gray-300\">An <strong>exception</strong> is an event that disrupts the normal flow of a program. Java's exception handling mechanism allows you to manage these errors without crashing the application.</p><p class=\"mb-4 text-gray-300\">The <code>try</code> block contains the code that might throw an exception. The <code>catch</code> block contains the code that is executed if an exception of a specific type occurs in the <code>try</code> block.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">public class Main {\n    public static void main(String[] args) {\n        int[] numbers = {1, 2, 3};\n        try {\n            // This line will cause an ArrayIndexOutOfBoundsException\n            System.out.println(numbers[10]);\n        } catch (Exception e) {\n            // This block runs instead of the program crashing\n            System.out.println(\"Something went wrong.\");\n        }\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding exception handling (try-catch) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying exception handling (try-catch), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply exception handling (try-catch) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with exception handling (try-catch), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "OOP",
        "Concurrency"
      ]
    },
    {
      "id": 35,
      "title": "35. HashMap",
      "description": "A `HashMap` stores items in \"key/value\" pairs. Create a HashMap to store capital cities, add a few pairs, and then retrieve a value using its key.",
      "initialCode": "import java.util.HashMap;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create a HashMap to store String keys and String values\n        HashMap<String, String> capitalCities = new HashMap<>();\n\n        // Add some key-value pairs\n        capitalCities.put(\"England\", \"London\");\n        capitalCities.put(\"Germany\", \"Berlin\");\n        capitalCities.put(\"Japan\", \"Tokyo\");\n\n        // Retrieve and print the capital of Germany\n\n    }\n}",
      "fullSolution": "import java.util.HashMap;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create a HashMap to store String keys and String values\n        HashMap<String, String> capitalCities = new HashMap<>();\n\n        // Add some key-value pairs\n        capitalCities.put(\"England\", \"London\");\n        capitalCities.put(\"Germany\", \"Berlin\");\n        capitalCities.put(\"Japan\", \"Tokyo\");\n\n        // Retrieve and print the capital of Germany\n        System.out.println(capitalCities.get(\"Germany\"));\n    }\n}",
      "expectedOutput": "Berlin",
      "tutorial": "<p class=\"mb-4 text-gray-300\">A <code>HashMap</code> is a powerful data structure for storing key-value pairs, similar to a dictionary. Each value is associated with a unique key. It's incredibly fast for looking up values when you know the key.</p><p class=\"mb-4 text-gray-300\">Like <code>ArrayList</code>, you must import it from <code>java.util.HashMap</code>. Common methods include:</p><ul class=\"list-disc list-inside mb-4 text-gray-300 space-y-1\"><li><code>put(key, value)</code>: Adds a key-value pair.</li><li><code>get(key)</code>: Returns the value associated with the key.</li><li><code>remove(key)</code>: Removes the key-value pair.</li><li><code>size()</code>: Returns the number of pairs.</li></ul><p class=\"mb-4 text-gray-300\">Practice the concept using a short example below.</p> <h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"Hello, Java!\");</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding hashmap is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying hashmap, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply hashmap will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with hashmap, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Collections",
        "OOP"
      ]
    },
    {
      "title": "36. Mini Assert Utility",
      "language": "java",
      "description": "Implement a very small assertEquals helper that throws IllegalArgumentException on mismatch, then prints PASS.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        assertEquals(42, 40 + 2);\n    }\n\n    // Implement assertEquals(int expected, int actual)\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        assertEquals(42, 40 + 2);\n    }\n\n    static void assertEquals(int expected, int actual) {\n        if (expected != actual) {\n            throw new IllegalArgumentException(\"expected \" + expected + \" but got \" + actual);\n        }\n        System.out.println(\"PASS\");\n    }\n}\n",
      "expectedOutput": "PASS",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Testing frameworks throw when expectations fail. A tiny helper that compares values and raises on mismatch mirrors JUnit's behavior.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">static void assertTrue(boolean condition) {\n    if (!condition) throw new IllegalArgumentException(\"not true\");\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding mini assert utility is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying mini assert utility, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply mini assert utility will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with mini assert utility, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 36,
      "tags": [
        "Beginner",
        "Testing",
        "Basics",
        "Control Flow",
        "OOP"
      ]
    },
    {
      "title": "37. Read Env Default",
      "language": "java",
      "description": "Return an environment variable when set, otherwise a fallback value.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        System.out.println(getOrDefault(\"DATABASE_URL\", \"sqlite:///app.db\"));\n    }\n\n    // Implement getOrDefault(String key, String fallback)\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        System.out.println(getOrDefault(\"DATABASE_URL\", \"sqlite:///app.db\"));\n    }\n\n    static String getOrDefault(String key, String fallback) {\n        String value = System.getenv(key);\n        return value != null ? value : fallback;\n    }\n}\n",
      "expectedOutput": "sqlite:///app.db",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Environment variables are often optional during local development, so code should fall back to safe defaults.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Map&lt;String, String&gt; env = System.getenv();\nString url = env.getOrDefault(\"DATABASE_URL\", \"sqlite:///app.db\");\nSystem.out.println(url);</pre></div>\n<p class=\"mt-4 text-gray-300\">Cache System.getenv() in a local map so tests can stub it and you only look up the key once.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding read env default is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying read env default, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply read env default will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with read env default, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 37,
      "tags": [
        "Beginner",
        "Basics",
        "Collections",
        "OOP",
        "Databases"
      ]
    },
    {
      "id": 38,
      "title": "38. String Methods",
      "description": "The `String` class has many useful methods. Use `length()`, `toUpperCase()`, and `substring()` to manipulate a string and print the results.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String text = \"Hello Java\";\n\n        // Print the length of the string\n\n        // Print the string in all uppercase letters\n\n        // Print the substring \"Java\"\n\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String text = \"Hello Java\";\n\n        // Print the length of the string\n        System.out.println(\"Length: \" + text.length());\n\n        // Print the string in all uppercase letters\n        System.out.println(\"Uppercase: \" + text.toUpperCase());\n\n        // Print the substring \"Java\"\n        System.out.println(\"Substring: \" + text.substring(6));\n    }\n}",
      "expectedOutput": "Length: 10\nUppercase: HELLO JAVA\nSubstring: Java",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Strings in Java are objects, and they come with many built-in methods for common operations.</p><ul class=\"list-disc list-inside mb-4 text-gray-300 space-y-1\"><li><code>length()</code>: Returns the number of characters in the string.</li><li><code>toUpperCase()</code> / <code>toLowerCase()</code>: Returns a new string in the specified case.</li><li><code>substring(startIndex)</code>: Returns a new string from the start index to the end.</li><li><code>substring(startIndex, endIndex)</code>: Returns a new string from the start index up to (but not including) the end index.</li></ul><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">String greeting = \"Welcome!\";\nSystem.out.println(greeting.length()); // Prints 8\nSystem.out.println(greeting.substring(0, 3)); // Prints \"Wel\"</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding string methods is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying string methods, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply string methods will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with string methods, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Strings",
        "OOP"
      ]
    },
    {
      "id": 39,
      "title": "39. Math Class",
      "description": "The `Math` class contains methods for performing basic numeric operations. Use `Math.max()` and `Math.sqrt()` to find the larger of two numbers and the square root of another.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        // Find the larger of 25 and 42 using Math.max()\n        System.out.println(\"Max: \" + Math.max(25, 42));\n\n        // Find the square root of 64 using Math.sqrt()\n        System.out.println(\"Sqrt: \" + Math.sqrt(64));\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        // Find the larger of 25 and 42 using Math.max()\n        System.out.println(\"Max: \" + Math.max(25, 42));\n\n        // Find the square root of 64 using Math.sqrt()\n        System.out.println(\"Sqrt: \" + Math.sqrt(64));\n    }\n}",
      "expectedOutput": "Max: 42\nSqrt: 8.0",
      "tutorial": "<p class=\"mb-4 text-gray-300\">The <code>Math</code> class provides a collection of static methods for mathematical calculations. You don't need to create an object of the Math class; you can call its methods directly.</p><ul class=\"list-disc list-inside mb-4 text-gray-300 space-y-1\"><li><code>Math.max(a, b)</code>: Returns the largest of two values.</li><li><code>Math.min(a, b)</code>: Returns the smallest of two values.</li><li><code>Math.sqrt(n)</code>: Returns the square root of a number.</li><li><code>Math.random()</code>: Returns a random double between 0.0 and 1.0.</li><li><code>Math.abs(n)</code>: Returns the absolute (non-negative) value.</li></ul><p class=\"mb-4 text-gray-300\">Classes bundle data and behavior. Create an instance with new and call its methods.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">class Dog {\n  void bark() { System.out.println(\"Woof!\"); }\n}\nnew Dog().bark();</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding math class is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying math class, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply math class will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with math class, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 40,
      "title": "40. StringBuilder",
      "description": "When you need to build a string by appending many parts, `StringBuilder` is more efficient than regular string concatenation. Use it to build a sentence.",
      "initialCode": "import java.lang.StringBuilder;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create a new StringBuilder\n        StringBuilder builder = new StringBuilder();\n\n        // Append parts of a sentence\n        builder.append(\"Java \");\n        builder.append(\"is \");\n        builder.append(\"efficient!\");\n\n        // Convert the StringBuilder back to a String and print it\n\n    }\n}",
      "fullSolution": "import java.lang.StringBuilder;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create a new StringBuilder\n        StringBuilder builder = new StringBuilder();\n\n        // Append parts of a sentence\n        builder.append(\"Java \");\n        builder.append(\"is \");\n        builder.append(\"efficient!\");\n\n        // Convert the StringBuilder back to a String and print it\n        String result = builder.toString();\n        System.out.println(result);\n    }\n}",
      "expectedOutput": "Java is efficient!",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Every time you use the <code>+</code> operator to concatenate strings, Java creates a new string object in memory. This can be inefficient if you do it many times in a loop. <code>StringBuilder</code> is a mutable object that allows you to modify a sequence of characters without creating new objects for each change.</p><p class=\"mb-4 text-gray-300\">Use <code>append()</code> to add to the string. When you are finished, call <code>toString()</code> to get the final <code>String</code> object.</p><p class=\"mb-4 text-gray-300\">String methods like toLowerCase(), toUpperCase(), and length() return transformed information; Strings are immutable.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">String s = \"Java\";\nSystem.out.println(s.toLowerCase());\nSystem.out.println(s.toUpperCase());\nSystem.out.println(s.length());</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding stringbuilder is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying stringbuilder, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply stringbuilder will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with stringbuilder, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Strings",
        "OOP"
      ]
    },
    {
      "id": 41,
      "title": "41. The `super` Keyword",
      "description": "The `super` keyword refers to the superclass. It can be used to call the superclass's constructor or methods. Call the `Animal` constructor from the `Dog` constructor.",
      "initialCode": "class Animal {\n    String name;\n    public Animal(String name) {\n        this.name = name;\n        System.out.println(\"Animal constructor called for: \" + name);\n    }\n}\n\nclass Dog extends Animal {\n    public Dog(String name) {\n        // Use 'super' to call the constructor of the Animal class\n        // Pass the 'name' variable to it.\n\n        System.out.println(\"Dog constructor called.\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Dog myDog = new Dog(\"Fido\");\n    }\n}",
      "fullSolution": "class Animal {\n    String name;\n    public Animal(String name) {\n        this.name = name;\n        System.out.println(\"Animal constructor called for: \" + name);\n    }\n}\n\nclass Dog extends Animal {\n    public Dog(String name) {\n        // Use 'super' to call the constructor of the Animal class\n        // Pass the 'name' variable to it.\n        super(name);\n        System.out.println(\"Dog constructor called.\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Dog myDog = new Dog(\"Fido\");\n    }\n}",
      "expectedOutput": "Animal constructor called for: Fido\nDog constructor called.",
      "tutorial": "<p class=\"mb-4 text-gray-300\">The <code>super</code> keyword is used inside a subclass to refer to its immediate parent (superclass). There are two main uses:</p><ol class=\"list-decimal list-inside mb-4 text-gray-300 space-y-2\"><li><code>super(arguments)</code>: To call a constructor of the superclass. If used, it <strong>must</strong> be the very first statement in the subclass constructor.</li><li><code>super.methodName()</code>: To call a method of the superclass, which is useful if the subclass has overridden that method but you still need the original behavior.</li></ol><p class=\"mb-4 text-gray-300\">Practice the concept using a short example below.</p> <h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"Hello, Java!\");</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding the `super` keyword is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying the `super` keyword, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply the `super` keyword will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with the `super` keyword, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Functions",
        "OOP"
      ]
    },
    {
      "id": 42,
      "title": "42. Method Overloading",
      "description": "Method overloading allows you to define multiple methods with the same name in the same class, as long as they have different parameters. Create two `add` methods: one for integers and one for doubles.",
      "initialCode": "public class Main {\n\n    // Method to add two integers\n    public static int add(int a, int b) {\n        return a + b;\n    }\n\n    // Overload the add method to handle two doubles\n\n\n    public static void main(String[] args) {\n        int intSum = add(5, 10);\n        double doubleSum = add(3.5, 4.5);\n\n        System.out.println(\"Integer sum: \" + intSum);\n        System.out.println(\"Double sum: \" + doubleSum);\n    }\n}",
      "fullSolution": "public class Main {\n\n    // Method to add two integers\n    public static int add(int a, int b) {\n        return a + b;\n    }\n\n    // Overload the add method to handle two doubles\n    public static double add(double a, double b) {\n        return a + b;\n    }\n\n    public static void main(String[] args) {\n        int intSum = add(5, 10);\n        double doubleSum = add(3.5, 4.5);\n\n        System.out.println(\"Integer sum: \" + intSum);\n        System.out.println(\"Double sum: \" + doubleSum);\n    }\n}",
      "expectedOutput": "Integer sum: 15\nDouble sum: 8.0",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><strong>Method Overloading</strong> increases the readability of the program. It allows you to have multiple methods with the same name as long as their parameter lists are different (either by the number of parameters, the type of parameters, or both).</p><p class=\"mb-4 text-gray-300\">Java determines which version of the method to call based on the arguments you provide.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">public void display(int a) {\n    System.out.println(\"Got an Integer: \" + a);\n}\n\npublic void display(String s) {\n    System.out.println(\"Got a String: \" + s);\n}\n\ndisplay(100); // Calls the first method\ndisplay(\"Hello\"); // Calls the second method</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding method overloading is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying method overloading, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply method overloading will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with method overloading, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Functions",
        "Collections"
      ]
    },
    {
      "id": 43,
      "title": "43. Abstract Classes",
      "description": "An abstract class cannot be instantiated and can contain abstract methods (without a body). Create an abstract `Shape` class and a `Circle` subclass that implements its abstract method.",
      "initialCode": "// Abstract class\nabstract class Shape {\n    // Abstract method (does not have a body)\n    public abstract void draw();\n\n    // Regular method\n    public void moveTo() {\n        System.out.println(\"Shape moved.\");\n    }\n}\n\n// Subclass (inherits from Shape)\nclass Circle extends Shape {\n    // Provide an implementation for the abstract draw() method\n\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Circle myCircle = new Circle();\n        myCircle.draw();\n        myCircle.moveTo();\n    }\n}",
      "fullSolution": "// Abstract class\nabstract class Shape {\n    // Abstract method (does not have a body)\n    public abstract void draw();\n\n    // Regular method\n    public void moveTo() {\n        System.out.println(\"Shape moved.\");\n    }\n}\n\n// Subclass (inherits from Shape)\nclass Circle extends Shape {\n    // Provide an implementation for the abstract draw() method\n    public void draw() {\n        System.out.println(\"Drawing a circle.\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Circle myCircle = new Circle();\n        myCircle.draw();\n        myCircle.moveTo();\n    }\n}",
      "expectedOutput": "Drawing a circle.\nShape moved.",
      "tutorial": "<p class=\"mb-4 text-gray-300\">An <strong>abstract class</strong> is a restricted class that cannot be used to create objects. It serves as a base for subclasses. It can have both abstract and non-abstract (regular) methods.</p><p class=\"mb-4 text-gray-300\">An <strong>abstract method</strong> is a method that is declared without an implementation. Any subclass of an abstract class must either implement all of the superclass's abstract methods or be declared abstract itself.</p><p class=\"mb-4 text-gray-300\">This provides a middle ground between a regular class and an interface.</p><p class=\"mb-4 text-gray-300\">Classes bundle data and behavior. Create an instance with new and call its methods.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">class Dog {\n  void bark() { System.out.println(\"Woof!\"); }\n}\nnew Dog().bark();</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding abstract classes is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying abstract classes, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply abstract classes will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with abstract classes, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Functions",
        "OOP"
      ]
    },
    {
      "id": 44,
      "title": "44. Type Casting",
      "description": "Type casting is when you assign a value of one primitive data type to another type. Perform both widening (automatic) and narrowing (manual) casting.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        // Widening Casting (int to double)\n        int myInt = 9;\n        double myDouble = myInt; // Automatic casting\n        System.out.println(myDouble);\n\n        // Narrowing Casting (double to int)\n        double anotherDouble = 9.78;\n        // Manually cast the double to an int and store it in anotherInt\n        int anotherInt = (int) anotherDouble;\n\n        System.out.println(anotherInt);\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        // Widening Casting (int to double)\n        int myInt = 9;\n        double myDouble = myInt; // Automatic casting\n        System.out.println(myDouble);\n\n        // Narrowing Casting (double to int)\n        double anotherDouble = 9.78;\n        // Manually cast the double to an int and store it in anotherInt\n        int anotherInt = (int) anotherDouble;\n\n        System.out.println(anotherInt);\n    }\n}",
      "expectedOutput": "9.0\n9",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Type casting is used to convert variables from one data type to another.</p><ul class=\"list-disc list-inside mb-4 text-gray-300 space-y-2\"><li><strong>Widening Casting</strong>: Happens automatically when passing a smaller size type to a larger size type (e.g., <code>int</code> to <code>double</code>). This is safe as there is no data loss.</li><li><strong>Narrowing Casting</strong>: Must be done manually by placing the type in parentheses in front of the value (e.g., <code>(int)</code>). This can lead to data loss, as you are fitting a larger type into a smaller one. For example, casting a <code>double</code> to an <code>int</code> will truncate the decimal part.</li></ul><p class=\"mb-4 text-gray-300\">Practice the concept using a short example below.</p> <h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"Hello, Java!\");</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding type casting is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying type casting, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply type casting will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with type casting, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "OOP",
        "Math and Stats"
      ]
    },
    {
      "id": 45,
      "title": "45. Ternary Operator",
      "description": "The ternary operator is a shorthand for an if-else statement. Use it to assign a value to the `result` string based on a condition.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        int time = 20;\n        String result;\n\n        // Use the ternary operator to set 'result'.\n        // If time < 18, it should be \"Good day.\"\n        // Otherwise, it should be \"Good evening.\"\n        result = (time < 18) ? \"Good day.\" : \"Good evening.\";\n\n        System.out.println(result);\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        int time = 20;\n        String result;\n\n        // Use the ternary operator to set 'result'.\n        // If time < 18, it should be \"Good day.\"\n        // Otherwise, it should be \"Good evening.\"\n        result = (time < 18) ? \"Good day.\" : \"Good evening.\";\n\n        System.out.println(result);\n    }\n}",
      "expectedOutput": "Good evening.",
      "tutorial": "<p class=\"mb-4 text-gray-300\">The ternary operator provides a concise way to write simple conditional assignments. Its syntax is:</p><p class=\"mb-4 text-gray-300\"><code>variable = (condition) ? valueIfTrue : valueIfFalse;</code></p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Using if-else\nint x = 10;\nString message;\nif (x > 5) {\n    message = \"x is greater than 5\";\n} else {\n    message = \"x is not greater than 5\";\n}\n\n// Using ternary operator (equivalent)\nString message2 = (x > 5) ? \"x is greater than 5\" : \"x is not greater than 5\";</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding ternary operator is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying ternary operator, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply ternary operator will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with ternary operator, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 46,
      "title": "46. Do-While Loop",
      "description": "A `do-while` loop is a variant of the while loop which executes the code block once before checking the condition. Use it to print a countdown that includes 0.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        int i = 3;\n\n        // Create a do-while loop that prints 'i' and decrements it.\n        // The loop should continue as long as i is greater than or equal to 0.\n\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        int i = 3;\n\n        // Create a do-while loop that prints 'i' and decrements it.\n        // The loop should continue as long as i is greater than or equal to 0.\n        do {\n            System.out.println(i);\n            i--;\n        } while (i >= 0);\n    }\n}",
      "expectedOutput": "3\n2\n1\n0",
      "tutorial": "<p class=\"mb-4 text-gray-300\">The <code>do-while</code> loop is similar to a <code>while</code> loop, but with one key difference: the condition is checked <em>after</em> the loop body is executed. This guarantees that the loop will run at least once, regardless of whether the condition is true or false.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">int count = 5;\n\ndo {\n    System.out.println(\"This will print at least once.\");\n} while (count < 3); // Condition is false, but loop ran once.</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding do-while loop is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying do-while loop, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply do-while loop will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with do-while loop, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "OOP",
        "Concurrency"
      ]
    },
    {
      "title": "47. Primitive vs Reference & Autoboxing",
      "language": "java",
      "description": "Autobox an int into a list, then compare two Integer objects created with valueOf to show equals vs ==.",
      "initialCode": "import java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) {\n        ArrayList<Integer> numbers = new ArrayList<>();\n        int primitive = 256;\n\n        // Autobox primitive into the list\n        // Create two Integer objects using Integer.valueOf(256)\n        // Print the first element of the list\n        // Print boxed.equals(other)\n        // Print boxed == other\n    }\n}\n",
      "fullSolution": "import java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) {\n        ArrayList<Integer> numbers = new ArrayList<>();\n        int primitive = 256;\n\n        numbers.add(primitive); // autobox\n        Integer boxed = Integer.valueOf(256);\n        Integer other = Integer.valueOf(256);\n\n        System.out.println(numbers.get(0));\n        System.out.println(boxed.equals(other));\n        System.out.println(boxed == other);\n    }\n}\n",
      "expectedOutput": "256\ntrue\nfalse",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Collections hold objects, so primitives auto-convert to their wrapper classes (autoboxing). Two wrapper objects can be equal in value yet occupy different references, so <code>.equals()</code> is the safe comparison.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Integer a = Integer.valueOf(256);\nInteger b = Integer.valueOf(256);\nSystem.out.println(a.equals(b)); // true\nSystem.out.println(a == b);      // false</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding primitive vs reference & autoboxing is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying primitive vs reference & autoboxing, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply primitive vs reference & autoboxing will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with primitive vs reference & autoboxing, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 47,
      "tags": [
        "Beginner",
        "Basics",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 48,
      "title": "48. Wrapper Classes",
      "description": "Wrapper classes provide a way to use primitive data types (like `int`) as objects. Create an `Integer` object and use one of its methods.",
      "initialCode": "import java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) {\n        // ArrayLists cannot store primitives, they need objects.\n        ArrayList<Integer> myNumbers = new ArrayList<>();\n\n        // Create an Integer wrapper object\n        Integer myInt = 500;\n\n        // Add it to the list\n        myNumbers.add(myInt);\n\n        // Use a method from the Integer wrapper class, like toString(), and print it.\n\n    }\n}",
      "fullSolution": "import java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) {\n        // ArrayLists cannot store primitives, they need objects.\n        ArrayList<Integer> myNumbers = new ArrayList<>();\n\n        // Create an Integer wrapper object\n        Integer myInt = 500;\n\n        // Add it to the list\n        myNumbers.add(myInt);\n\n        // Use a method from the Integer wrapper class, like toString(), and print it.\n        String intAsString = myInt.toString();\n        System.out.println(\"String length: \" + intAsString.length());\n    }\n}",
      "expectedOutput": "String length: 3",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Java has two categories of data types: primitive types and reference types (objects). Sometimes you need to treat a primitive like an object, for example, when using it with collections like <code>ArrayList</code>. Wrapper classes solve this problem.</p><p class=\"mb-4 text-gray-300\">Each primitive has a corresponding wrapper class:</p><ul class=\"list-disc list-inside mb-4 text-gray-300 space-y-1\"><li><code>int</code> -> <code>Integer</code></li><li><code>double</code> -> <code>Double</code></li><li><code>char</code> -> <code>Character</code></li><li><code>boolean</code> -> <code>Boolean</code></li></ul><p class=\"mb-4 text-gray-300\">The process of converting a primitive to a wrapper object is called <strong>autoboxing</strong>, and the reverse is called <strong>unboxing</strong>. Java often does this automatically for you.</p><p class=\"mb-4 text-gray-300\">Classes bundle data and behavior. Create an instance with new and call its methods.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">class Dog {\n  void bark() { System.out.println(\"Woof!\"); }\n}\nnew Dog().bark();</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding wrapper classes is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying wrapper classes, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply wrapper classes will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with wrapper classes, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Functions",
        "Strings"
      ]
    },
    {
      "id": 49,
      "title": "49. Recursion",
      "description": "Recursion is the technique of making a function call itself. Create a recursive function to calculate the sum of all numbers up to n.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        int result = sum(5);\n        System.out.println(result);\n    }\n\n    // Create the recursive sum method\n    public static int sum(int k) {\n        // The base case: if k is 0, stop and return 0.\n\n        // The recursive step: return k + the sum of all numbers below k.\n\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        int result = sum(5);\n        System.out.println(result);\n    }\n\n    // Create the recursive sum method\n    public static int sum(int k) {\n        // The base case: if k is 0, stop and return 0.\n        if (k > 0) {\n            // The recursive step: return k + the sum of all numbers below k.\n            return k + sum(k - 1);\n        } else {\n            return 0;\n        }\n    }\n}",
      "expectedOutput": "15",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Recursion is a powerful but tricky concept where a method calls itself to solve a problem. It breaks a complex problem into smaller, identical subproblems.</p><p class=\"mb-4 text-gray-300\">Every recursive function must have two parts:</p><ol class=\"list-decimal list-inside mb-4 text-gray-300 space-y-2\"><li>A <strong>base case</strong>: A condition that stops the recursion. Without it, you'll get an infinite loop and a <code>StackOverflowError</code>.</li><li>A <strong>recursive step</strong>: The part of the function that calls itself, usually with a modified argument that brings it closer to the base case.</li></ol><p class=\"mb-4 text-gray-300\">For this problem, summing numbers up to 5 (5+4+3+2+1) can be thought of as <code>5 + sum(4)</code>, and <code>sum(4)</code> is <code>4 + sum(3)</code>, and so on, until you reach the base case of <code>sum(0)</code>.</p><p class=\"mb-4 text-gray-300\">Practice the concept using a short example below.</p> <h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"Hello, Java!\");</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding recursion is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying recursion, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply recursion will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with recursion, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Functions",
        "OOP"
      ]
    },
    {
      "id": 50,
      "title": "50. 2D Arrays",
      "description": "A 2D array is like a grid or a table, an array of arrays. Create a 2D array and access an element from a specific row and column.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        // Create a 2D integer array (a 2x3 matrix)\n        int[][] myNumbers = { {1, 2, 3}, {4, 5, 6} };\n\n        // Access the element in the second row (index 1)\n        // and the third column (index 2).\n        // Print the result.\n\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        // Create a 2D integer array (a 2x3 matrix)\n        int[][] myNumbers = { {1, 2, 3}, {4, 5, 6} };\n\n        // Access the element in the second row (index 1)\n        // and the third column (index 2).\n        // Print the result.\n        int value = myNumbers[1][2];\n        System.out.println(value);\n    }\n}",
      "expectedOutput": "6",
      "tutorial": "<p class=\"mb-4 text-gray-300\">A 2D array is an array where each element is itself another array. It's useful for representing data in a grid-like structure, such as a tic-tac-toe board or a spreadsheet.</p><p class=\"mb-4 text-gray-300\">You declare it with two sets of square brackets (e.g., <code>int[][]</code>). To access an element, you provide two indices: the first for the row and the second for the column.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">String[][] board = {\n    {\"X\", \"O\", \"X\"},\n    {\"O\", \"X\", \"O\"},\n    {\"X\", \"O\", \"X\"}\n};\n\n// Access the middle element (row 1, column 1)\nSystem.out.println(board[1][1]); // Prints \"X\"</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding 2d arrays is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying 2d arrays, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply 2d arrays will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with 2d arrays, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 51,
      "title": "51. Looping Through 2D Arrays",
      "description": "To iterate over all elements in a 2D array, you need nested loops: one for the rows and one for the columns.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        int[][] myNumbers = { {1, 2, 3}, {4, 5, 6} };\n\n        // Use nested for loops to print all elements.\n        // The outer loop iterates through the rows (myNumbers.length).\n        // The inner loop iterates through the columns of the current row (myNumbers[i].length).\n\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        int[][] myNumbers = { {1, 2, 3}, {4, 5, 6} };\n\n        // Use nested for loops to print all elements.\n        // The outer loop iterates through the rows (myNumbers.length).\n        // The inner loop iterates through the columns of the current row (myNumbers[i].length).\n        for (int i = 0; i < myNumbers.length; i++) {\n            for (int j = 0; j < myNumbers[i].length; j++) {\n                System.out.println(myNumbers[i][j]);\n            }\n        }\n    }\n}",
      "expectedOutput": "1\n2\n3\n4\n5\n6",
      "tutorial": "<p class=\"mb-4 text-gray-300\">To process every element in a 2D array, a common pattern is to use a \"nested loop\" â€” a loop inside another loop.</p><p class=\"mb-4 text-gray-300\">The outer loop iterates through each of the main arrays (the rows). The inner loop then iterates through all the elements within that specific row-array (the columns).</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example with for-each loops:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">String[][] data = {{\"A\", \"B\"}, {\"C\", \"D\"}};\n\nfor (String[] row : data) {\n    for (String element : row) {\n        System.out.print(element + \" \"); // Prints \"A B C D \"\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding looping through 2d arrays is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying looping through 2d arrays, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply looping through 2d arrays will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with looping through 2d arrays, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 52,
      "title": "52. The `final` Keyword",
      "description": "The `final` keyword is used to make a variable a constant, meaning its value cannot be changed. Try to change a final variable to see the error, then fix it by removing the attempt to change it.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        // A final variable's value cannot be changed.\n        final int MY_NUMBER = 15;\n\n        // This line will cause a compilation error. \n        // To pass the lesson, remove or comment out this line.\n        MY_NUMBER = 20;\n\n        System.out.println(MY_NUMBER);\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        // A final variable's value cannot be changed.\n        final int MY_NUMBER = 15;\n\n        // This line will cause a compilation error. \n        // To pass the lesson, remove or comment out this line.\n        // MY_NUMBER = 20;\n\n        System.out.println(MY_NUMBER);\n    }\n}",
      "expectedOutput": "15",
      "tutorial": "<p class=\"mb-4 text-gray-300\">The <code>final</code> keyword is a non-access modifier used for classes, methods, and variables. It has different meanings depending on the context:</p><ul class=\"list-disc list-inside mb-4 text-gray-300 space-y-2\"><li><strong>final variable</strong>: Creates a constant. Its value cannot be changed after it has been assigned. By convention, constant names are written in all uppercase letters.</li><li><strong>final method</strong>: Cannot be overridden by a subclass.</li><li><strong>final class</strong>: Cannot be extended (inherited from) by another class.</li></ul><p class=\"mb-4 text-gray-300\">This lesson focuses on final variables. Attempting to reassign a final variable will result in a compile-time error.</p><p class=\"mb-4 text-gray-300\">Practice the concept using a short example below.</p> <h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"Hello, Java!\");</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding the `final` keyword is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying the `final` keyword, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply the `final` keyword will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with the `final` keyword, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Functions",
        "Strings"
      ]
    },
    {
      "id": 53,
      "title": "53. Enums",
      "description": "An enum is a special \"class\" that represents a group of constants. Define an enum for difficulty levels and use it in a switch statement.",
      "initialCode": "// Define an enum for game difficulty levels\nenum Level {\n    EASY,\n    MEDIUM,\n    HARD\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Level myLevel = Level.MEDIUM;\n\n        // Use a switch statement to print a message based on the level\n\n    }\n}",
      "fullSolution": "// Define an enum for game difficulty levels\nenum Level {\n    EASY,\n    MEDIUM,\n    HARD\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Level myLevel = Level.MEDIUM;\n\n        // Use a switch statement to print a message based on the level\n        switch(myLevel) {\n            case EASY:\n                System.out.println(\"Easy level\");\n                break;\n            case MEDIUM:\n                System.out.println(\"Medium level\");\n                break;\n            case HARD:\n                System.out.println(\"Hard level\");\n                break;\n        }\n    }\n}",
      "expectedOutput": "Medium level",
      "tutorial": "<p class=\"mb-4 text-gray-300\">An <code>enum</code> (short for enumeration) is a special data type that enables for a variable to be a set of predefined constants. The variable must be equal to one of the values that have been predefined for it.</p><p class=\"mb-4 text-gray-300\">Enums are useful when you have a value that you know is one of a small, fixed set of possibilities, such as days of the week, compass directions, or states in a game. They make code more readable and prevent errors from using invalid values.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">enum Direction {\n    NORTH, SOUTH, EAST, WEST\n}\n\nDirection myDir = Direction.NORTH;\n\nif (myDir == Direction.NORTH) {\n    System.out.println(\"Heading North!\");\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding enums is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying enums, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply enums will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with enums, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 54,
      "title": "54. Access Modifiers (private)",
      "description": "Access modifiers control the visibility of classes, fields, and methods. Use the `private` keyword to encapsulate data and provide public getter/setter methods.",
      "initialCode": "class Person {\n    // Make the 'name' variable private\n    public String name;\n\n    // Public getter method\n    public String getName() {\n        return name;\n    }\n\n    // Public setter method\n    public void setName(String newName) {\n        this.name = newName;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Person myPerson = new Person();\n        // This would cause an error if 'name' were private: myPerson.name = \"John\";\n        \n        // Use the setter to change the name\n\n        // Use the getter to retrieve and print the name\n\n    }\n}",
      "fullSolution": "class Person {\n    // Make the 'name' variable private\n    private String name;\n\n    // Public getter method\n    public String getName() {\n        return name;\n    }\n\n    // Public setter method\n    public void setName(String newName) {\n        this.name = newName;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Person myPerson = new Person();\n        // This would cause an error if 'name' were private: myPerson.name = \"John\";\n        \n        // Use the setter to change the name\n        myPerson.setName(\"Alice\");\n\n        // Use the getter to retrieve and print the name\n        System.out.println(myPerson.getName());\n    }\n}",
      "expectedOutput": "Alice",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Java has four access modifiers:</p><ul class=\"list-disc list-inside mb-4 text-gray-300 space-y-2\"><li><code>public</code>: The code is accessible for all classes.</li><li><code>private</code>: The code is only accessible within the declared class.</li><li><code>protected</code>: The code is accessible in the same package and subclasses.</li><li><strong>default</strong> (no keyword): The code is only accessible in the same package.</li></ul><p class=\"mb-4 text-gray-300\">The <code>private</code> modifier is central to the concept of <strong>encapsulation</strong>. It hides sensitive data from the outside world. To access or modify private data, you provide public \"getter\" and \"setter\" methods.</p><p class=\"mb-4 text-gray-300\">Practice the concept using a short example below.</p> <h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"Hello, Java!\");</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding access modifiers (private) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying access modifiers (private), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply access modifiers (private) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with access modifiers (private), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Functions",
        "OOP"
      ]
    },
    {
      "id": 55,
      "title": "55. The `continue` Keyword",
      "description": "The `continue` statement breaks one iteration (in the loop), if a specified condition occurs, and continues with the next iteration in the loop. Use it to print only the odd numbers.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        for (int i = 0; i < 10; i++) {\n            // If 'i' is an even number, skip this iteration\n            if (i % 2 == 0) {\n                \n            }\n            System.out.println(i);\n        }\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        for (int i = 0; i < 10; i++) {\n            // If 'i' is an even number, skip this iteration\n            if (i % 2 == 0) {\n                continue;\n            }\n            System.out.println(i);\n        }\n    }\n}",
      "expectedOutput": "1\n3\n5\n7\n9",
      "tutorial": "<p class=\"mb-4 text-gray-300\">While <code>break</code> exits a loop entirely, <code>continue</code> just skips the current iteration. When the <code>continue</code> statement is executed, the program immediately jumps to the loop's next iteration, bypassing any remaining code in the current iteration.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Don't print the number 5\nfor (int i = 0; i < 10; i++) {\n    if (i == 5) {\n        continue; // Skip the rest of the loop body when i is 5\n    }\n    System.out.println(i);\n}</pre></div><p class=\"mt-4 text-gray-300\">In this lesson, you'll use the modulo operator (<code>%</code>) to check for even numbers and skip them with <code>continue</code>.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding the `continue` keyword is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying the `continue` keyword, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply the `continue` keyword will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with the `continue` keyword, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "OOP"
      ]
    },
    {
      "id": 56,
      "title": "56. Iterating through a HashMap",
      "description": "You can loop through the keys, values, or key-value pairs of a HashMap. Use a for-each loop to print all the keys in the map.",
      "initialCode": "import java.util.HashMap;\n\npublic class Main {\n    public static void main(String[] args) {\n        HashMap<String, String> capitalCities = new HashMap<>();\n        capitalCities.put(\"England\", \"London\");\n        capitalCities.put(\"Germany\", \"Berlin\");\n        capitalCities.put(\"Japan\", \"Tokyo\");\n\n        // Use keySet() and a for-each loop to print each country name.\n\n    }\n}",
      "fullSolution": "import java.util.HashMap;\n\npublic class Main {\n    public static void main(String[] args) {\n        HashMap<String, String> capitalCities = new HashMap<>();\n        capitalCities.put(\"England\", \"London\");\n        capitalCities.put(\"Germany\", \"Berlin\");\n        capitalCities.put(\"Japan\", \"Tokyo\");\n\n        // Use keySet() and a for-each loop to print each country name.\n        for (String country : capitalCities.keySet()) {\n            System.out.println(country);\n        }\n    }\n}",
      "expectedOutput": "England\nGermany\nJapan",
      "tutorial": "<p class=\"mb-4 text-gray-300\">There are several ways to loop through a <code>HashMap</code>:</p><ul class=\"list-disc list-inside mb-4 text-gray-300 space-y-2\"><li><code>keySet()</code>: Returns a set of all the keys. You can iterate through this set and use <code>get()</code> to retrieve each value.</li><li><code>values()</code>: Returns a collection of all the values. Use this if you don't need the keys.</li><li><code>entrySet()</code>: Returns a set of all key-value pairs (as <code>Map.Entry</code> objects). This is the most efficient method if you need both the key and the value in each iteration.</li></ul><h4 class=\"font-semibold text-gray-200 mb-2\">Example using entrySet():</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">for (Map.Entry<String, String> entry : capitalCities.entrySet()) {\n    System.out.println(\"Key: \" + entry.getKey() + \", Value: \" + entry.getValue());\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding iterating through a hashmap is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying iterating through a hashmap, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply iterating through a hashmap will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with iterating through a hashmap, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Functions",
        "Collections"
      ]
    },
    {
      "id": 57,
      "title": "57. The `this` Keyword",
      "description": "The `this` keyword refers to the current object instance. It is commonly used to resolve ambiguity between instance variables and parameters.",
      "initialCode": "class Car {\n    String model;\n\n    // Constructor\n    public Car(String model) {\n        // Use 'this' to distinguish between the instance variable 'model'\n        // and the parameter 'model'.\n        model = model;\n    }\n\n    public void printModel() {\n        System.out.println(\"Car model: \" + this.model);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Car myCar = new Car(\"Mustang\");\n        myCar.printModel();\n    }\n}",
      "fullSolution": "class Car {\n    String model;\n\n    // Constructor\n    public Car(String model) {\n        // Use 'this' to distinguish between the instance variable 'model'\n        // and the parameter 'model'.\n        this.model = model;\n    }\n\n    public void printModel() {\n        System.out.println(\"Car model: \" + this.model);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Car myCar = new Car(\"Mustang\");\n        myCar.printModel();\n    }\n}",
      "expectedOutput": "Car model: Mustang",
      "tutorial": "<p class=\"mb-4 text-gray-300\">The <code>this</code> keyword is a reference to the current object â€” the object whose method or constructor is being called. It can be used to:</p><ul class=\"list-disc list-inside mb-4 text-gray-300 space-y-2\"><li>Disambiguate between instance variables and parameters when they have the same name (the most common use).</li><li>Call another constructor in the same class (e.g., <code>this(arguments)</code>).</li><li>Pass the current object as an argument in a method call.</li></ul><p class=\"mb-4 text-gray-300\">When a parameter has the same name as an instance variable, the parameter \"shadows\" the instance variable. Using <code>this.variableName</code> ensures you are referring to the instance variable.</p><p class=\"mb-4 text-gray-300\">Practice the concept using a short example below.</p> <h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"Hello, Java!\");</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding the `this` keyword is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying the `this` keyword, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply the `this` keyword will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with the `this` keyword, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Functions",
        "OOP"
      ]
    },
    {
      "id": 58,
      "title": "58. Reading Numbers with Scanner",
      "description": "The `Scanner` class can read specific data types, not just strings. Use `nextInt()` to read an integer from the user and perform a calculation.",
      "initialCode": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your age:\");\n\n        // Use nextInt() to read the user's age\n        int age = scanner.nextInt();\n\n        int ageInTenYears = age + 10;\n        System.out.println(\"In ten years, you will be \" + ageInTenYears + \".\");\n    }\n}",
      "fullSolution": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your age:\");\n\n        // Use nextInt() to read the user's age\n        int age = scanner.nextInt();\n\n        int ageInTenYears = age + 10;\n        System.out.println(\"In ten years, you will be \" + ageInTenYears + \".\");\n    }\n}",
      "userInput": [
        "25"
      ],
      "expectedOutput": "Enter your age:\nIn ten years, you will be 35.",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Besides <code>nextLine()</code>, the <code>Scanner</code> class provides methods to read specific data types directly:</p><ul class=\"list-disc list-inside mb-4 text-gray-300 space-y-1\"><li><code>nextInt()</code></li><li><code>nextDouble()</code></li><li><code>nextBoolean()</code></li><li><code>next()</code> (reads the next word, not the whole line)</li></ul><p class=\"mb-4 text-gray-300\">Using these methods can be more convenient than reading a line as a string and then converting it manually. The simulation for this lesson will provide the number \"25\" as input.</p><p class=\"mb-4 text-gray-300\">Read input from the console with java.util.Scanner. Close scanners in real programs to free resources.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.Scanner;\nScanner scanner = new Scanner(System.in);\nString name = scanner.nextLine();\nSystem.out.println(\"Hello, \" + name);</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding reading numbers with scanner is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying reading numbers with scanner, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply reading numbers with scanner will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with reading numbers with scanner, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "OOP"
      ]
    },
    {
      "id": 59,
      "title": "59. String Comparison",
      "description": "When comparing strings for equality, you should use the `.equals()` method, not the `==` operator. The `==` operator checks if two references point to the same object, while `.equals()` checks if the string contents are the same.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String a = \"hello\";\n        String b = new String(\"hello\");\n\n        // This will print false, because they are different objects\n        System.out.println(\"Using == : \" + (a == b));\n\n        // Use the .equals() method to correctly compare the content of the strings\n        // and print the result.\n        System.out.print(\"Using .equals() : \" + a.equals(b));\n\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String a = \"hello\";\n        String b = new String(\"hello\");\n\n        // This will print false, because they are different objects\n        System.out.println(\"Using == : \" + (a == b));\n\n        // Use the .equals() method to correctly compare the content of the strings\n        // and print the result.\n        System.out.print(\"Using .equals() : \" + a.equals(b));\n    }\n}",
      "expectedOutput": "Using == : false\nUsing .equals() : true",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This is a very common point of confusion for new Java programmers. For primitive types (like <code>int</code>, <code>boolean</code>), the <code>==</code> operator works as expected, comparing their values.</p><p class=\"mb-4 text-gray-300\">However, for objects (like <code>String</code>), <code>==</code> checks if the two variables refer to the exact same object in memory. The <code>.equals()</code> method, on the other hand, is defined in the class to provide a meaningful comparison of the objects' actual contents.</p><p class=\"mb-4 text-gray-300\"><strong>Rule of thumb:</strong> Always use <code>.equals()</code> to compare strings for equality.</p><p class=\"mb-4 text-gray-300\">String methods like toLowerCase(), toUpperCase(), and length() return transformed information; Strings are immutable.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">String s = \"Java\";\nSystem.out.println(s.toLowerCase());\nSystem.out.println(s.toUpperCase());\nSystem.out.println(s.length());</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding string comparison is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying string comparison, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply string comparison will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with string comparison, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "Functions",
        "OOP"
      ]
    },
    {
      "id": 60,
      "title": "60. The `finally` Block",
      "description": "The `finally` block in a try-catch statement always executes, regardless of whether an exception was thrown or not. It is used to run important cleanup code.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        try {\n            System.out.println(\"Inside the try block.\");\n            // int x = 5 / 0; // Uncomment to see exception path\n        } catch (Exception e) {\n            System.out.println(\"Inside the catch block.\");\n        } finally {\n            // This block will always execute. Print a message here.\n\n        }\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        try {\n            System.out.println(\"Inside the try block.\");\n            // int x = 5 / 0; // Uncomment to see exception path\n        } catch (Exception e) {\n            System.out.println(\"Inside the catch block.\");\n        } finally {\n            // This block will always execute. Print a message here.\n            System.out.println(\"Inside the finally block. Cleanup complete.\");\n        }\n    }\n}",
      "expectedOutput": "Inside the try block.\nInside the finally block. Cleanup complete.",
      "tutorial": "<p class=\"mb-4 text-gray-300\">The <code>try-catch-finally</code> structure provides robust error handling. The flow is as follows:</p><ol class=\"list-decimal list-inside mb-4 text-gray-300 space-y-2\"><li>The <code>try</code> block is executed.</li><li>If an exception occurs, the corresponding <code>catch</code> block is executed.</li><li>The <code>finally</code> block is <strong>always</strong> executed, whether an exception happened or not. This makes it the perfect place for cleanup code, like closing files or network connections, to ensure resources are released properly.</li></ol><p class=\"mb-4 text-gray-300\">Practice the concept using a short example below.</p> <h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"Hello, Java!\");</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding the `finally` block is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying the `finally` block, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply the `finally` block will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with the `finally` block, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Basics",
        "Control Flow",
        "OOP",
        "Concurrency"
      ]
    },
    {
      "id": 61,
      "title": "61. The `instanceof` Operator",
      "description": "The `instanceof` operator checks whether an object is an instance of a specific class or an interface. Use it to determine the true type of an object.",
      "initialCode": "class Animal {}\nclass Dog extends Animal {}\nclass Cat extends Animal {}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animal myPet = new Dog();\n\n        // Check if myPet is an instance of Dog\n        System.out.println(\"Is it a Dog? \" + (myPet instanceof Dog));\n\n        // Check if myPet is an instance of Cat\n\n\n        // Check if myPet is an instance of Animal (its superclass)\n\n    }\n}",
      "fullSolution": "class Animal {}\nclass Dog extends Animal {}\nclass Cat extends Animal {}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animal myPet = new Dog();\n\n        // Check if myPet is an instance of Dog\n        System.out.println(\"Is it a Dog? \" + (myPet instanceof Dog));\n\n        // Check if myPet is an instance of Cat\n        System.out.println(\"Is it a Cat? \" + (myPet instanceof Cat));\n\n        // Check if myPet is an instance of Animal (its superclass)\n        System.out.println(\"Is it an Animal? \" + (myPet instanceof Animal));\n    }\n}",
      "expectedOutput": "Is it a Dog? true\nIs it a Cat? false\nIs it an Animal? true",
      "tutorial": "<p class=\"mb-4 text-gray-300\">The <code>instanceof</code> operator is a type comparison operator that returns <code>true</code> if the object on the left side is an instance of the class on the right side. It also returns <code>true</code> if the object is an instance of a subclass of the class on the right.</p><p class=\"mb-4 text-gray-300\">This is particularly useful in polymorphism when you have a variable of a superclass type that could be holding an object of any of its subclasses, and you need to perform a specific action based on its actual type.</p><p class=\"mb-4 text-gray-300\">Practice the concept using a short example below.</p> <h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"Hello, Java!\");</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding the `instanceof` operator is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying the `instanceof` operator, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply the `instanceof` operator will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with the `instanceof` operator, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Control Flow",
        "OOP"
      ]
    },
    {
      "id": 62,
      "title": "62. Course Review",
      "description": "Combine everything you have learned. Create a `Student` class, manage a list of students with an `ArrayList`, and calculate their average score.",
      "initialCode": "import java.util.ArrayList;\n\nclass Student {\n    String name; int score;\n    Student(String name, int score) {\n        this.name = name;\n        this.score = score;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        ArrayList<Student> students = new ArrayList<>();\n        students.add(new Student(\"Alice\", 90));\n        students.add(new Student(\"Bob\", 80));\n        students.add(new Student(\"Charlie\", 100));\n\n        double totalScore = 0;\n        // Loop through the students list and sum their scores\n\n\n        // Calculate and print the average score\n\n    }\n}",
      "fullSolution": "import java.util.ArrayList;\n\nclass Student {\n    String name; int score;\n    Student(String name, int score) {\n        this.name = name;\n        this.score = score;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        ArrayList<Student> students = new ArrayList<>();\n        students.add(new Student(\"Alice\", 90));\n        students.add(new Student(\"Bob\", 80));\n        students.add(new Student(\"Charlie\", 100));\n\n        double totalScore = 0;\n        // Loop through the students list and sum their scores\n        for (Student s : students) {\n            totalScore += s.score;\n        }\n\n        // Calculate and print the average score\n        double average = totalScore / students.size();\n        System.out.println(\"Average student score: \" + average);\n    }\n}",
      "expectedOutput": "Average student score: 90.0",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Congratulations on reaching the final review lesson! This challenge combines many of the core concepts you've learned:</p><ul class=\"list-disc list-inside mb-4 text-gray-300 space-y-2\"><li><strong>Classes and Objects</strong>: The <code>Student</code> class with a constructor and private fields.</li><li><strong>Encapsulation</strong>: Using a getter method (<code>getScore</code>) to access private data.</li><li><strong>ArrayList</strong>: To hold a dynamic list of <code>Student</code> objects.</li><li><strong>Loops</strong>: A for-each loop to iterate through the list.</li><li><strong>Variables and Calculations</strong>: Summing the scores and calculating the average.</li></ul><p class=\"mb-4 text-gray-300\">Solving this demonstrates a solid grasp of Java fundamentals. Well done!</p><p class=\"mb-4 text-gray-300\">Practice the concept using a short example below.</p> <h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"Hello, Java!\");</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding course review is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying course review, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply course review will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with course review, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Control Flow",
        "Functions",
        "Collections",
        "OOP"
      ]
    },
    {
      "title": "63. Spring-Style Controller Method",
      "language": "java",
      "description": "Create a dummy @GetMapping annotation and use it on a controller method that returns \"Hello, World!\".",
      "initialCode": "@interface GetMapping {\n    String value();\n}\n\nclass HelloController {\n    // Annotate hello() with @GetMapping(\"/hello\") and return \"Hello, World!\"\n    public String hello() {\n        return null;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(new HelloController().hello());\n    }\n}\n",
      "fullSolution": "@interface GetMapping {\n    String value();\n}\n\nclass HelloController {\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"Hello, World!\";\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(new HelloController().hello());\n    }\n}\n",
      "expectedOutput": "Hello, World!",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Spring MVC uses annotations such as <code>@GetMapping</code> to map HTTP routes to controller methods. Defining a no-op annotation lets you practice the syntax without pulling in Spring dependencies.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">@interface PostMapping { String value(); }\nclass Api {\n    @PostMapping(\"/submit\")\n    public String submit() { return \"OK\"; }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding spring-style controller method is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying spring-style controller method, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply spring-style controller method will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with spring-style controller method, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 63,
      "tags": [
        "Beginner",
        "Functions",
        "Collections",
        "OOP",
        "Networking"
      ]
    },
    {
      "title": "64. SpringApplication Runner Stub",
      "language": "java",
      "description": "Create a SpringApplication-like helper that prints which class is booting.",
      "initialCode": "class SpringApplication {\n    // Implement static run that prints \"Booting <ClassName>\"\n}\n\nclass DemoApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(DemoApplication.class, args);\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        Child child = new Child();\n        child.display();\n    }\n}\n\nclass Parent {\n    void display() {\n        System.out.println(\"Parent display\");\n    }\n}\n\nclass Child extends Parent {\n    @Override\n    void display() {\n        super.display();\n        System.out.println(\"Child display\");\n    }\n}",
      "expectedOutput": "Parent display\\nChild display",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Spring Boot apps start via SpringApplication.run. A stubbed version lets you practice the pattern without pulling in dependencies.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">class SpringApplication {\n    static void run(Class<?> clazz, String[] args) {\n        System.out.printf(\"Booting %s%n\", clazz.getSimpleName());\n    }\n}</pre></div>\n<p class=\"mt-4 text-gray-300\">This stub replicates the logging handshake while staying dependency-free.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding springapplication runner stub is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying springapplication runner stub, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply springapplication runner stub will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with springapplication runner stub, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 64,
      "tags": [
        "Beginner",
        "Control Flow",
        "OOP",
        "Web",
        "Debugging"
      ]
    },
    {
      "title": "65. Spring Boot Mini Project Plan",
      "language": "java",
      "description": "List the files needed for a minimal Spring Boot REST API and print each filename with its responsibility.",
      "initialCode": "import java.util.List;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Map.Entry<String, String>> files = List.of(\n            Map.entry(\"src/main/java/com/example/Application.java\", \"bootstraps Spring app\"),\n            Map.entry(\"src/main/java/com/example/web/ProductController.java\", \"REST endpoints\"),\n            Map.entry(\"src/main/resources/application.properties\", \"configuration\"),\n            Map.entry(\"build.gradle\", \"dependencies & plugins\")\n        );\n\n        // Print lines in format \"<path> -> <description>\"\n    }\n}\n",
      "fullSolution": "import java.util.List;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Map.Entry<String, String>> files = List.of(\n            Map.entry(\"src/main/java/com/example/Application.java\", \"bootstraps Spring app\"),\n            Map.entry(\"src/main/java/com/example/web/ProductController.java\", \"REST endpoints\"),\n            Map.entry(\"src/main/resources/application.properties\", \"configuration\"),\n            Map.entry(\"build.gradle\", \"dependencies & plugins\")\n        );\n\n        for (Map.Entry<String, String> file : files) {\n            System.out.println(file.getKey() + \" -> \" + file.getValue());\n        }\n    }\n}\n",
      "expectedOutput": "src/main/java/com/example/Application.java -> bootstraps Spring app\nsrc/main/java/com/example/web/ProductController.java -> REST endpoints\nsrc/main/resources/application.properties -> configuration\nbuild.gradle -> dependencies & plugins",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Sketching the project tree clarifies the entry point, web layer, config, and build file you will need before writing code.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">for (var entry : files) {\n    System.out.println(entry.getKey() + \" -> \" + entry.getValue());\n}</pre></div>\n<p class=\"mt-4 text-gray-300\">Mapping each path to a responsibility lets reviewers confirm you covered every layer.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding spring boot mini project plan is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying spring boot mini project plan, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply spring boot mini project plan will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with spring boot mini project plan, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Beginner",
        "Project",
        "Control Flow",
        "Strings",
        "Collections"
      ],
      "id": 65
    },
    {
      "title": "66. Spring Boot Skeleton Files",
      "language": "java",
      "description": "Print starter contents for Application and ProductController so learners can immediately run a minimal API.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String application = String.join(\"\n\",\n            \"package com.example;\",\n            \"\",\n            \"import org.springframework.boot.SpringApplication;\",\n            \"import org.springframework.boot.autoconfigure.SpringBootApplication;\",\n            \"\",\n            \"@SpringBootApplication\",\n            \"public class Application {\",\n            \"    public static void main(String[] args) {\",\n            \"        SpringApplication.run(Application.class, args);\",\n            \"    }\",\n            \"}\"\n        );\n        String controller = String.join(\"\n\",\n            \"package com.example.web;\",\n            \"\",\n            \"import org.springframework.web.bind.annotation.GetMapping;\",\n            \"import org.springframework.web.bind.annotation.RestController;\",\n            \"\",\n            \"@RestController\",\n            \"public class ProductController {\",\n            \"    @GetMapping(\"/products\")\",\n            \"    public String list() {\",\n            \"        return \"[]\";\",\n            \"    }\",\n            \"}\"\n        );\n\n        // Print file -> snippet mapping\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        Shape[] shapes = {new Circle(), new Rectangle()};\n        for (Shape shape : shapes) {\n            shape.draw();\n        }\n    }\n}\n\nabstract class Shape {\n    abstract void draw();\n}\n\nclass Circle extends Shape {\n    @Override\n    void draw() {\n        System.out.println(\"Drawing circle\");\n    }\n}\n\nclass Rectangle extends Shape {\n    @Override\n    void draw() {\n        System.out.println(\"Drawing rectangle\");\n    }\n}",
      "expectedOutput": "Drawing circle\\nDrawing rectangle",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Provide the starter Application class and REST controller so the plan becomes runnable.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"src/main/java/com/example/Application.java ->\");\nSystem.out.println(application);\nSystem.out.println(\"src/main/java/com/example/web/ProductController.java ->\");\nSystem.out.println(controller);</pre></div>\n<p class=\"mt-4 text-gray-300\">Print the file headers followed by the snippets so teammates can paste them verbatim.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding spring boot skeleton files is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying spring boot skeleton files, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply spring boot skeleton files will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with spring boot skeleton files, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Beginner",
        "Project",
        "Control Flow",
        "Strings",
        "Collections"
      ],
      "id": 66
    },
    {
      "title": "67. Spring Boot Run Checklist",
      "language": "java",
      "description": "Print Gradle commands to build and run the Spring Boot app plus the curl call to verify the endpoint.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String project = \"inventory-service\";\n\n        // Print ./gradlew bootRun and curl http://localhost:8080/products\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String project = \"inventory-service\";\n\n        System.out.println(\"./gradlew bootRun\");\n        System.out.println(\"curl http://localhost:8080/products\");\n    }\n}\n",
      "expectedOutput": "./gradlew bootRun\ncurl http://localhost:8080/products",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Capture the exact commands to boot the service and smoke-test the REST endpoint.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"./gradlew bootRun\");\nSystem.out.println(\"curl http://localhost:8080/products\");</pre></div>\n<p class=\"mt-4 text-gray-300\">Include the curl so ops can validate the new build from the same checklist.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding spring boot run checklist is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying spring boot run checklist, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply spring boot run checklist will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with spring boot run checklist, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Beginner",
        "Tooling",
        "OOP",
        "Algorithms",
        "Networking"
      ],
      "id": 67
    },
    {
      "title": "68. Capstone: Deployment Checklist",
      "language": "java",
      "description": "Outline the release steps for the Spring Boot service: merge, cherry-pick, run tests, build the jar.",
      "initialCode": "String[] tasks = {\n    \"git checkout main\",\n    \"git merge feature/order-summary\",\n    \"git cherry-pick fix-null-order\",\n    \"./gradlew test\",\n    \"./gradlew bootJar\"\n};\n\n// Print each step prefixed with its number\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String[] tasks = {\n            \"git checkout main\",\n            \"git merge feature/order-summary\",\n            \"git cherry-pick fix-null-order\",\n            \"./gradlew test\",\n            \"./gradlew bootJar\"\n        };\n        for (int i = 0; i < tasks.length; i++) {\n            System.out.println((i + 1) + \". \" + tasks[i]);\n        }\n    }\n}\n",
      "expectedOutput": "1. git checkout main\n2. git merge feature/order-summary\n3. git cherry-pick fix-null-order\n4. ./gradlew test\n5. ./gradlew bootJar",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Capstones capture the release runbook so teammates can execute it without missing critical Git or build steps.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">for (int i = 0; i < tasks.length; i++) {\n    System.out.printf(\"%d. %s%n\", i + 1, tasks[i]);\n}</pre></div>\n<p class=\"mt-4 text-gray-300\">Leading with the step number keeps asynchronous reviewers on the same page.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding capstone: deployment checklist is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying capstone: deployment checklist, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply capstone: deployment checklist will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with capstone: deployment checklist, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Beginner",
        "Git",
        "Workflow",
        "Project",
        "Control Flow"
      ],
      "id": 68
    },
    {
      "title": "69. Deploy Spring Boot JAR",
      "language": "java",
      "description": "Print the commands to run the shaded jar with environment variables for port and profile.",
      "initialCode": "String jar = \"build/libs/inventory-service-1.0.0.jar\";\n\n// Print export SPRING_PROFILES_ACTIVE, export SERVER_PORT, and java -jar command\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String jar = \"build/libs/inventory-service-1.0.0.jar\";\n        System.out.println(\"export SPRING_PROFILES_ACTIVE=prod\");\n        System.out.println(\"export SERVER_PORT=8080\");\n        System.out.println(\"java -jar \" + jar);\n    }\n}\n",
      "expectedOutput": "export SPRING_PROFILES_ACTIVE=prod\nexport SERVER_PORT=8080\njava -jar build/libs/inventory-service-1.0.0.jar",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Running the jar directly is the simplest deployment option. Set the profile and port so ops tooling can override them.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"export SPRING_PROFILES_ACTIVE=prod\");\nSystem.out.println(\"export SERVER_PORT=8080\");\nSystem.out.println(\"java -jar \" + jar);</pre></div>\n<p class=\"mt-4 text-gray-300\">Group the exports above the java command so the runtime picks them up.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding deploy spring boot jar is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying deploy spring boot jar, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply deploy spring boot jar will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with deploy spring boot jar, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Beginner",
        "Deployment",
        "Control Flow",
        "Collections",
        "OOP"
      ],
      "id": 69
    },
    {
      "title": "70. Capstone: Smoke Tests",
      "language": "java",
      "description": "Run Gradle smoke tests and curl health check after deploying the jar.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String[] cmds = {\n            \"./gradlew test --tests SmokeTests\",\n            \"curl -f http://localhost:8080/health\"\n        };\n        // Print each command on its own line\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String[] cmds = {\n            \"./gradlew test --tests SmokeTests\",\n            \"curl -f http://localhost:8080/health\"\n        };\n        for (String cmd : cmds) {\n            System.out.println(cmd);\n        }\n    }\n}\n",
      "expectedOutput": "./gradlew test --tests SmokeTests\ncurl -f http://localhost:8080/health",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Post-deploy smoke tests guard against regressions. Automate them (Gradle + curl) and fail the release if either step breaks.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">for (String cmd : cmds) {\n    System.out.println(cmd);\n}</pre></div>\n<p class=\"mt-4 text-gray-300\">Keep the list tight so on-call engineers can run the same checks manually.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding capstone: smoke tests is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying capstone: smoke tests, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply capstone: smoke tests will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with capstone: smoke tests, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Beginner",
        "Testing",
        "Project",
        "Control Flow",
        "Collections"
      ],
      "id": 70
    },
    {
      "title": "71. Collections Warm-Up with Generics",
      "language": "java",
      "description": "Create a typed list and set, add names (including a duplicate), then print their sizes.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create an ArrayList<String> and add \"Ada\", \"Grace\", \"Ada\"\n        // Create a HashSet<String> from the list\n        // Print the list size then the set size\n    }\n}\n",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> names = new ArrayList<>();\n        names.add(\"Ada\");\n        names.add(\"Grace\");\n        names.add(\"Ada\");\n\n        Set<String> unique = new HashSet<>(names);\n\n        System.out.println(names.size());\n        System.out.println(unique.size());\n    }\n}\n",
      "expectedOutput": "3\n2",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Generics keep collections type-safe: <code>List&lt;String&gt;</code> guarantees every element is a <code>String</code>. Converting to a <code>Set</code> is a quick way to deduplicate.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">List<Integer> numbers = new ArrayList<>();\nnumbers.add(1);\nnumbers.add(1);\nSet<Integer> unique = new HashSet<>(numbers);\nSystem.out.println(unique.size()); // 1</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding collections warm-up with generics is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying collections warm-up with generics, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply collections warm-up with generics will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with collections warm-up with generics, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 71,
      "tags": [
        "Beginner",
        "Collections",
        "OOP",
        "Security",
        "Type System"
      ]
    },
    {
      "id": 72,
      "title": "72. Streams: map",
      "description": "Use a stream with a lambda to double each number and print each on a new line.",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> nums = Arrays.asList(1,2,3);\n        // Double each then print each value on its own line\n\n    }\n}",
      "fullSolution": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> nums = Arrays.asList(1,2,3);\n        nums.stream().map(n -> n * 2).forEach(System.out::println);\n    }\n}",
      "expectedOutput": "2\n4\n6",
      "tutorial": "<p class=\"mb-4 text-gray-300\">The `map` operation transforms each element of a stream. It applies a function to each element and returns a new stream of the results.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.List;\nList<String> names = List.of(\"alice\", \"bob\");\nnames.stream()\n     .map(String::toUpperCase)\n     .forEach(System.out::println); // ALICE, BOB printed on new lines</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding streams: map is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying streams: map, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply streams: map will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with streams: map, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Functions",
        "Collections",
        "OOP",
        "Functional"
      ]
    },
    {
      "id": 73,
      "title": "73. Streams: filter",
      "description": "Filter even numbers from 0..6 and print them.",
      "initialCode": "import java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Filter evens from 0..6 and print them on new lines\n\n    }\n}",
      "fullSolution": "import java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        IntStream.rangeClosed(0,6).filter(n -> n % 2 == 0).forEach(System.out::println);\n    }\n}",
      "expectedOutput": "0\n2\n4\n6",
      "tutorial": "<p class=\"mb-4 text-gray-300\">The `filter` operation selects elements from a stream that match a given condition (a `Predicate`).</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.List;\nList<Integer> nums = List.of(1, 2, 3, 4);\nnums.stream()\n    .filter(n -> n % 2 == 0)\n    .forEach(System.out::println); // 2, 4 printed on new lines</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding streams: filter is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying streams: filter, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply streams: filter will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with streams: filter, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Control Flow",
        "Collections",
        "OOP",
        "Functional"
      ]
    },
    {
      "id": 74,
      "title": "74. Sort by Length",
      "description": "Sort strings by length ascending and print them.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> words = Arrays.asList(\"pear\", \"fig\", \"apple\");\n        // Sort by length and print each on a new line\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> words = Arrays.asList(\"pear\", \"fig\", \"apple\");\n        words.stream().sorted(Comparator.comparingInt(String::length)).forEach(System.out::println);\n    }\n}",
      "expectedOutput": "fig\npear\napple",
      "tutorial": "<p class=\"mb-4 text-gray-300\">You can sort collections using a `Comparator`. `Comparator.comparingInt` is a helper for sorting by an integer property, like string length.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.List;\nimport java.util.Comparator;\nList<String> words = List.of(\"fig\", \"apple\", \"pear\");\nwords.stream()\n     .sorted(Comparator.comparingInt(String::length))\n     .forEach(System.out::println); // fig, pear, apple on new lines</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding sort by length is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying sort by length, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply sort by length will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with sort by length, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Control Flow",
        "Collections",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 75,
      "title": "75. Comparator on Objects",
      "description": "Sort objects by a field using Comparator.comparing.",
      "initialCode": "import java.util.*;\n\nclass Person {\n    String name; int age;\n    Person(String n, int a){ name=n; age=a; }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Person> people = Arrays.asList(new Person(\"Bob\",30), new Person(\"Alice\",25), new Person(\"Eve\",35));\n        // Sort by age ascending and print names\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\nclass Person {\n    String name; int age;\n    Person(String n, int a){ name=n; age=a; }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Person> people = Arrays.asList(new Person(\"Bob\",30), new Person(\"Alice\",25), new Person(\"Eve\",35));\n        people.stream().sorted(Comparator.comparingInt(p -> p.age)).forEach(p -> System.out.println(p.name));\n    }\n}",
      "expectedOutput": "Alice\nBob\nEve",
      "tutorial": "<p class=\"mb-4 text-gray-300\">`Comparator.comparing` extracts a sort key from an object. You provide a lambda that takes an object and returns the property to sort by.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\nclass Person { String name; Person(String n) { name=n; } }\nList<Person> people = List.of(new Person(\"Bob\"), new Person(\"Alice\"));\npeople.stream().sorted(Comparator.comparing(p -> p.name))\n      .forEach(p -> System.out.println(p.name)); // Alice, Bob</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding comparator on objects is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying comparator on objects, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply comparator on objects will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with comparator on objects, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Functions",
        "Collections",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 76,
      "title": "76. Optional.map",
      "description": "Uppercase a value inside Optional and print it if present.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Optional<String> opt = Optional.of(\"java\");\n        // Map to uppercase and print if present\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Optional<String> opt = Optional.of(\"java\");\n        opt.map(String::toUpperCase).ifPresent(System.out::println);\n    }\n}",
      "expectedOutput": "JAVA",
      "tutorial": "<p class=\"mb-4 text-gray-300\">`Optional.map` applies a function to the value inside an Optional, if it is present, and returns a new Optional with the result.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.Optional;\nOptional<String> opt = Optional.of(\"text\");\nopt.map(String::toUpperCase).ifPresent(System.out::println); // TEXT</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding optional.map is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying optional.map, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply optional.map will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with optional.map, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Control Flow",
        "Functions",
        "Strings",
        "Collections"
      ]
    },
    {
      "id": 77,
      "title": "77. Generic Box<T>",
      "description": "Create a generic Box class and print its value.",
      "initialCode": "public class Main {\n    static class Box<T> {\n        T value;\n        Box(T v){ value=v; }\n        T get(){ return value; }\n    }\n    public static void main(String[] args) {\n        // Create Box<Integer> with 7 and print its value\n\n    }\n}",
      "fullSolution": "public class Main {\n    static class Box<T> {\n        T value;\n        Box(T v){ value=v; }\n        T get(){ return value; }\n    }\n    public static void main(String[] args) {\n        Box<Integer> b = new Box<>(7);\n        System.out.println(b.get());\n    }\n}",
      "expectedOutput": "7",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Generics allow you to define classes and methods that are parameterized over types. A `Box<T>` can hold any type `T`.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">class Box<T> { private T t; public void set(T t) { this.t=t; } public T get() { return t; } }\nBox<Integer> intBox = new Box<>();\nintBox.set(10);\nSystem.out.println(intBox.get()); // 10</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding generic box<t> is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying generic box<t>, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply generic box<t> will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with generic box<t>, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Collections",
        "OOP",
        "Type System"
      ]
    },
    {
      "id": 78,
      "title": "78. Bounded Wildcards",
      "description": "Sum a list of Numbers using an upper-bounded wildcard.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    static double sumList(List<? extends Number> list){\n        double s = 0;\n        // Sum numbers here\n        return s;\n    }\n    public static void main(String[] args) {\n        System.out.println(sumList(Arrays.asList(1,2,3)));\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    static double sumList(List<? extends Number> list){\n        double s = 0;\n        for (Number n : list) s += n.doubleValue();\n        return s;\n    }\n    public static void main(String[] args) {\n        System.out.println(sumList(Arrays.asList(1,2,3)));\n    }\n}",
      "expectedOutput": "6.0",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Upper-bounded wildcards (`? extends Type`) are used to increase flexibility. A `List<? extends Number>` can hold a list of Integers or a list of Doubles.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.List;\npublic static double sum(List<? extends Number> list) {\n    return list.stream().mapToDouble(Number::doubleValue).sum();\n}\nSystem.out.println(sum(List.of(1, 2.5))); // 3.5</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding bounded wildcards is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying bounded wildcards, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply bounded wildcards will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with bounded wildcards, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Control Flow",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 79,
      "title": "79. Method References",
      "description": "Use method references to map and print.",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> s = Arrays.asList(\"a\", \"b\", \"c\");\n        // Map to uppercase and print using method references\n\n    }\n}",
      "fullSolution": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> s = Arrays.asList(\"a\", \"b\", \"c\");\n        s.stream().map(String::toUpperCase).forEach(System.out::println);\n    }\n}",
      "expectedOutput": "A\nB\nC",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Method references are a shorthand syntax for a lambda expression that executes just ONE method. They make code more readable.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.List;\nList<String> list = List.of(\"a\", \"b\");\nlist.stream().map(String::toUpperCase).forEach(System.out::println); // A, B</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding method references is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying method references, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply method references will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with method references, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Control Flow",
        "Functions",
        "Strings",
        "Collections"
      ]
    },
    {
      "id": 80,
      "title": "80. Reverse Sort",
      "description": "Sort numbers in descending order and print them.",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> nums = Arrays.asList(3,1,2);\n        // Sort descending and print\n\n    }\n}",
      "fullSolution": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> nums = Arrays.asList(3,1,2);\n        nums.stream().sorted(Comparator.reverseOrder()).forEach(System.out::println);\n    }\n}",
      "expectedOutput": "3\n2\n1",
      "tutorial": "<p class=\"mb-4 text-gray-300\">`Comparator.reverseOrder()` returns a comparator that imposes the reverse of the natural ordering.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\nList<Integer> nums = List.of(1, 3, 2);\nnums.stream().sorted(Comparator.reverseOrder()).forEach(System.out::println); // 3, 2, 1</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding reverse sort is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying reverse sort, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply reverse sort will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with reverse sort, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Beginner",
        "Collections",
        "OOP",
        "Algorithms",
        "Streams"
      ]
    },
    {
      "id": 81,
      "title": "81. Enum + switch",
      "description": "Switch on an enum and print a label.",
      "initialCode": "enum Day { MON, SAT }\n\npublic class Main {\n    public static void main(String[] args) {\n        Day d = Day.MON;\n        // Switch and print Workday for MON, Weekend for SAT\n\n    }\n}",
      "fullSolution": "enum Day { MON, SAT }\n\npublic class Main {\n    public static void main(String[] args) {\n        Day d = Day.MON;\n        switch (d) {\n            case MON -> System.out.println(\"Workday\");\n            case SAT -> System.out.println(\"Weekend\");\n        }\n    }\n}",
      "expectedOutput": "Workday",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Enums work very well with `switch` statements, providing compile-time checking that all cases are handled.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">enum Level { EASY, HARD }\nLevel level = Level.EASY;\nswitch (level) {\n    case EASY -> System.out.println(\"Easy mode\");\n    case HARD -> System.out.println(\"Hard mode\");\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding enum + switch is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying enum + switch, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply enum + switch will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with enum + switch, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Control Flow",
        "OOP"
      ]
    },
    {
      "id": 82,
      "title": "82. Record Basics",
      "description": "Use a record to model a point and print x+y.",
      "initialCode": "record Point(int x, int y) {}\n\npublic class Main {\n    public static void main(String[] args) {\n        // Print the sum of Point(2,3) coordinates\n\n    }\n}",
      "fullSolution": "record Point(int x, int y) {}\n\npublic class Main {\n    public static void main(String[] args) {\n        Point p = new Point(2,3);\n        System.out.println(p.x() + p.y());\n    }\n}",
      "expectedOutput": "5",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Records (Java 16+) provide a compact syntax for declaring classes which are transparent holders for immutable data.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">record Point(int x, int y) {}\nPoint p = new Point(1, 2);\nSystem.out.println(p.x()); // 1</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding record basics is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying record basics, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply record basics will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with record basics, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Control Flow",
        "OOP",
        "Type System"
      ]
    },
    {
      "id": 83,
      "title": "83. Streams: reduce",
      "description": "Use reduce to sum numbers.",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> nums = Arrays.asList(1,2,3);\n        // Use reduce to compute the sum and print it\n\n    }\n}",
      "fullSolution": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> nums = Arrays.asList(1,2,3);\n        int sum = nums.stream().reduce(0, Integer::sum);\n        System.out.println(sum);\n    }\n}",
      "expectedOutput": "6",
      "tutorial": "<p class=\"mb-4 text-gray-300\">The `reduce` operation combines all elements of a stream into a single result.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.List;\nint sum = List.of(1, 2, 3).stream().reduce(0, (a, b) -> a + b);\nSystem.out.println(sum); // 6</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding streams: reduce is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying streams: reduce, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply streams: reduce will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with streams: reduce, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Collections",
        "OOP",
        "Functional",
        "Streams"
      ]
    },
    {
      "id": 84,
      "title": "84. Collectors.joining",
      "description": "Join strings with commas using Collectors.joining.",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> w = Arrays.asList(\"a\",\"b\",\"c\");\n        // Join with commas and print\n\n    }\n}",
      "fullSolution": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> w = Arrays.asList(\"a\",\"b\",\"c\");\n        String s = w.stream().collect(Collectors.joining(\",\"));\n        System.out.println(s);\n    }\n}",
      "expectedOutput": "a,b,c",
      "tutorial": "<p class=\"mb-4 text-gray-300\">`Collectors.joining` is a collector that concatenates the input elements into a String, in encounter order.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.stream.*;\nString s = Stream.of(\"a\", \"b\", \"c\").collect(Collectors.joining(\",\"));\nSystem.out.println(s); // \"a,b,c\"</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding collectors.joining is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying collectors.joining, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply collectors.joining will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with collectors.joining, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Strings",
        "Collections",
        "OOP",
        "Functional"
      ]
    },
    {
      "id": 85,
      "title": "85. LinkedHashMap Order",
      "description": "Preserve insertion order and print key:value pairs.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        LinkedHashMap<String,Integer> m = new LinkedHashMap<>();\n        m.put(\"a\",1); m.put(\"b\",2); m.put(\"c\",3);\n        // Print a:1 then b:2 then c:3 (each on its own line)\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        LinkedHashMap<String,Integer> m = new LinkedHashMap<>();\n        m.put(\"a\",1); m.put(\"b\",2); m.put(\"c\",3);\n        m.forEach((k,v) -> System.out.println(k + \":\" + v));\n    }\n}",
      "expectedOutput": "a:1\nb:2\nc:3",
      "tutorial": "<p class=\"mb-4 text-gray-300\">A HashMap stores key-value pairs. Use `put` to add items and `get` to retrieve them by key.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.HashMap;\nHashMap<String, String> capitals = new HashMap<>();\ncapitals.put(\"England\", \"London\");\nSystem.out.println(capitals.get(\"England\")); // London</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding linkedhashmap order is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying linkedhashmap order, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply linkedhashmap order will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with linkedhashmap order, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Collections",
        "OOP",
        "Security"
      ]
    },
    {
      "id": 86,
      "title": "86. LinkedHashSet Basics",
      "description": "Avoid duplicates and keep insertion order.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        LinkedHashSet<Integer> set = new LinkedHashSet<>();\n        set.add(1); set.add(2); set.add(1); set.add(3);\n        // Print each value on a new line\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        LinkedHashSet<Integer> set = new LinkedHashSet<>();\n        set.add(1); set.add(2); set.add(1); set.add(3);\n        for (Integer i : set) System.out.println(i);\n    }\n}",
      "expectedOutput": "1\n2\n3",
      "tutorial": "<p class=\"mb-4 text-gray-300\">A `LinkedHashSet` is an ordered version of HashSet that maintains a doubly-linked List across all elements. The elements are ordered based on their insertion order.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.LinkedHashSet;\nLinkedHashSet<Integer> set = new LinkedHashSet<>();\nset.add(3); set.add(1); set.add(3);\nSystem.out.println(set); // [3, 1]</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding linkedhashset basics is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying linkedhashset basics, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply linkedhashset basics will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with linkedhashset basics, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Collections",
        "OOP",
        "Security"
      ]
    },
    {
      "id": 87,
      "title": "87. TreeSet Sort",
      "description": "Store numbers in a sorted set and print ascending.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        TreeSet<Integer> ts = new TreeSet<>(Arrays.asList(3,1,2));\n        // Print sorted elements\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        TreeSet<Integer> ts = new TreeSet<>(Arrays.asList(3,1,2));\n        for (Integer i : ts) System.out.println(i);\n    }\n}",
      "expectedOutput": "1\n2\n3",
      "tutorial": "<p class=\"mb-4 text-gray-300\">A `TreeSet` is a NavigableSet implementation based on a TreeMap. The elements are ordered using their natural ordering, or by a Comparator provided at set creation time.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.TreeSet;\nTreeSet<Integer> set = new TreeSet<>();\nset.add(3); set.add(1);\nSystem.out.println(set); // [1, 3]</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding treeset sort is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying treeset sort, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply treeset sort will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with treeset sort, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Collections",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 88,
      "title": "88. Comparable",
      "description": "Implement Comparable to sort custom objects.",
      "initialCode": "import java.util.*;\n\nclass User implements Comparable<User> {\n    String name;\n    User(String n){ name=n; }\n    // Implement compareTo by name\n    public int compareTo(User o){ return 0; }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        List<User> users = Arrays.asList(new User(\"Bob\"), new User(\"Alice\"), new User(\"Carol\"));\n        Collections.sort(users);\n        for (User u : users) System.out.println(u.name);\n    }\n}",
      "fullSolution": "import java.util.*;\n\nclass User implements Comparable<User> {\n    String name;\n    User(String n){ name=n; }\n    public int compareTo(User o){ return this.name.compareTo(o.name); }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        List<User> users = Arrays.asList(new User(\"Bob\"), new User(\"Alice\"), new User(\"Carol\"));\n        Collections.sort(users);\n        for (User u : users) System.out.println(u.name);\n    }\n}",
      "expectedOutput": "Alice\nBob\nCarol",
      "tutorial": "<p class=\"mb-4 text-gray-300\">The `Comparable` interface imposes a total ordering on the objects of each class that implements it. This ordering is referred to as the class's natural ordering.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">class User implements Comparable<User> {\n    String name; User(String n){name=n;}\n    public int compareTo(User o) { return name.compareTo(o.name); }\n}\nUser u1=new User(\"Bob\"), u2=new User(\"Alice\");\nSystem.out.println(u1.compareTo(u2) > 0); // true</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding comparable is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying comparable, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply comparable will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with comparable, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Collections",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 89,
      "title": "89. Default Methods",
      "description": "Use a default method in an interface.",
      "initialCode": "interface Greeter {\n    // Provide a default method greet() printing Hello\n}\n\nclass MyGreeter implements Greeter {}\n\npublic class Main {\n    public static void main(String[] args) {\n        new MyGreeter().greet();\n    }\n}",
      "fullSolution": "interface Greeter {\n    default void greet(){ System.out.println(\"Hello\"); }\n}\n\nclass MyGreeter implements Greeter {}\n\npublic class Main {\n    public static void main(String[] args) {\n        new MyGreeter().greet();\n    }\n}",
      "expectedOutput": "Hello",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Define reusable logic in methods. Static methods belong to the class and can be called without an instance.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">static int add(int a, int b) { return a + b; }\nSystem.out.println(add(3, 4)); // 7</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding default methods is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying default methods, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply default methods will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with default methods, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Functions",
        "OOP"
      ]
    },
    {
      "id": 90,
      "title": "90. Abstract Class",
      "description": "Extend an abstract class and implement its method.",
      "initialCode": "abstract class Animal {\n    abstract void speak();\n}\nclass Dog extends Animal {\n    // Implement speak to print Bark!\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        new Dog().speak();\n    }\n}",
      "fullSolution": "abstract class Animal {\n    abstract void speak();\n}\nclass Dog extends Animal {\n    void speak(){ System.out.println(\"Bark!\"); }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        new Dog().speak();\n    }\n}",
      "expectedOutput": "Bark!",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Abstract classes are similar to interfaces but can have fields that are not static and final, and they can contain non-abstract methods.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">abstract class Shape { abstract double area(); }\nclass Circle extends Shape { double r=2; double area() {return 3.14*r*r;} }\nSystem.out.println(new Circle().area()); // 12.56</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding abstract class is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying abstract class, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply abstract class will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with abstract class, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "OOP"
      ]
    },
    {
      "id": 91,
      "title": "91. LocalDate",
      "description": "Parse a date and add one day.",
      "initialCode": "import java.time.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        LocalDate d = LocalDate.parse(\"2023-01-02\");\n        // Print d.plusDays(1)\n\n    }\n}",
      "fullSolution": "import java.time.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        LocalDate d = LocalDate.parse(\"2023-01-02\");\n        System.out.println(d.plusDays(1));\n    }\n}",
      "expectedOutput": "2023-01-03",
      "tutorial": "<p class=\"mb-4 text-gray-300\">`LocalDate` is an immutable date-time object that represents a date, often viewed as year-month-day.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.time.LocalDate;\nLocalDate date = LocalDate.of(2023, 1, 31);\nSystem.out.println(date.plusDays(1)); // 2023-02-01</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding localdate is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying localdate, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply localdate will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with localdate, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "OOP",
        "Web",
        "Date/Time",
        "Parsing"
      ]
    },
    {
      "id": 92,
      "title": "92. Regex Find",
      "description": "Use Pattern/Matcher to find digits in a string.",
      "initialCode": "import java.util.regex.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Matcher m = Pattern.compile(\"\\\\d\").matcher(\"a1b2\");\n        // Print each digit match on its own line\n\n    }\n}",
      "fullSolution": "import java.util.regex.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Matcher m = Pattern.compile(\"\\\\d\").matcher(\"a1b2\");\n        while (m.find()) System.out.println(m.group());\n    }\n}",
      "expectedOutput": "1\n2",
      "tutorial": "<p class=\"mb-4 text-gray-300\">The `Matcher` class finds matches for a regular expression pattern in a string. The `find()` method scans the input sequence to find the next subsequence that matches the pattern.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.regex.*;\nMatcher m = Pattern.compile(\"\\\\d+\").matcher(\"a12b34c\");\nwhile (m.find()) { System.out.println(m.group()); } // 12, 34</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding regex find is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying regex find, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply regex find will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with regex find, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Tooling",
        "Control Flow",
        "Functions",
        "Strings"
      ]
    },
    {
      "id": 93,
      "title": "93. ArrayDeque",
      "description": "Use a deque to add/remove from both ends.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        ArrayDeque<String> dq = new ArrayDeque<>();\n        dq.addLast(\"A\"); dq.addLast(\"B\"); dq.addFirst(\"0\");\n        // Remove from front until empty, printing each\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        ArrayDeque<String> dq = new ArrayDeque<>();\n        dq.addLast(\"A\"); dq.addLast(\"B\"); dq.addFirst(\"0\");\n        while (!dq.isEmpty()) System.out.println(dq.removeFirst());\n    }\n}",
      "expectedOutput": "0\nA\nB",
      "tutorial": "<p class=\"mb-4 text-gray-300\">`ArrayDeque` is a resizable-array implementation of the `Deque` interface. It has no capacity restrictions and is faster than LinkedList for stack and queue operations.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.ArrayDeque;\nArrayDeque<Integer> dq = new ArrayDeque<>();\ndq.addFirst(1); dq.addLast(2);\nSystem.out.println(dq.pollFirst()); // 1</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding arraydeque is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying arraydeque, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply arraydeque will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with arraydeque, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 94,
      "title": "94. String.format",
      "description": "Format a string with placeholders.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        // Print: Name: Alice, Age: 30\n\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        System.out.println(String.format(\"Name: %s, Age: %d\", \"Alice\", 30));\n    }\n}",
      "expectedOutput": "Name: Alice, Age: 30",
      "tutorial": "<p class=\"mb-4 text-gray-300\">`String.format()` returns a formatted string using the specified format string and arguments.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">String s = String.format(\"Hello, %s! You have %d messages.\", \"Alice\", 5);\nSystem.out.println(s);</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding string.format is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying string.format, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply string.format will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with string.format, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Strings",
        "OOP"
      ]
    },
    {
      "title": "95. Maven Coordinate Formatter",
      "language": "java",
      "description": "Format Maven coordinates as groupId:artifactId:version and print the result.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String group = \"org.springframework\";\n        String artifact = \"spring-core\";\n        String version = \"6.1.0\";\n\n        // Use String.join or concatenation to print groupId:artifactId:version\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String group = \"org.springframework\";\n        String artifact = \"spring-core\";\n        String version = \"6.1.0\";\n\n        System.out.println(String.join(\":\", group, artifact, version));\n    }\n}\n",
      "expectedOutput": "org.springframework:spring-core:6.1.0",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Maven artifacts are referenced by <code>groupId:artifactId:version</code>. Formatting these strings shows how dependencies are declared in pom.xml.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">String coordinate = String.join(\":\", \"org.projectlombok\", \"lombok\", \"1.18.30\");\nSystem.out.println(coordinate);</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding maven coordinate formatter is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying maven coordinate formatter, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply maven coordinate formatter will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with maven coordinate formatter, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 95,
      "tags": [
        "Intermediate",
        "Strings",
        "OOP",
        "Serialization",
        "Web"
      ]
    },
    {
      "title": "96. Gradle Dependency Line",
      "language": "java",
      "description": "Print an implementation(\"group:artifact:version\") line for Gradle build scripts.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String group = \"com.fasterxml.jackson.core\";\n        String artifact = \"jackson-databind\";\n        String version = \"2.16.1\";\n\n        // Print implementation(\"group:artifact:version\")\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String group = \"com.fasterxml.jackson.core\";\n        String artifact = \"jackson-databind\";\n        String version = \"2.16.1\";\n\n        String dependency = String.format(\"implementation(\\\"%s:%s:%s\\\")\", group, artifact, version);\n        System.out.println(dependency);\n    }\n}\n",
      "expectedOutput": "implementation(\"com.fasterxml.jackson.core:jackson-databind:2.16.1\")",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Gradle's Kotlin/Groovy DSL wraps dependencies in method calls such as <code>implementation(\"group:artifact:version\")</code>. Build scripts often use <code>String.format</code> or template literals to generate these entries.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">String dep = String.format(\"testImplementation(\"%s:%s:%s\")\", \"org.junit.jupiter\", \"junit-jupiter\", \"5.10.1\");\nSystem.out.println(dep);</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding gradle dependency line is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying gradle dependency line, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply gradle dependency line will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with gradle dependency line, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 96,
      "tags": [
        "Intermediate",
        "Control Flow",
        "Functions",
        "Strings",
        "OOP"
      ]
    },
    {
      "title": "97. Git Branch Summary",
      "language": "java",
      "description": "Format a branch list so the current branch is marked with '*'.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String[] branches = {\"main\", \"feature/login\", \"chore/deps\"};\n        String current = \"feature/login\";\n\n        // Print branches with '*' prefix on the current branch\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String[] branches = {\"main\", \"feature/login\", \"chore/deps\"};\n        String current = \"feature/login\";\n\n        for (String name : branches) {\n            String marker = name.equals(current) ? \"*\" : \" \";\n            System.out.println(marker + \" \" + name);\n        }\n    }\n}\n",
      "expectedOutput": "  main\n* feature/login\n  chore/deps",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Match Git's branch listing by marking the active branch with an asterisk.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">for (String branch : branches) {\n    String prefix = branch.equals(current) ? \"* \" : \"  \";\n    System.out.println(prefix + branch);\n}</pre></div>\n<p class=\"mt-4 text-gray-300\">Formatting it like <code>git branch</code> keeps the practice output familiar.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding git branch summary is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying git branch summary, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply git branch summary will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with git branch summary, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 97,
      "tags": [
        "Intermediate",
        "Git",
        "Workflow",
        "Control Flow",
        "Strings"
      ]
    },
    {
      "title": "98. Git Merge Plan",
      "language": "java",
      "description": "Print the Git commands to merge a feature branch into main and show the commits that will be added.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String source = \"feature/login\";\n        String target = \"main\";\n        String[] commits = {\"login-form\", \"oauth\"};\n\n        // Print checkout, merge, then the incoming commits separated by commas\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String source = \"feature/login\";\n        String target = \"main\";\n        String[] commits = {\"login-form\", \"oauth\"};\n\n        System.out.println(\"git checkout \" + target);\n        System.out.println(\"git merge \" + source);\n        System.out.println(\"Incoming commits: \" + String.join(\", \", commits));\n    }\n}\n",
      "expectedOutput": "git checkout main\ngit merge feature/login\nIncoming commits: login-form, oauth",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Summarize merge work by listing the commands you will run and the commits that will land. Tools like <code>git log main..feature</code> provide the same input.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"git checkout \" + target);\nSystem.out.println(\"git merge \" + source);\nSystem.out.println(\"Incoming commits: \" + String.join(\", \", commits));</pre></div>\n<p class=\"mt-4 text-gray-300\">Spell out the post-merge history so reviewers can flag surprises before you run the command.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding git merge plan is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying git merge plan, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply git merge plan will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with git merge plan, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Git",
        "Workflow",
        "Strings",
        "OOP"
      ],
      "id": 98
    },
    {
      "title": "99. Git Rebase Steps",
      "language": "java",
      "description": "Describe the commands to rebase a feature branch onto main and show the commits being replayed.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String feature = \"feature/search\";\n        String base = \"main\";\n        String[] commits = {\"index-view\", \"search-ui\"};\n\n        // Print checkout, fetch, rebase, then the commits being replayed\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String feature = \"feature/search\";\n        String base = \"main\";\n        String[] commits = {\"index-view\", \"search-ui\"};\n\n        System.out.println(\"git checkout \" + feature);\n        System.out.println(\"git fetch origin \" + base);\n        System.out.println(\"git rebase origin/\" + base);\n        System.out.println(\"Replaying: \" + String.join(\", \", commits));\n    }\n}\n",
      "expectedOutput": "git checkout feature/search\ngit fetch origin main\ngit rebase origin/main\nReplaying: index-view, search-ui",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Rebasing keeps history linear. Listing the replayed commits double-checks what will be rewritten.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"git checkout \" + feature);\nSystem.out.println(\"git fetch origin \" + base);\nSystem.out.println(\"git rebase origin/\" + base);\nSystem.out.println(\"Replaying: \" + String.join(\", \", commits));</pre></div>\n<p class=\"mt-4 text-gray-300\">Call out the origin branch explicitly so nobody rebases against stale local history.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding git rebase steps is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying git rebase steps, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply git rebase steps will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with git rebase steps, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Git",
        "Workflow",
        "Strings",
        "OOP"
      ],
      "id": 99
    },
    {
      "title": "100. Git Conflict Resolution Practice",
      "language": "java",
      "description": "Walk through resolving merge conflicts by listing commands and the manual edit step.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String source = \"feature/landing\";\n        String target = \"main\";\n        String[] files = {\"templates/home.html\", \"static/site.css\"};\n\n        // Print checkout, merge, placeholders to resolve each file, add, and commit\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String source = \"feature/landing\";\n        String target = \"main\";\n        String[] files = {\"templates/home.html\", \"static/site.css\"};\n\n        System.out.println(\"git checkout \" + target);\n        System.out.println(\"git merge \" + source);\n        for (String path : files) {\n            System.out.println(\"# resolve conflicts in \" + path);\n        }\n        System.out.println(\"git add \" + String.join(\" \", files));\n        System.out.println(\"git commit --no-edit\");\n    }\n}\n",
      "expectedOutput": "git checkout main\ngit merge feature/landing\n# resolve conflicts in templates/home.html\n# resolve conflicts in static/site.css\ngit add templates/home.html static/site.css\ngit commit --no-edit",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Conflict resolution is a routine workflow: merge, fix, stage, commit.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"git checkout \" + target);\nSystem.out.println(\"git merge \" + source);\nfor (String path : files) {\n    System.out.println(\"# resolve conflicts in \" + path);\n}\nSystem.out.println(\"git add \" + String.join(\" \", files));\nSystem.out.println(\"git commit --no-edit\");</pre></div>\n<p class=\"mt-4 text-gray-300\">Listing every conflicted file reassures reviewers you touched each one before committing.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding git conflict resolution practice is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying git conflict resolution practice, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply git conflict resolution practice will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with git conflict resolution practice, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Git",
        "Workflow",
        "Control Flow",
        "Strings"
      ],
      "id": 100
    },
    {
      "title": "101. Git Cherry-pick Steps",
      "language": "java",
      "description": "Describe how to cherry-pick a set of commits onto a release branch and verify the history.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String target = \"release/1.2\";\n        String[] commits = {\"feat-a1\", \"fix-a2\"};\n\n        // Print checkout target, cherry-pick each commit, then git log --oneline -5\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String target = \"release/1.2\";\n        String[] commits = {\"feat-a1\", \"fix-a2\"};\n\n        System.out.println(\"git checkout \" + target);\n        for (String commit : commits) {\n            System.out.println(\"git cherry-pick \" + commit);\n        }\n        System.out.println(\"git log --oneline -5\");\n    }\n}\n",
      "expectedOutput": "git checkout release/1.2\ngit cherry-pick feat-a1\ngit cherry-pick fix-a2\ngit log --oneline -5",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Cherry-picking targeted fixes onto release branches is common during hotfix windows.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"git checkout \" + target);\nfor (String commit : commits) {\n    System.out.println(\"git cherry-pick \" + commit);\n}\nSystem.out.println(\"git log --oneline -5\");</pre></div>\n<p class=\"mt-4 text-gray-300\">Close with a short log query so the team verifies the commits before tagging.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding git cherry-pick steps is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying git cherry-pick steps, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply git cherry-pick steps will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with git cherry-pick steps, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Git",
        "Workflow",
        "Control Flow",
        "Collections"
      ],
      "id": 101
    },
    {
      "id": 102,
      "title": "102. Arrays.stream",
      "description": "Stream over a primitive array and sum it.",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr = {1,2,3};\n        // Print the sum\n\n    }\n}",
      "fullSolution": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr = {1,2,3};\n        System.out.println(Arrays.stream(arr).sum());\n    }\n}",
      "expectedOutput": "6",
      "tutorial": "<p class=\"mb-4 text-gray-300\">`Arrays.stream()` returns a sequential Stream with the specified array as its source.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.Arrays;\nint[] arr = {1, 2, 3};\nSystem.out.println(Arrays.stream(arr).sum()); // 6</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding arrays.stream is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying arrays.stream, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply arrays.stream will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with arrays.stream, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Collections",
        "OOP",
        "Streams"
      ]
    },
    {
      "id": 103,
      "title": "103. distinct()",
      "description": "Remove duplicates with distinct and print unique values.",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> list = Arrays.asList(1,1,2,2,3);\n        // Print unique values in encounter order\n\n    }\n}",
      "fullSolution": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> list = Arrays.asList(1,1,2,2,3);\n        list.stream().distinct().forEach(System.out::println);\n    }\n}",
      "expectedOutput": "1\n2\n3",
      "tutorial": "<p class=\"mb-4 text-gray-300\">The `distinct()` stream operation returns a stream consisting of the distinct elements (according to `Object.equals(Object)`) of this stream.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.stream.Stream;\nStream.of(1, 2, 1, 3).distinct().forEach(System.out::println); // 1, 2, 3</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding distinct() is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying distinct(), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply distinct() will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with distinct(), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Collections",
        "OOP",
        "Streams"
      ]
    },
    {
      "id": 104,
      "title": "104. groupingBy + TreeMap",
      "description": "Group words by length into a sorted map and print counts.",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> words = Arrays.asList(\"one\", \"two\", \"three\");\n        // Group by length into a TreeMap and print k=v per line\n\n    }\n}",
      "fullSolution": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> words = Arrays.asList(\"one\", \"two\", \"three\");\n        Map<Integer, Long> m = words.stream().collect(Collectors.groupingBy(String::length, TreeMap::new, Collectors.counting()));\n        m.forEach((k,v) -> System.out.println(k + \"=\" + v));\n    }\n}",
      "expectedOutput": "3=2\n5=1",
      "tutorial": "<p class=\"mb-4 text-gray-300\">`Collectors.groupingBy` is used for grouping objects by some property and storing results in a Map instance.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.stream.*;\nimport java.util.List;\nSystem.out.println(Stream.of(\"a\", \"bb\", \"ccc\", \"dd\").collect(Collectors.groupingBy(String::length))); // {1=[a], 2=[bb, dd], 3=[ccc]}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding groupingby + treemap is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying groupingby + treemap, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply groupingby + treemap will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with groupingby + treemap, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Collections",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 105,
      "title": "105. flatMap",
      "description": "Flatten a list of lists and print each element.",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<List<Integer>> nested = Arrays.asList(Arrays.asList(1,2), Arrays.asList(3,4));\n        // Flatten and print each number\n\n    }\n}",
      "fullSolution": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<List<Integer>> nested = Arrays.asList(Arrays.asList(1,2), Arrays.asList(3,4));\n        nested.stream().flatMap(List::stream).forEach(System.out::println);\n    }\n}",
      "expectedOutput": "1\n2\n3\n4",
      "tutorial": "<p class=\"mb-4 text-gray-300\">`flatMap` transforms each element of a stream into another stream and then concatenates these streams into a single, \"flattened\" stream.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.stream.*;\nimport java.util.List;\nList<List<Integer>> listOfLists = List.of(List.of(1), List.of(2, 3));\nlistOfLists.stream().flatMap(List::stream).forEach(System.out::println); // 1, 2, 3</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding flatmap is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying flatmap, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply flatmap will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with flatmap, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Collections",
        "OOP",
        "Functional",
        "Streams"
      ]
    },
    {
      "id": 106,
      "title": "106. compute() Counts",
      "description": "Use Map.compute to count character frequency preserving first-seen order.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        String s = \"banana\";\n        Map<Character,Integer> m = new LinkedHashMap<>();\n        // Count chars and print b=1, a=3, n=2 (one per line)\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        String s = \"banana\";\n        Map<Character,Integer> m = new LinkedHashMap<>();\n        for (char c : s.toCharArray()) {\n            m.compute(c, (k,v) -> v==null ? 1 : v+1);\n        }\n        m.forEach((k,v) -> System.out.println(k + \"=\" + v));\n    }\n}",
      "expectedOutput": "b=1\na=3\nn=2",
      "tutorial": "<p class=\"mb-4 text-gray-300\">`Map.compute()` attempts to compute a mapping for the specified key and its current mapped value.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.HashMap;\nHashMap<String, Integer> map = new HashMap<>();\nmap.compute(\"key\", (k, v) -> (v == null) ? 1 : v + 1);\nSystem.out.println(map.get(\"key\")); // 1</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding compute() counts is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying compute() counts, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply compute() counts will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with compute() counts, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Strings",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 107,
      "title": "107. partitioningBy",
      "description": "Partition numbers into even/odd and print counts.",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> nums = Arrays.asList(1,2,3,4,5);\n        // Partition into even/odd and print even=2 then odd=3\n\n    }\n}",
      "fullSolution": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> nums = Arrays.asList(1,2,3,4,5);\n        Map<Boolean, Long> m = nums.stream().collect(Collectors.partitioningBy(n -> n % 2 == 0, Collectors.counting()));\n        System.out.println(\"even=\" + m.get(true));\n        System.out.println(\"odd=\" + m.get(false));\n    }\n}",
      "expectedOutput": "even=2\nodd=3",
      "tutorial": "<p class=\"mb-4 text-gray-300\">`Collectors.partitioningBy` is a collector which partitions the input elements into a `Map<Boolean, List<T>>` according to a `Predicate`.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.stream.*;\nSystem.out.println(Stream.of(1,2,3,4).collect(Collectors.partitioningBy(n -> n%2==0))); // {false=[1, 3], true=[2, 4]}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding partitioningby is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying partitioningby, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply partitioningby will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with partitioningby, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Collections",
        "OOP",
        "Functional",
        "Streams"
      ]
    },
    {
      "title": "108. Thread vs Runnable",
      "language": "java",
      "description": "Create a Runnable that prints a message, start a Thread with it, then join the thread.",
      "initialCode": "public class Main {\n    public static void main(String[] args) throws InterruptedException {\n        // Create a Runnable that prints \"Working...\"\n        // Start a Thread with the runnable\n        // Wait for it to finish using join()\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) throws InterruptedException {\n        Runnable task = () -> System.out.println(\"Working...\");\n        Thread worker = new Thread(task);\n        worker.start();\n        worker.join();\n    }\n}\n",
      "expectedOutput": "Working...",
      "tutorial": "<p class=\"mb-4 text-gray-300\">In Java, <code>Runnable</code> captures the work to do, while <code>Thread</code> controls execution. Wrap your runnable in a thread (or executor) and start it.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Runnable job = () -> System.out.println(\"Hi\");\nThread t = new Thread(job);\nt.start();\nt.join();</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding thread vs runnable is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying thread vs runnable, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply thread vs runnable will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with thread vs runnable, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 108,
      "tags": [
        "Intermediate",
        "Control Flow",
        "Strings",
        "OOP",
        "Concurrency"
      ]
    },
    {
      "id": 109,
      "title": "109. ExecutorService",
      "description": "Submit a Callable and print the result.",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Submit a task returning 2+3 and print the result\n\n    }\n}",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        ExecutorService ex = Executors.newSingleThreadExecutor();\n        Future<Integer> f = ex.submit(() -> 2 + 3);\n        System.out.println(f.get());\n        ex.shutdown();\n    }\n}",
      "expectedOutput": "5",
      "tutorial": "<p class=\"mb-4 text-gray-300\">`ExecutorService` is a framework for asynchronous task execution. It manages a pool of threads and a task queue.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.concurrent.*;\nExecutorService es = Executors.newSingleThreadExecutor();\nFuture<Integer> future = es.submit(() -> 1 + 1);\ntry { System.out.println(future.get()); } catch (Exception e) {}\nes.shutdown();</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding executorservice is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying executorservice, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply executorservice will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with executorservice, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Functions",
        "OOP",
        "Concurrency"
      ]
    },
    {
      "id": 110,
      "title": "110. CompletableFuture",
      "description": "Compose async tasks and print the final result.",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // supplyAsync -> thenApply to add ! and print\n\n    }\n}",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        CompletableFuture<String> cf = CompletableFuture.supplyAsync(() -> \"Hi\").thenApply(s -> s + \"!\");\n        System.out.println(cf.join());\n    }\n}",
      "expectedOutput": "Hi!",
      "tutorial": "<p class=\"mb-4 text-gray-300\">`CompletableFuture` is used for asynchronous programming. It represents a future result of an asynchronous computation.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.concurrent.CompletableFuture;\nCompletableFuture.supplyAsync(() -> \"Result\").thenAccept(System.out::println); // Result</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding completablefuture is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying completablefuture, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply completablefuture will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with completablefuture, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Strings",
        "OOP",
        "Concurrency"
      ]
    },
    {
      "id": 111,
      "title": "111. AtomicInteger",
      "description": "Safely increment a counter from two threads and print the total.",
      "initialCode": "import java.util.concurrent.atomic.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        AtomicInteger ai = new AtomicInteger(0);\n        // Start two threads incrementing 100 times each, then print ai.get()\n\n    }\n}",
      "fullSolution": "import java.util.concurrent.atomic.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        AtomicInteger ai = new AtomicInteger(0);\n        Thread t1 = new Thread(() -> { for (int i=0;i<100;i++) ai.incrementAndGet(); });\n        Thread t2 = new Thread(() -> { for (int i=0;i<100;i++) ai.incrementAndGet(); });\n        t1.start(); t2.start(); t1.join(); t2.join();\n        System.out.println(ai.get());\n    }\n}",
      "expectedOutput": "200",
      "tutorial": "<p class=\"mb-4 text-gray-300\">An `AtomicInteger` is an `int` value that may be updated atomically, making it useful in concurrent programming without locks.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.concurrent.atomic.AtomicInteger;\nAtomicInteger ai = new AtomicInteger(5);\nSystem.out.println(ai.incrementAndGet()); // 6</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding atomicinteger is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying atomicinteger, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply atomicinteger will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with atomicinteger, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Strings",
        "OOP",
        "Concurrency"
      ]
    },
    {
      "id": 112,
      "title": "112. Optional.orElse",
      "description": "Provide a default value when Optional is empty.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Optional<String> o = Optional.empty();\n        // Print default if empty\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Optional<String> o = Optional.empty();\n        System.out.println(o.orElse(\"default\"));\n    }\n}",
      "expectedOutput": "default",
      "tutorial": "<p class=\"mb-4 text-gray-300\">`Optional.orElse()` returns the value if present, otherwise returns the other value.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.Optional;\nString name = (String) Optional.ofNullable(null).orElse(\"default\");\nSystem.out.println(name); // default</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding optional.orelse is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying optional.orelse, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply optional.orelse will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with optional.orelse, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Control Flow",
        "OOP"
      ]
    },
    {
      "id": 113,
      "title": "113. StringJoiner",
      "description": "Join strings with a custom delimiter.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Join a, b, c with '-' and print\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        StringJoiner sj = new StringJoiner(\"-\");\n        sj.add(\"a\"); sj.add(\"b\"); sj.add(\"c\");\n        System.out.println(sj.toString());\n    }\n}",
      "expectedOutput": "a-b-c",
      "tutorial": "<p class=\"mb-4 text-gray-300\">String methods like toLowerCase(), toUpperCase(), and length() return transformed information; Strings are immutable.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">String s = \"Java\";\nSystem.out.println(s.toLowerCase());\nSystem.out.println(s.toUpperCase());\nSystem.out.println(s.length());</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding stringjoiner is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying stringjoiner, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply stringjoiner will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with stringjoiner, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Strings",
        "OOP"
      ]
    },
    {
      "id": 114,
      "title": "114. BigDecimal",
      "description": "Add precise decimal numbers and print the result.",
      "initialCode": "import java.math.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Print 0.1 + 0.2 using BigDecimal\n\n    }\n}",
      "fullSolution": "import java.math.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        BigDecimal a = new BigDecimal(\"0.1\");\n        BigDecimal b = new BigDecimal(\"0.2\");\n        System.out.println(a.add(b));\n    }\n}",
      "expectedOutput": "0.3",
      "tutorial": "<p class=\"mb-4 text-gray-300\">`BigDecimal` provides arbitrary-precision signed decimal numbers. Use it for financial calculations where precision is critical.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.math.BigDecimal;\nBigDecimal a = new BigDecimal(\"0.1\");\nBigDecimal b = new BigDecimal(\"0.2\");\nSystem.out.println(a.add(b)); // 0.3</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding bigdecimal is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying bigdecimal, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply bigdecimal will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with bigdecimal, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Control Flow",
        "OOP",
        "Math and Stats"
      ]
    },
    {
      "id": 115,
      "title": "115. replaceAll",
      "description": "Remove digits from a string using regex.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String s = \"a1b2\";\n        // Remove digits and print\n\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String s = \"a1b2\";\n        System.out.println(s.replaceAll(\"\\\\d\", \"\"));\n    }\n}",
      "expectedOutput": "ab",
      "tutorial": "<p class=\"mb-4 text-gray-300\">`String.replaceAll()` replaces each substring of this string that matches the given regular expression with the given replacement.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">String s = \"a1b2c3\";\nSystem.out.println(s.replaceAll(\"\\\\d\", \"#\")); // a#b#c#</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding replaceall is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying replaceall, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply replaceall will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with replaceall, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Strings",
        "OOP",
        "Regex"
      ]
    },
    {
      "id": 116,
      "title": "116. Case-Insensitive Sort",
      "description": "Sort strings ignoring case and print them.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        String[] arr = {\"Bob\", \"alice\", \"Carol\"};\n        // Sort ignoring case and print each on a new line\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        String[] arr = {\"Bob\", \"alice\", \"Carol\"};\n        Arrays.sort(arr, String.CASE_INSENSITIVE_ORDER);\n        for (String w : arr) System.out.println(w);\n    }\n}",
      "expectedOutput": "alice\nBob\nCarol",
      "tutorial": "<p class=\"mb-4 text-gray-300\">`String.CASE_INSENSITIVE_ORDER` is a `Comparator` that orders `String` objects as by `compareToIgnoreCase`.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.Arrays;\nString[] arr = {\"Bob\", \"alice\"};\nArrays.sort(arr, String.CASE_INSENSITIVE_ORDER);\nSystem.out.println(Arrays.toString(arr)); // [alice, Bob]</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding case-insensitive sort is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying case-insensitive sort, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply case-insensitive sort will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with case-insensitive sort, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Control Flow",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 117,
      "title": "117. String.repeat",
      "description": "Repeat a string and print it.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        // Print hahaha using repeat\n\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        System.out.println(\"ha\".repeat(3));\n    }\n}",
      "expectedOutput": "hahaha",
      "tutorial": "<p class=\"mb-4 text-gray-300\">`String.repeat(n)` returns a string whose value is the concatenation of this string repeated `n` times.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"-\".repeat(5)); // -----</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding string.repeat is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying string.repeat, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply string.repeat will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with string.repeat, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "OOP"
      ]
    },
    {
      "id": 118,
      "title": "118. Varargs",
      "description": "Implement a varargs sum method and print the sum.",
      "initialCode": "public class Main {\n    static int sum(int... nums){\n        // Sum all nums\n        return 0;\n    }\n    public static void main(String[] args) {\n        System.out.println(sum(1,2,3));\n    }\n}",
      "fullSolution": "public class Main {\n    static int sum(int... nums){\n        int s=0; for (int n: nums) s += n; return s;\n    }\n    public static void main(String[] args) {\n        System.out.println(sum(1,2,3));\n    }\n}",
      "expectedOutput": "6",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Varargs allows a method to accept zero or more arguments. The varargs parameter is treated as an array of the specified type.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">static int sum(int... nums) {\n    return java.util.Arrays.stream(nums).sum();\n}\nSystem.out.println(sum(1, 2, 3)); // 6</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding varargs is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying varargs, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply varargs will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with varargs, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Functions",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 119,
      "title": "119. Interface Static Method",
      "description": "Call a static method defined on an interface.",
      "initialCode": "interface Util {\n    // add(a,b) returning a+b as a static method\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        // Print Util.add(2,3)\n\n    }\n}",
      "fullSolution": "interface Util {\n    static int add(int a, int b){ return a + b; }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(Util.add(2,3));\n    }\n}",
      "expectedOutput": "5",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Define reusable logic in methods. Static methods belong to the class and can be called without an instance.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">static int add(int a, int b) { return a + b; }\nSystem.out.println(add(3, 4)); // 7</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding interface static method is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying interface static method, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply interface static method will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with interface static method, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Functions",
        "OOP"
      ]
    },
    {
      "id": 120,
      "title": "120. Try-with-Resources",
      "description": "Use try-with-resources to auto-close a reader.",
      "initialCode": "import java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Use StringReader to read 'hello' then print it\n\n    }\n}",
      "fullSolution": "import java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        try (StringReader r = new StringReader(\"hello\")) {\n            char[] buf = new char[5];\n            r.read(buf);\n            System.out.println(new String(buf));\n        }\n    }\n}",
      "expectedOutput": "hello",
      "tutorial": "<p class=\"mb-4 text-gray-300\">The try-with-resources statement ensures that each resource is closed at the end of the statement. Any object that implements `AutoCloseable` can be used as a resource.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.io.*;\ntry (StringReader r = new StringReader(\"text\")) {\n    System.out.println((char)r.read()); // t\n} catch (IOException e) {}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding try-with-resources is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying try-with-resources, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply try-with-resources will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with try-with-resources, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Strings",
        "OOP",
        "I/O"
      ]
    },
    {
      "id": 121,
      "title": "121. PriorityQueue",
      "description": "Use a min-heap to get the smallest element.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        pq.add(3); pq.add(1); pq.add(2);\n        // Poll and print the smallest\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        pq.add(3); pq.add(1); pq.add(2);\n        System.out.println(pq.poll());\n    }\n}",
      "expectedOutput": "1",
      "tutorial": "<p class=\"mb-4 text-gray-300\">A `PriorityQueue` is a heap-based queue where elements are ordered according to their natural ordering, or by a `Comparator`.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.PriorityQueue;\nPriorityQueue<Integer> pq = new PriorityQueue<>();\npq.add(3); pq.add(1);\nSystem.out.println(pq.poll()); // 1</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding priorityqueue is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying priorityqueue, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply priorityqueue will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with priorityqueue, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Collections",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 122,
      "title": "122. LinkedList",
      "description": "Use LinkedList to add at the front and print first element.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        LinkedList<String> list = new LinkedList<>();\n        list.add(\"B\");\n        // Add \"A\" to the front then print first element\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        LinkedList<String> list = new LinkedList<>();\n        list.add(\"B\");\n        list.addFirst(\"A\");\n        System.out.println(list.getFirst());\n    }\n}",
      "expectedOutput": "A",
      "tutorial": "<p class=\"mb-4 text-gray-300\">ArrayList is a resizable list. Use add() to append and get() to access by index.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">java.util.List<Integer> list = new java.util.ArrayList<>();\nlist.add(1); list.add(2); list.add(3);\nSystem.out.println(list);</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding linkedlist is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying linkedlist, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply linkedlist will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with linkedlist, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 123,
      "title": "123. Deque push/pop",
      "description": "Use a Deque as a stack and print the popped value.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Deque<Integer> st = new ArrayDeque<>();\n        st.push(1); st.push(2);\n        // Pop and print\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Deque<Integer> st = new ArrayDeque<>();\n        st.push(1); st.push(2);\n        System.out.println(st.pop());\n    }\n}",
      "expectedOutput": "2",
      "tutorial": "<p class=\"mb-4 text-gray-300\">The `Deque` interface provides stack operations like `push` and `pop`. `ArrayDeque` is the recommended implementation.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.ArrayDeque;\nArrayDeque<Integer> stack = new ArrayDeque<>();\nstack.push(1); stack.push(2);\nSystem.out.println(stack.pop()); // 2</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding deque push/pop is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying deque push/pop, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply deque push/pop will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with deque push/pop, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 124,
      "title": "124. TreeMap",
      "description": "Insert keys into TreeMap and print the first key.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        TreeMap<String,Integer> tm = new TreeMap<>();\n        tm.put(\"b\",2); tm.put(\"a\",1);\n        // Print the firstKey\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        TreeMap<String,Integer> tm = new TreeMap<>();\n        tm.put(\"b\",2); tm.put(\"a\",1);\n        System.out.println(tm.firstKey());\n    }\n}",
      "expectedOutput": "a",
      "tutorial": "<p class=\"mb-4 text-gray-300\">A `TreeMap` is a NavigableMap implementation that keeps its entries sorted according to the natural ordering of its keys, or by a `Comparator`.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.TreeMap;\nTreeMap<Integer, String> map = new TreeMap<>();\nmap.put(3, \"c\"); map.put(1, \"a\");\nSystem.out.println(map.firstKey()); // 1</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding treemap is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying treemap, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply treemap will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with treemap, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Collections",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 125,
      "title": "125. StringBuilder.reverse",
      "description": "Reverse a string using StringBuilder and print it.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        // Reverse 'abc' and print\n\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        System.out.println(new StringBuilder(\"abc\").reverse().toString());\n    }\n}",
      "expectedOutput": "cba",
      "tutorial": "<p class=\"mb-4 text-gray-300\">String methods like toLowerCase(), toUpperCase(), and length() return transformed information; Strings are immutable.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">String s = \"Java\";\nSystem.out.println(s.toLowerCase());\nSystem.out.println(s.toUpperCase());\nSystem.out.println(s.length());</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding stringbuilder.reverse is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying stringbuilder.reverse, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply stringbuilder.reverse will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with stringbuilder.reverse, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Strings",
        "OOP"
      ]
    },
    {
      "id": 126,
      "title": "126. Regex Groups",
      "description": "Capture a group from a string and print it.",
      "initialCode": "import java.util.regex.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Pattern p = Pattern.compile(\"^Hello\\\\s+(\\\\w+)$\");\n        Matcher m = p.matcher(\"Hello World\");\n        // Print the captured word\n\n    }\n}",
      "fullSolution": "import java.util.regex.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Pattern p = Pattern.compile(\"^Hello\\\\s+(\\\\w+)$\");\n        Matcher m = p.matcher(\"Hello World\");\n        if (m.find()) System.out.println(m.group(1));\n    }\n}",
      "expectedOutput": "World",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Parentheses `()` in a regex create capturing groups. You can access the captured text using `matcher.group(index)`.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.regex.*;\nMatcher m = Pattern.compile(\"(\\\\d+)-(\\w+)\").matcher(\"123-xyz\");\nif (m.find()) { System.out.println(m.group(2)); } // xyz</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding regex groups is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying regex groups, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply regex groups will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with regex groups, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Strings",
        "OOP",
        "Regex"
      ]
    },
    {
      "id": 127,
      "title": "127. Arrays.binarySearch",
      "description": "Search a sorted array and print the index.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr = {1,2,3,4};\n        // Print index of 3\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr = {1,2,3,4};\n        System.out.println(Arrays.binarySearch(arr, 3));\n    }\n}",
      "expectedOutput": "2",
      "tutorial": "<p class=\"mb-4 text-gray-300\">`Arrays.binarySearch` searches the specified array for the specified value using the binary search algorithm. The array must be sorted.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.Arrays;\nint[] arr = {10, 20, 30};\nSystem.out.println(Arrays.binarySearch(arr, 20)); // 1</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding arrays.binarysearch is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying arrays.binarysearch, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply arrays.binarysearch will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with arrays.binarysearch, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Collections",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 128,
      "title": "128. Map.merge",
      "description": "Merge counts in a map and print the sum of counts for 'a' and 'b'.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String,Integer> counts = new HashMap<>();\n        for (char ch : \"aab\".toCharArray()) {\n            // Use merge to count characters\n        }\n        // Print counts.get(\"a\") + counts.get(\"b\")\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String,Integer> counts = new HashMap<>();\n        for (char ch : \"aab\".toCharArray()) {\n            counts.merge(String.valueOf(ch), 1, Integer::sum);\n        }\n        System.out.println(counts.get(\"a\") + counts.get(\"b\"));\n    }\n}",
      "expectedOutput": "3",
      "tutorial": "<p class=\"mb-4 text-gray-300\">`Map.merge` lets you update a map entry by applying a function to the old and new values.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.HashMap;\nHashMap<String, Integer> counts = new HashMap<>();\ncounts.merge(\"apple\", 1, Integer::sum);\ncounts.merge(\"apple\", 1, Integer::sum);\nSystem.out.println(counts.get(\"apple\")); // 2</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding map.merge is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying map.merge, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply map.merge will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with map.merge, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Functions",
        "Strings",
        "Collections"
      ]
    },
    {
      "id": 129,
      "title": "129. Capstone: Top Student",
      "description": "Use streams to find and print the highest-scoring student's name.",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\nclass Student { String name; int score; Student(String n,int s){ name=n; score=s; } }\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Student> students = Arrays.asList(new Student(\"Alice\",90), new Student(\"Bob\",80), new Student(\"Charlie\",100));\n        // Find max by score and print the name\n\n    }\n}",
      "fullSolution": "import java.util.*;\nimport java.util.stream.*;\n\nclass Student { String name; int score; Student(String n,int s){ name=n; score=s; } }\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Student> students = Arrays.asList(new Student(\"Alice\",90), new Student(\"Bob\",80), new Student(\"Charlie\",100));\n        String name = students.stream().max(Comparator.comparingInt(s -> s.score)).get().name;\n        System.out.println(name);\n    }\n}",
      "expectedOutput": "Charlie",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This capstone combines streams, comparators, and Optionals to find the object with the maximum value in a collection.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\nclass S { String n; int s; S(String n, int s){this.n=n;this.s=s;} }\nList<S> list = List.of(new S(\"A\",90), new S(\"B\",100));\nlist.stream().max(Comparator.comparingInt(s -> s.s))\n    .ifPresent(s -> System.out.println(s.n)); // B</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding capstone: top student is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying capstone: top student, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply capstone: top student will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with capstone: top student, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Collections",
        "OOP",
        "Streams"
      ]
    },
    {
      "id": 130,
      "title": "130. groupingBy counting",
      "description": "Count occurrences of letters using streams and print counts for 'a' then 'b'.",
      "initialCode": "import java.util.*;\nimport java.util.function.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> xs = Arrays.asList(\"a\", \"a\", \"b\", \"b\", \"b\");\n        // Build a Map<String, Long> of counts using groupingBy + counting\n        // Then print counts.get(\"a\") and counts.get(\"b\") on separate lines\n\n    }\n}",
      "fullSolution": "import java.util.*;\nimport java.util.function.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> xs = Arrays.asList(\"a\", \"a\", \"b\", \"b\", \"b\");\n        Map<String, Long> counts = xs.stream()\n            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n        System.out.println(counts.get(\"a\"));\n        System.out.println(counts.get(\"b\"));\n    }\n}",
      "fullSolutionCommented": "import java.util.*;\nimport java.util.function.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // groupingBy(Function.identity()) groups equal elements, counting() tallies per group.\n        List<String> xs = Arrays.asList(\"a\", \"a\", \"b\", \"b\", \"b\");\n        Map<String, Long> counts = xs.stream()\n            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n        System.out.println(counts.get(\"a\")); // 2\n        System.out.println(counts.get(\"b\")); // 3\n    }\n}",
      "expectedOutput": "2\n3",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use <code>groupingBy</code> with <code>counting</code> to aggregate items by key in one pass.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nList<String> items = Arrays.asList(\"a\", \"b\", \"a\");\nMap<String, Long> m = items.stream()\n  .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\nSystem.out.println(m.get(\"a\")); // 2</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding groupingby counting is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying groupingby counting, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply groupingby counting will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with groupingby counting, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Collections",
        "OOP",
        "Functional"
      ]
    },
    {
      "id": 131,
      "title": "131. Optional.orElse",
      "description": "Find the first even number or return -1.",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> xs = Arrays.asList(1, 3, 4, 7);\n        // Use streams + filter + findFirst + orElse to print the first even or -1\n\n    }\n}",
      "fullSolution": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> xs = Arrays.asList(1, 3, 4, 7);\n        int v = xs.stream().filter(n -> n % 2 == 0).findFirst().orElse(-1);\n        System.out.println(v);\n    }\n}",
      "fullSolutionCommented": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Filter to evens, take the first if present, otherwise return default -1.\n        List<Integer> xs = Arrays.asList(1, 3, 4, 7);\n        int v = xs.stream()\n                  .filter(n -> n % 2 == 0)\n                  .findFirst()\n                  .orElse(-1);\n        System.out.println(v); // 4\n    }\n}",
      "expectedOutput": "4",
      "tutorial": "<p class=\"mb-4 text-gray-300\">`Optional.orElse` provides a fallback when a value is absent.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.Optional;\nSystem.out.println(Optional.&lt;Integer&gt;empty().orElse(42)); // 42</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding optional.orelse is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying optional.orelse, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply optional.orelse will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with optional.orelse, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Collections",
        "OOP",
        "Functional",
        "Streams"
      ]
    },
    {
      "id": 132,
      "title": "132. Comparator.thenComparing",
      "description": "Sort by age then name and print the first person's name.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    static class Person { String name; int age; Person(String n,int a){ name=n; age=a; } }\n    public static void main(String[] args) {\n        List<Person> ps = Arrays.asList(new Person(\"Bob\",20), new Person(\"Ann\",20), new Person(\"Zoe\",30));\n        // Sort by age ascending, then by name ascending, and print ps.get(0).name\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    static class Person { String name; int age; Person(String n,int a){ name=n; age=a; } }\n    public static void main(String[] args) {\n        List<Person> ps = Arrays.asList(new Person(\"Bob\",20), new Person(\"Ann\",20), new Person(\"Zoe\",30));\n        ps.sort(Comparator.comparingInt((Person p) -> p.age).thenComparing(p -> p.name));\n        System.out.println(ps.get(0).name);\n    }\n}",
      "fullSolutionCommented": "import java.util.*;\n\npublic class Main {\n    static class Person { String name; int age; Person(String n,int a){ name=n; age=a; } }\n    public static void main(String[] args) {\n        // First sort key: age ascending; tie-break by name ascending.\n        List<Person> ps = Arrays.asList(new Person(\"Bob\",20), new Person(\"Ann\",20), new Person(\"Zoe\",30));\n        ps.sort(Comparator.comparingInt((Person p) -> p.age)\n                          .thenComparing(p -> p.name));\n        System.out.println(ps.get(0).name); // Ann\n    }\n}",
      "expectedOutput": "Ann",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Chain comparators with <code>thenComparing</code> to apply tie-breakers for sorting.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">list.sort(Comparator.comparingInt(Person::age)\n    .thenComparing(Person::name));</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding comparator.thencomparing is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying comparator.thencomparing, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply comparator.thencomparing will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with comparator.thencomparing, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Collections",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "title": "133. Concurrency Toolbox Overview",
      "language": "java",
      "description": "Implement pickTool(kind) to recommend a Java concurrency abstraction.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        System.out.println(pickTool(\"io-bound\"));\n        System.out.println(pickTool(\"many-short-tasks\"));\n        System.out.println(pickTool(\"cpu-bound\"));\n    }\n\n    static String pickTool(String kind) {\n        // Return \"ExecutorService\" for io-bound, \"CompletableFuture\" for many-short-tasks, \"ForkJoinPool\" for cpu-bound\n        return null;\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        System.out.println(pickTool(\"io-bound\"));\n        System.out.println(pickTool(\"many-short-tasks\"));\n        System.out.println(pickTool(\"cpu-bound\"));\n    }\n\n    static String pickTool(String kind) {\n        switch (kind) {\n            case \"io-bound\":\n                return \"ExecutorService\";\n            case \"many-short-tasks\":\n                return \"CompletableFuture\";\n            case \"cpu-bound\":\n                return \"ForkJoinPool\";\n            default:\n                throw new IllegalArgumentException(\"Unknown kind: \" + kind);\n        }\n    }\n}\n",
      "expectedOutput": "ExecutorService\nCompletableFuture\nForkJoinPool",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Threads, thread pools, and high-level futures each shine for different workloads. Pick executors for blocking I/O, <code>CompletableFuture</code> for pipelines of async tasks, and <code>ForkJoinPool</code> for CPU-heavy fork/join work.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">switch (kind) {\n    case \"io-bound\": return \"ExecutorService\";\n    case \"cpu-bound\": return \"ForkJoinPool\";\n    default: return \"CompletableFuture\";\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding concurrency toolbox overview is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying concurrency toolbox overview, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply concurrency toolbox overview will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with concurrency toolbox overview, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 133,
      "tags": [
        "Intermediate",
        "Control Flow",
        "Strings",
        "OOP",
        "Web"
      ]
    },
    {
      "id": 134,
      "title": "134. CompletableFuture.thenCombine",
      "description": "Combine two async computations and print their sum.",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Create two CompletableFutures of 10 and 20, thenCombine to sum, then print\n\n    }\n}",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        CompletableFuture<Integer> a = CompletableFuture.supplyAsync(() -> 10);\n        CompletableFuture<Integer> b = CompletableFuture.supplyAsync(() -> 20);\n        System.out.println(a.thenCombine(b, Integer::sum).get());\n    }\n}",
      "fullSolutionCommented": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Run two async suppliers, then combine their results with a sum.\n        CompletableFuture<Integer> a = CompletableFuture.supplyAsync(() -> 10);\n        CompletableFuture<Integer> b = CompletableFuture.supplyAsync(() -> 20);\n        CompletableFuture<Integer> sum = a.thenCombine(b, Integer::sum);\n        System.out.println(sum.get()); // 30\n    }\n}",
      "expectedOutput": "30",
      "tutorial": "<p class=\"mb-4 text-gray-300\">`CompletableFuture` supports composition. Use <code>thenCombine</code> to merge results of two futures.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">CompletableFuture&lt;Integer&gt; a = CompletableFuture.completedFuture(1);\nCompletableFuture&lt;Integer&gt; b = CompletableFuture.completedFuture(2);\nSystem.out.println(a.thenCombine(b, Integer::sum).join());</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding completablefuture.thencombine is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying completablefuture.thencombine, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply completablefuture.thencombine will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with completablefuture.thencombine, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Strings",
        "OOP",
        "Concurrency",
        "Async"
      ]
    },
    {
      "id": 135,
      "title": "135. ExecutorService invokeAll",
      "description": "Run callables on a thread pool and sum their results.",
      "initialCode": "import java.util.*;\nimport java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Use a fixed thread pool to compute 1,2,3 and print their sum\n\n    }\n}",
      "fullSolution": "import java.util.*;\nimport java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        ExecutorService es = Executors.newFixedThreadPool(2);\n        List<Callable<Integer>> tasks = Arrays.asList(() -> 1, () -> 2, () -> 3);\n        int sum = 0;\n        for (Future<Integer> f : es.invokeAll(tasks)) sum += f.get();\n        es.shutdown();\n        System.out.println(sum);\n    }\n}",
      "fullSolutionCommented": "import java.util.*;\nimport java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Submit a batch of callables and collect their results.\n        ExecutorService es = Executors.newFixedThreadPool(2);\n        try {\n            List<Callable<Integer>> tasks = Arrays.asList(() -> 1, () -> 2, () -> 3);\n            int sum = 0;\n            for (Future<Integer> f : es.invokeAll(tasks)) {\n                sum += f.get();\n            }\n            System.out.println(sum); // 6\n        } finally {\n            es.shutdown();\n        }\n    }\n}",
      "expectedOutput": "6",
      "tutorial": "<p class=\"mb-4 text-gray-300\">`invokeAll` submits a batch of tasks and returns Futures you can collect results from.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">ExecutorService es = Executors.newFixedThreadPool(4);\ntry { /* submit work */ } finally { es.shutdown(); }</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding executorservice invokeall is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying executorservice invokeall, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply executorservice invokeall will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with executorservice invokeall, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Collections",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 136,
      "title": "136. ArrayDeque as Stack",
      "description": "Push 1,2,3 then pop and print each on a new line.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        ArrayDeque<Integer> st = new ArrayDeque<>();\n        // Push 1,2,3 then pop and print each\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        ArrayDeque<Integer> st = new ArrayDeque<>();\n        st.push(1); st.push(2); st.push(3);\n        System.out.println(st.pop());\n        System.out.println(st.pop());\n        System.out.println(st.pop());\n    }\n}",
      "fullSolutionCommented": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Use ArrayDeque as a stack (LIFO): push, then pop.\n        ArrayDeque<Integer> st = new ArrayDeque<>();\n        st.push(1); st.push(2); st.push(3);\n        System.out.println(st.pop()); // 3\n        System.out.println(st.pop()); // 2\n        System.out.println(st.pop()); // 1\n    }\n}",
      "expectedOutput": "3\n2\n1",
      "tutorial": "<p class=\"mb-4 text-gray-300\">`ArrayDeque` implements the `Deque` interface and supports efficient stack operations.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">ArrayDeque&lt;String&gt; s = new ArrayDeque<>();\ns.push(\"x\"); s.push(\"y\");\nSystem.out.println(s.pop()); // y</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding arraydeque as stack is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying arraydeque as stack, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply arraydeque as stack will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with arraydeque as stack, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 137,
      "title": "137. TreeSet Comparator",
      "description": "Use a custom Comparator to sort by length then lexicographically and print the first element.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Comparator<String> cmp = Comparator.comparingInt(String::length).thenComparing(Comparator.naturalOrder());\n        // Create a TreeSet with this comparator, add 'pear','fig','apple' then print first element\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Comparator<String> cmp = Comparator.comparingInt(String::length).thenComparing(Comparator.naturalOrder());\n        TreeSet<String> ts = new TreeSet<>(cmp);\n        ts.add(\"pear\"); ts.add(\"fig\"); ts.add(\"apple\");\n        System.out.println(ts.first());\n    }\n}",
      "fullSolutionCommented": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Sort by string length, then lexicographically to break ties.\n        Comparator<String> cmp = Comparator.comparingInt(String::length)\n                                           .thenComparing(Comparator.naturalOrder());\n        TreeSet<String> ts = new TreeSet<>(cmp);\n        ts.add(\"pear\"); ts.add(\"fig\"); ts.add(\"apple\");\n        System.out.println(ts.first()); // fig\n    }\n}",
      "expectedOutput": "fig",
      "tutorial": "<p class=\"mb-4 text-gray-300\">`TreeSet` orders its elements according to a Comparator you supply.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Comparator&lt;String&gt; byLen = Comparator.comparingInt(String::length);\nTreeSet&lt;String&gt; set = new TreeSet<>(byLen.thenComparing(Comparator.naturalOrder()));</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding treeset comparator is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying treeset comparator, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply treeset comparator will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with treeset comparator, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Collections",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 138,
      "title": "138. LRU via LinkedHashMap",
      "description": "Limit size to 2 and print remaining keys after inserts.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create a LinkedHashMap with accessOrder=false and override removeEldestEntry to keep size<=2\n        // Put a=1, b=2, c=3 then iterate keys and print each on its own line\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        LinkedHashMap<String,Integer> lru = new LinkedHashMap<String,Integer>(16, 0.75f, false) {\n            protected boolean removeEldestEntry(Map.Entry<String,Integer> e) {\n                return size() > 2;\n            }\n        };\n        lru.put(\"a\",1); lru.put(\"b\",2); lru.put(\"c\",3);\n        for (String k : lru.keySet()) System.out.println(k);\n    }\n}",
      "fullSolutionCommented": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Implement a tiny size-bounded cache by overriding removeEldestEntry.\n        LinkedHashMap<String,Integer> lru = new LinkedHashMap<String,Integer>(16, 0.75f, false) {\n            protected boolean removeEldestEntry(Map.Entry<String,Integer> e) {\n                return size() > 2; // evict oldest when size exceeds 2\n            }\n        };\n        lru.put(\"a\",1); lru.put(\"b\",2); lru.put(\"c\",3); // 'a' evicted\n        for (String k : lru.keySet()) System.out.println(k); // b, c\n    }\n}",
      "expectedOutput": "b\nc",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Subclass `LinkedHashMap` and override `removeEldestEntry` to implement a simple LRU-style eviction by size.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">LinkedHashMap&lt;K,V&gt; cache = new LinkedHashMap&lt;&gt;() {\n  protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; e) { return size() &gt; 100; }\n};</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding lru via linkedhashmap is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying lru via linkedhashmap, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply lru via linkedhashmap will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with lru via linkedhashmap, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Control Flow",
        "OOP",
        "Security"
      ]
    },
    {
      "id": 139,
      "title": "139. StringJoiner",
      "description": "Join strings with delimiter, prefix, and suffix.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Join [a,b,c] into [a,b,c] using StringJoiner and print\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        StringJoiner sj = new StringJoiner(\",\", \"[\", \"]\");\n        sj.add(\"a\").add(\"b\").add(\"c\");\n        System.out.println(sj.toString());\n    }\n}",
      "fullSolutionCommented": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Join elements with custom delimiter and enclosing brackets.\n        StringJoiner sj = new StringJoiner(\",\", \"[\", \"]\");\n        sj.add(\"a\").add(\"b\").add(\"c\");\n        System.out.println(sj.toString()); // [a,b,c]\n    }\n}",
      "expectedOutput": "[a,b,c]",
      "tutorial": "<p class=\"mb-4 text-gray-300\">`StringJoiner` helps build delimited strings with optional prefix/suffix.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">StringJoiner sj = new StringJoiner(\", \", \"(\", \")\");\nsj.add(\"x\").add(\"y\");\nSystem.out.println(sj); // (x, y)</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding stringjoiner is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying stringjoiner, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply stringjoiner will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with stringjoiner, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Strings",
        "OOP"
      ]
    },
    {
      "id": 140,
      "title": "140. BigDecimal Rounding",
      "description": "Round 2.456 to 2 decimal places using HALF_UP and print it.",
      "initialCode": "import java.math.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create BigDecimal 2.456, round to 2 places HALF_UP, print\n\n    }\n}",
      "fullSolution": "import java.math.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        BigDecimal bd = new BigDecimal(\"2.456\").setScale(2, RoundingMode.HALF_UP);\n        System.out.println(bd.toString());\n    }\n}",
      "fullSolutionCommented": "import java.math.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Use BigDecimal for precise decimal arithmetic; set scale and rounding mode.\n        BigDecimal bd = new BigDecimal(\"2.456\").setScale(2, RoundingMode.HALF_UP);\n        System.out.println(bd.toString()); // 2.46\n    }\n}",
      "expectedOutput": "2.46",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use `BigDecimal` for precise decimal arithmetic and control rounding.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">new BigDecimal(\"1.005\").setScale(2, RoundingMode.HALF_UP); // 1.01</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding bigdecimal rounding is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying bigdecimal rounding, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply bigdecimal rounding will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with bigdecimal rounding, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Control Flow",
        "OOP",
        "Math and Stats"
      ]
    },
    {
      "id": 141,
      "title": "141. Capstone: Event Duration",
      "description": "Sum durations for CLICK events using streams and print the total.",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\nclass Event { String type; int ms; Event(String t,int m){ type=t; ms=m; } }\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Event> es = Arrays.asList(new Event(\"CLICK\",10), new Event(\"VIEW\",5), new Event(\"CLICK\",20));\n        // Sum ms for CLICK events and print the total\n\n    }\n}",
      "fullSolution": "import java.util.*;\nimport java.util.stream.*;\n\nclass Event { String type; int ms; Event(String t,int m){ type=t; ms=m; } }\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Event> es = Arrays.asList(new Event(\"CLICK\",10), new Event(\"VIEW\",5), new Event(\"CLICK\",20));\n        int total = es.stream().filter(e -> e.type.equals(\"CLICK\"))\n            .mapToInt(e -> e.ms).sum();\n        System.out.println(total);\n    }\n}",
      "fullSolutionCommented": "import java.util.*;\nimport java.util.stream.*;\n\nclass Event { String type; int ms; Event(String t,int m){ type=t; ms=m; } }\n\npublic class Main {\n    public static void main(String[] args) {\n        // Filter by event type, project to durations, then sum.\n        List<Event> es = Arrays.asList(new Event(\"CLICK\",10), new Event(\"VIEW\",5), new Event(\"CLICK\",20));\n        int total = es.stream()\n                      .filter(e -> e.type.equals(\"CLICK\"))\n                      .mapToInt(e -> e.ms)\n                      .sum();\n        System.out.println(total); // 30\n    }\n}",
      "expectedOutput": "30",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Combine filtering and aggregation in a stream pipeline to compute metrics from domain objects.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">int sum = list.stream().filter(x -&gt; x &gt; 0).mapToInt(Integer::intValue).sum();</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding capstone: event duration is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying capstone: event duration, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply capstone: event duration will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with capstone: event duration, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Collections",
        "OOP",
        "Web"
      ]
    },
    {
      "id": 142,
      "title": "142. Map.merge (counting)",
      "language": "java",
      "description": "Use Map.merge to count occurrences and print the count for 'a'.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        String[] xs = {\"a\", \"b\", \"a\"};\n        Map<String, Integer> m = new HashMap<>();\n        // Use merge to count occurrences in m, then print m.get(\"a\") (should be 2)\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        String[] xs = {\"a\", \"b\", \"a\"};\n        Map<String, Integer> m = new HashMap<>();\n        for (String s : xs) {\n            m.merge(s, 1, Integer::sum);\n        }\n        System.out.println(m.get(\"a\"));\n    }\n}",
      "expectedOutput": "2",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>Map.merge</code> simplifies counters: initialize when absent, otherwise combine with a function (e.g., <code>Integer::sum</code>).</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">java.util.Map<String,Integer> m = new java.util.HashMap<>();\nm.merge(\"k\", 1, Integer::sum);</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding map.merge (counting) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying map.merge (counting), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply map.merge (counting) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with map.merge (counting), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Functions",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 143,
      "title": "143. LinkedHashSet (dedupe, preserve order)",
      "language": "java",
      "description": "Remove duplicates while preserving insertion order and print the size.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        String[] xs = {\"a\", \"b\", \"a\", \"c\"};\n        // Put in a LinkedHashSet to dedupe while preserving order, then print size (3)\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        String[] xs = {\"a\", \"b\", \"a\", \"c\"};\n        Set<String> s = new LinkedHashSet<>(Arrays.asList(xs));\n        System.out.println(s.size());\n    }\n}",
      "expectedOutput": "3",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>LinkedHashSet</code> preserves insertion order while removing duplicates.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        String[] xs = {\"a\", \"b\", \"a\", \"c\"};\n        Set&lt;String&gt; s = new LinkedHashSet&lt;&gt;(Arrays.asList(xs));\n        System.out.println(s.size());\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding linkedhashset (dedupe, preserve order) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying linkedhashset (dedupe, preserve order), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply linkedhashset (dedupe, preserve order) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with linkedhashset (dedupe, preserve order), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Collections",
        "OOP",
        "Security"
      ]
    },
    {
      "id": 144,
      "title": "144. groupingBy + summingInt",
      "language": "java",
      "description": "Group strings by first character and sum their lengths.",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> xs = Arrays.asList(\"ax\", \"by\", \"az\");\n        // Group by first char and sum lengths; print sum for key 'a' (4)\n\n    }\n}",
      "fullSolution": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> xs = Arrays.asList(\"ax\", \"by\", \"az\");\n        Map<Character,Integer> m = xs.stream().collect(\n            Collectors.groupingBy(s -> s.charAt(0), Collectors.summingInt(String::length))\n        );\n        System.out.println(m.get('a'));\n    }\n}",
      "expectedOutput": "4",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use <code>Collectors.groupingBy</code> with <code>summingInt</code> to aggregate values per key.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List&lt;String&gt; xs = Arrays.asList(\"ax\", \"by\", \"az\");\n        Map&lt;Character,Integer&gt; m = xs.stream().collect(\n            Collectors.groupingBy(s -&gt; s.charAt(0), Collectors.summingInt(String::length))\n        );\n        System.out.println(m.get('a'));\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding groupingby + summingint is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying groupingby + summingint, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply groupingby + summingint will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with groupingby + summingint, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Strings",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 145,
      "title": "145. Files.createDirectories + size",
      "language": "java",
      "description": "Create a directory and file, write text, then print file size.",
      "initialCode": "import java.nio.file.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Create dir 'd', write \"hi\" to d/t.txt, then print file size (2)\n\n    }\n}",
      "fullSolution": "import java.nio.file.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Path dir = Paths.get(\"d\");\n        Files.createDirectories(dir);\n        Path p = dir.resolve(\"t.txt\");\n        try (BufferedWriter w = Files.newBufferedWriter(p)) {\n            w.write(\"hi\");\n        }\n        System.out.println(Files.size(p));\n    }\n}",
      "expectedOutput": "2",
      "tutorial": "<p class=\"mb-4 text-gray-300\">NIO.2 APIs (<code>java.nio.file</code>) support portable path operations and buffered I/O. Always close streams via try-with-resources.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.nio.file.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Path dir = Paths.get(\"d\");\n        Files.createDirectories(dir);\n        Path p = dir.resolve(\"t.txt\");\n        try (BufferedWriter w = Files.newBufferedWriter(p)) {\n            w.write(\"hi\");\n        }\n        System.out.println(Files.size(p));</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding files.createdirectories + size is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying files.createdirectories + size, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply files.createdirectories + size will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with files.createdirectories + size, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "OOP",
        "I/O"
      ]
    },
    {
      "id": 146,
      "title": "146. LocalDate + format",
      "language": "java",
      "description": "Add one day to a date and print ISO format.",
      "initialCode": "import java.time.*;\nimport java.time.format.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create LocalDate.of(2020,1,1), plus one day, and print as yyyy-MM-dd\n\n    }\n}",
      "fullSolution": "import java.time.*;\nimport java.time.format.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        LocalDate d = LocalDate.of(2020, 1, 1).plusDays(1);\n        System.out.println(d.format(DateTimeFormatter.ISO_LOCAL_DATE));\n    }\n}",
      "expectedOutput": "2020-01-02",
      "tutorial": "<p class=\"mb-4 text-gray-300\">The Java Time API (JSR-310) offers immutable date/time types; use <code>DateTimeFormatter</code> for formatting.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.time.*;\nimport java.time.format.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        LocalDate d = LocalDate.of(2020, 1, 1).plusDays(1);\n        System.out.println(d.format(DateTimeFormatter.ISO_LOCAL_DATE));\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding localdate + format is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying localdate + format, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply localdate + format will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with localdate + format, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Tooling",
        "Control Flow",
        "Strings",
        "OOP"
      ]
    },
    {
      "id": 147,
      "title": "147. Optional.orElseGet",
      "language": "java",
      "description": "Provide a lazy fallback when Optional is empty.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Optional<String> s = Optional.ofNullable(null);\n        // Use orElseGet to print \"fallback\"\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Optional<String> s = Optional.ofNullable(null);\n        System.out.println(s.orElseGet(() -> \"fallback\"));\n    }\n}",
      "expectedOutput": "fallback",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>orElseGet</code> evaluates the supplier only if the Optional is empty, avoiding unnecessary work.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Optional&lt;String&gt; s = Optional.ofNullable(null);\n        System.out.println(s.orElseGet(() -&gt; \"fallback\"));\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding optional.orelseget is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying optional.orelseget, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply optional.orelseget will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with optional.orelseget, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "OOP"
      ]
    },
    {
      "id": 148,
      "title": "148. IntStream.reduce (product)",
      "language": "java",
      "description": "Compute a product using IntStream.reduce.",
      "initialCode": "import java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Print the product of 1..4 using IntStream.reduce (should be 24)\n\n    }\n}",
      "fullSolution": "import java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int prod = IntStream.rangeClosed(1, 4).reduce(1, (a,b) -> a*b);\n        System.out.println(prod);\n    }\n}",
      "expectedOutput": "24",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use a neutral identity (1 for multiplication) with <code>reduce</code> to fold a stream into a single value.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int prod = IntStream.rangeClosed(1, 4).reduce(1, (a,b) -&gt; a*b);\n        System.out.println(prod);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding intstream.reduce (product) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying intstream.reduce (product), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply intstream.reduce (product) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with intstream.reduce (product), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "OOP",
        "Functional",
        "Streams"
      ]
    },
    {
      "id": 149,
      "title": "149. String.join",
      "language": "java",
      "description": "Join a list of strings with a delimiter.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> xs = Arrays.asList(\"a\", \"b\", \"c\");\n        // Join with '-' and print 'a-b-c'\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> xs = Arrays.asList(\"a\", \"b\", \"c\");\n        System.out.println(String.join(\"-\", xs));\n    }\n}",
      "expectedOutput": "a-b-c",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>String.join</code> is a convenient way to concatenate with delimiters.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List&lt;String&gt; xs = Arrays.asList(\"a\", \"b\", \"c\");\n        System.out.println(String.join(\"-\", xs));\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding string.join is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying string.join, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply string.join will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with string.join, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Strings",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 150,
      "title": "150. Arrays.binarySearch",
      "language": "java",
      "description": "Binary search for a value in a sorted array and print the index.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] a = {1, 3, 5};\n        // Use Arrays.binarySearch to find 3 and print the index (1)\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] a = {1, 3, 5};\n        System.out.println(Arrays.binarySearch(a, 3));\n    }\n}",
      "expectedOutput": "1",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>Arrays.binarySearch</code> returns the index of the key if found; the array must be sorted.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] a = {1, 3, 5};\n        System.out.println(Arrays.binarySearch(a, 3));\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding arrays.binarysearch is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying arrays.binarysearch, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply arrays.binarysearch will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with arrays.binarysearch, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Collections",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 151,
      "title": "151. Collections.frequency",
      "language": "java",
      "description": "Count how many times an element appears in a collection.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> xs = Arrays.asList(\"a\", \"a\", \"b\");\n        // Use Collections.frequency to count 'a' and print 2\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> xs = Arrays.asList(\"a\", \"a\", \"b\");\n        System.out.println(Collections.frequency(xs, \"a\"));\n    }\n}",
      "expectedOutput": "2",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>Collections.frequency</code> scans a collection to count occurrences of an element.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List&lt;String&gt; xs = Arrays.asList(\"a\", \"a\", \"b\");\n        System.out.println(Collections.frequency(xs, \"a\"));\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding collections.frequency is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying collections.frequency, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply collections.frequency will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with collections.frequency, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 152,
      "title": "152. StringTokenizer parsing",
      "language": "java",
      "description": "Use StringTokenizer to split a CSV line and print each token on a new line.",
      "initialCode": "import java.util.StringTokenizer;\n\npublic class Main {\n    public static void main(String[] args) {\n        String csv = \"apple,banana,cherry\";\n        \n        // TODO: use StringTokenizer with \",\" delimiter to split and print each token\n    }\n}\n",
      "fullSolution": "import java.util.StringTokenizer;\n\npublic class Main {\n    public static void main(String[] args) {\n        String csv = \"apple,banana,cherry\";\n        StringTokenizer tokenizer = new StringTokenizer(csv, \",\");\n        while (tokenizer.hasMoreTokens()) {\n            System.out.println(tokenizer.nextToken());\n        }\n    }\n}\n",
      "expectedOutput": "apple\nbanana\ncherry",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>StringTokenizer</code> is a legacy class for splitting strings by delimiters. While <code>String.split()</code> is more common today, StringTokenizer can be more efficient for simple cases.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">StringTokenizer tokenizer = new StringTokenizer(text, delimiter);\nwhile (tokenizer.hasMoreTokens()) {\n    String token = tokenizer.nextToken();\n    System.out.println(token);\n}</pre></div><p class=\"mt-4 text-gray-300\">For modern code, prefer <code>String.split()</code> or <code>Pattern</code> with regex for more flexibility.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding stringtokenizer parsing is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying stringtokenizer parsing, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply stringtokenizer parsing will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with stringtokenizer parsing, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Strings",
        "Parsing"
      ]
    },
    {
      "id": 153,
      "title": "153. BigInteger mod pow",
      "description": "Compute 2^10 mod 1000 using BigInteger.",
      "initialCode": "import java.math.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Print 2^10 mod 1000\n\n    }\n}",
      "fullSolution": "import java.math.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(BigInteger.valueOf(2).pow(10).mod(BigInteger.valueOf(1000)));\n    }\n}",
      "expectedOutput": "24",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use <code>BigInteger</code> for arbitrary-precision math, including modular operations used in cryptography.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">BigInteger a = new BigInteger(\"12345678901234567890\");</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding biginteger mod pow is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying biginteger mod pow, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply biginteger mod pow will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with biginteger mod pow, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Control Flow",
        "OOP",
        "Math and Stats",
        "Algorithms"
      ]
    },
    {
      "id": 154,
      "title": "154. Capstone: Word Count Top2",
      "description": "Count words and print the top 2 by frequency (key:count).",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        String s = \"a b a c b b\";\n        // Count words and print top 2 as 'b:3' then 'a:2' on separate lines\n\n    }\n}",
      "fullSolution": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        String s = \"a b a c b b\";\n        Map<String, Long> m = Arrays.stream(s.split(\" \")).collect(Collectors.groupingBy(x -> x, Collectors.counting()));\n        m.entrySet().stream()\n            .sorted((e1,e2) -> Long.compare(e2.getValue(), e1.getValue()))\n            .limit(2)\n            .forEach(e -> System.out.println(e.getKey()+\":\"+e.getValue()));\n    }\n}",
      "expectedOutput": "b:3\na:2",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Combine groupingBy+counting with a custom sort to get top-k frequencies.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        String s = \"a b a c b b\";\n        Map&lt;String, Long&gt; m = Arrays.stream(s.split(\" \")).collect(Collectors.groupingBy(x -&gt; x, Collectors.counting()));\n        m.entrySet().stream()\n            .sorted((e1,e2) -&gt; Long.compare(e2.getValue(), e1.getValue()))\n            .limit(2)\n            .forEach(e -&gt; System.out.println(e.getKey()+\":\"+e.getValue()));\n    }</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding capstone: word count top2 is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying capstone: word count top2, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply capstone: word count top2 will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with capstone: word count top2, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Strings",
        "Collections",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 155,
      "title": "155. Capstone: CompletableFuture Timeout",
      "description": "Use completeOnTimeout to return 'fast' if slow task exceeds 100ms.",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Build a future that sleeps 1s then returns \"slow\"\n        // Use completeOnTimeout(\"fast\", 100, MILLISECONDS) and print the result\n\n    }\n}",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        CompletableFuture<String> slow = CompletableFuture.supplyAsync(() -> {\n            try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); }\n            return \"slow\";\n        });\n        System.out.println(slow.completeOnTimeout(\"fast\", 100, TimeUnit.MILLISECONDS).join());\n    }\n}",
      "expectedOutput": "fast",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Bound latency by completing a future with a fallback if it exceeds a deadline.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        CompletableFuture&lt;String&gt; slow = CompletableFuture.supplyAsync(() -&gt; {\n            try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); }\n            return \"slow\";\n        });\n        System.out.println(slow.completeOnTimeout(\"fast\", 100, TimeUnit.MILLISECONDS).join());\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding capstone: completablefuture timeout is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying capstone: completablefuture timeout, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply capstone: completablefuture timeout will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with capstone: completablefuture timeout, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Strings",
        "OOP",
        "Concurrency"
      ]
    },
    {
      "id": 156,
      "title": "156. Capstone: NIO Files + Grouping",
      "description": "Create temp files and group names by extension; print 'txt:2'.",
      "initialCode": "import java.nio.file.*;\nimport java.io.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Create files a.txt, b.txt, c.log in CWD, then group by extension and print 'txt:2'\n\n    }\n}",
      "fullSolution": "import java.nio.file.*;\nimport java.io.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Files.writeString(Path.of(\"a.txt\"), \"a\");\n        Files.writeString(Path.of(\"b.txt\"), \"b\");\n        Files.writeString(Path.of(\"c.log\"), \"c\");\n        Map<String, Long> m = Files.list(Path.of(\".\"))\n            .filter(p -> Files.isRegularFile(p))\n            .collect(Collectors.groupingBy(p -> { String n=p.getFileName().toString(); int i=n.lastIndexOf('.'); return i==-1?\"\":n.substring(i+1); }, Collectors.counting()));\n        System.out.println(\"txt:\" + m.get(\"txt\"));\n    }\n}",
      "expectedOutput": "txt:2",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use NIO <code>Files</code> utilities to write and list paths; group with streams.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.nio.file.*;\nimport java.io.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Files.writeString(Path.of(\"a.txt\"), \"a\");\n        Files.writeString(Path.of(\"b.txt\"), \"b\");\n        Files.writeString(Path.of(\"c.log\"), \"c\");\n        Map&lt;String, Long&gt; m = Files.list(Path.of(\".\"))\n            .filter(p -&gt; Files.isRegularFile(p))</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding capstone: nio files + grouping is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying capstone: nio files + grouping, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply capstone: nio files + grouping will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with capstone: nio files + grouping, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Strings",
        "Collections",
        "OOP",
        "I/O"
      ]
    },
    {
      "id": 157,
      "title": "157. Capstone: Parallel Stream SumSquares",
      "description": "Compute sum of squares 1..1000 in parallel and print it.",
      "initialCode": "import java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Use IntStream.rangeClosed with parallel() to compute sum of squares and print it\n\n    }\n}",
      "fullSolution": "import java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        long sum = IntStream.rangeClosed(1, 1000).parallel().mapToLong(i -> (long)i*i).sum();\n        System.out.println(sum);\n    }\n}",
      "expectedOutput": "333833500",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Parallel streams can speed up CPU-bound aggregations on large ranges.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        long sum = IntStream.rangeClosed(1, 1000).parallel().mapToLong(i -&gt; (long)i*i).sum();\n        System.out.println(sum);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding capstone: parallel stream sumsquares is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying capstone: parallel stream sumsquares, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply capstone: parallel stream sumsquares will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with capstone: parallel stream sumsquares, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "OOP",
        "Streams"
      ]
    },
    {
      "id": 158,
      "title": "158. Capstone: CountDownLatch",
      "description": "Coordinate two threads and print 'done' after both complete.",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Create CountDownLatch(2); start two threads that sleep briefly then countDown; await and print 'done'\n\n    }\n}",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        CountDownLatch latch = new CountDownLatch(2);\n        Runnable r = () -> { try { Thread.sleep(50); } catch (InterruptedException e) {} finally { latch.countDown(); } };\n        new Thread(r).start();\n        new Thread(r).start();\n        latch.await();\n        System.out.println(\"done\");\n    }\n}",
      "expectedOutput": "done",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use <code>CountDownLatch</code> to wait for a set of operations to complete.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        CountDownLatch latch = new CountDownLatch(2);\n        Runnable r = () -&gt; { try { Thread.sleep(50); } catch (InterruptedException e) {} finally { latch.countDown(); } };\n        new Thread(r).start();\n        new Thread(r).start();\n        latch.await();\n        System.out.println(\"done\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding capstone: countdownlatch is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying capstone: countdownlatch, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply capstone: countdownlatch will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with capstone: countdownlatch, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Collections",
        "OOP",
        "Concurrency"
      ]
    },
    {
      "id": 159,
      "title": "159. ConcurrentHashMap merge",
      "language": "java",
      "description": "Use merge to maintain a thread-safe counter.",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        ConcurrentHashMap<String, Integer> m = new ConcurrentHashMap<>();\n        // Increment key 'a' twice using merge and print the value (2)\n\n    }\n}",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        ConcurrentHashMap<String, Integer> m = new ConcurrentHashMap<>();\n        m.merge(\"a\", 1, Integer::sum);\n        m.merge(\"a\", 1, Integer::sum);\n        System.out.println(m.get(\"a\"));\n    }\n}",
      "expectedOutput": "2",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>ConcurrentHashMap.merge</code> atomically updates a value given a remapping function, avoiding explicit locks for simple counters.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">ConcurrentHashMap<String,Integer> m = new ConcurrentHashMap<>();\nm.merge(\"k\", 1, Integer::sum);\nm.merge(\"k\", 1, Integer::sum);\nSystem.out.println(m.get(\"k\")); // 2</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding concurrenthashmap merge is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying concurrenthashmap merge, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply concurrenthashmap merge will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with concurrenthashmap merge, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Functions",
        "OOP",
        "Concurrency"
      ]
    },
    {
      "id": 160,
      "title": "160. computeIfAbsent (grouping)",
      "language": "java",
      "description": "Initialize a list per key with computeIfAbsent and add items.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, List<Integer>> m = new HashMap<>();\n        // Add 10 and 20 under key 'k' using computeIfAbsent, then print list size (2)\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, List<Integer>> m = new HashMap<>();\n        m.computeIfAbsent(\"k\", k -> new ArrayList<>()).add(10);\n        m.computeIfAbsent(\"k\", k -> new ArrayList<>()).add(20);\n        System.out.println(m.get(\"k\").size());\n    }\n}",
      "expectedOutput": "2",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>computeIfAbsent</code> simplifies multi-map style grouping: initialize a container when a key is first seen.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Map<String, List<Integer>> m = new HashMap<>();\nm.computeIfAbsent(\"k\", k -> new ArrayList<>()).add(1);</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding computeifabsent (grouping) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying computeifabsent (grouping), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply computeifabsent (grouping) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with computeifabsent (grouping), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Collections",
        "OOP",
        "Security"
      ]
    },
    {
      "id": 161,
      "title": "161. CompletableFuture allOf",
      "language": "java",
      "description": "Wait for several futures and combine results.",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Create two supplyAsync futures returning \"A\" and \"B\"; wait for all and print \"AB\"\n\n    }\n}",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> \"A\");\n        CompletableFuture<String> f2 = CompletableFuture.supplyAsync(() -> \"B\");\n        CompletableFuture.allOf(f1, f2).join();\n        System.out.println(f1.get() + f2.get());\n    }\n}",
      "expectedOutput": "AB",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>allOf</code> joins multiple futures; use their individual results after it completes.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">CompletableFuture<String> a = CompletableFuture.supplyAsync(() -> \"A\");\nCompletableFuture<String> b = CompletableFuture.supplyAsync(() -> \"B\");\nCompletableFuture.allOf(a,b).join();\nSystem.out.println(a.join()+b.join());</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding completablefuture allof is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying completablefuture allof, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply completablefuture allof will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with completablefuture allof, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Strings",
        "OOP",
        "Concurrency"
      ]
    },
    {
      "id": 162,
      "title": "162. thenCompose (dependent async)",
      "language": "java",
      "description": "Chain futures where the second depends on the first.",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Start with 2, then square it in a second async stage and print 4\n\n    }\n}",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        CompletableFuture<Integer> f = CompletableFuture.supplyAsync(() -> 2)\n            .thenCompose(x -> CompletableFuture.supplyAsync(() -> x * x));\n        System.out.println(f.join());\n    }\n}",
      "expectedOutput": "4",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>thenCompose</code> flattens nested futures and is the right choice when the next step is itself asynchronous.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">CompletableFuture.supplyAsync(() -> 2)\n  .thenCompose(x -> CompletableFuture.supplyAsync(() -> x+1))\n  .thenAccept(System.out::println);</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding thencompose (dependent async) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying thencompose (dependent async), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply thencompose (dependent async) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with thencompose (dependent async), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Strings",
        "OOP",
        "Concurrency",
        "Async"
      ]
    },
    {
      "id": 163,
      "title": "163. LongAdder (concurrency)",
      "language": "java",
      "description": "High-throughput counter under contention.",
      "initialCode": "import java.util.concurrent.*;\nimport java.util.concurrent.atomic.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Increment a LongAdder 100 times across a thread pool, then print sum (100)\n\n    }\n}",
      "fullSolution": "import java.util.concurrent.*;\nimport java.util.concurrent.atomic.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        LongAdder adder = new LongAdder();\n        ExecutorService es = Executors.newFixedThreadPool(4);\n        for (int i=0;i<100;i++) es.submit(adder::increment);\n        es.shutdown();\n        es.awaitTermination(5, TimeUnit.SECONDS);\n        System.out.println(adder.sum());\n    }\n}",
      "expectedOutput": "100",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>LongAdder</code> scales better than <code>AtomicLong</code> under high contention by maintaining multiple cells and aggregating on demand.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">LongAdder a = new LongAdder(); a.increment(); System.out.println(a.sum());</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding longadder (concurrency) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying longadder (concurrency), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply longadder (concurrency) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with longadder (concurrency), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "OOP",
        "Algorithms",
        "Concurrency"
      ]
    },
    {
      "id": 164,
      "title": "164. Semaphore (limit concurrency)",
      "language": "java",
      "description": "Bound parallelism with a Semaphore and count completions.",
      "initialCode": "import java.util.concurrent.*;\nimport java.util.concurrent.atomic.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Use a Semaphore(2) and run 3 tasks; increment an AtomicInteger when each finishes, then print 3\n\n    }\n}",
      "fullSolution": "import java.util.concurrent.*;\nimport java.util.concurrent.atomic.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Semaphore sem = new Semaphore(2);\n        AtomicInteger done = new AtomicInteger(0);\n        ExecutorService es = Executors.newFixedThreadPool(3);\n        Runnable r = () -> {\n            try { sem.acquire(); try { /* work */ } finally { sem.release(); } done.incrementAndGet(); }\n            catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        };\n        es.submit(r); es.submit(r); es.submit(r);\n        es.shutdown(); es.awaitTermination(5, TimeUnit.SECONDS);\n        System.out.println(done.get());\n    }\n}",
      "expectedOutput": "3",
      "tutorial": "<p class=\"mb-4 text-gray-300\">A <code>Semaphore</code> limits how many threads can enter a critical region simultaneously, useful for rate-limiting or resource pools.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Semaphore s = new Semaphore(2); s.acquire(); try { /* work */ } finally { s.release(); }</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding semaphore (limit concurrency) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying semaphore (limit concurrency), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply semaphore (limit concurrency) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with semaphore (limit concurrency), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "OOP",
        "Algorithms",
        "Concurrency"
      ]
    },
    {
      "id": 165,
      "title": "165. IntSummaryStatistics",
      "language": "java",
      "description": "Summarize numeric streams with min/max/sum/count.",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Compute summary statistics for [1,2,3,4] and print 'min=1,max=4,sum=10'\n\n    }\n}",
      "fullSolution": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        IntSummaryStatistics st = Arrays.asList(1,2,3,4).stream().mapToInt(Integer::intValue).summaryStatistics();\n        System.out.println(\"min=\"+st.getMin()+\",max=\"+st.getMax()+\",sum=\"+st.getSum());\n    }\n}",
      "expectedOutput": "min=1,max=4,sum=10",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Map to a primitive stream with <code>mapToInt</code> and use <code>summaryStatistics()</code> to get aggregate metrics in one pass.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">IntSummaryStatistics s = IntStream.of(5,1,9).summaryStatistics();\nSystem.out.println(s.getMax()); // 9</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding intsummarystatistics is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying intsummarystatistics, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply intsummarystatistics will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with intsummarystatistics, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Collections",
        "OOP",
        "Math and Stats"
      ]
    },
    {
      "id": 166,
      "title": "166. collectingAndThen",
      "language": "java",
      "description": "Post-process a collected result (e.g., make unmodifiable).",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Distinct ['a','b','a'] then wrap as unmodifiable list and print its size (2)\n\n    }\n}",
      "fullSolution": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> names = Arrays.asList(\"a\",\"b\",\"a\");\n        List<String> unique = names.stream().distinct().collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList));\n        System.out.println(unique.size());\n    }\n}",
      "expectedOutput": "2",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>collectingAndThen</code> applies a finisher after collecting, useful for wrapping or transforming the container.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">List<String> xs = List.of(\"a\", \"b\");\nList<String> ro = Collections.unmodifiableList(xs);</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding collectingandthen is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying collectingandthen, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply collectingandthen will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with collectingandthen, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Collections",
        "OOP",
        "Functional"
      ]
    },
    {
      "id": 167,
      "title": "167. Optional.flatMap",
      "language": "java",
      "description": "Flatten nested Optionals when mapping to another Optional.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    static Optional<Integer> parse(String s) {\n        // Return Optional.of(Integer.parseInt(s)) or Optional.empty() on failure\n        return Optional.empty();\n    }\n    public static void main(String[] args) {\n        // Use flatMap on Optional.of(\"7\") with parse and print the value or 0\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    static Optional<Integer> parse(String s) {\n        try { return Optional.of(Integer.parseInt(s)); } catch (Exception e) { return Optional.empty(); }\n    }\n    public static void main(String[] args) {\n        Optional<Integer> v = Optional.of(\"7\").flatMap(Main::parse);\n        System.out.println(v.orElse(0));\n    }\n}",
      "expectedOutput": "7",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>flatMap</code> avoids wrapping an Optional inside another Optional when your mapping returns an Optional.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Optional<String> s = Optional.of(\"42\");\nOptional<Integer> i = s.flatMap(x -> Optional.of(Integer.parseInt(x)));</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding optional.flatmap is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying optional.flatmap, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply optional.flatmap will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with optional.flatmap, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "OOP",
        "Functional",
        "Error Handling",
        "Parsing"
      ]
    },
    {
      "id": 168,
      "title": "168. computeIfPresent",
      "language": "java",
      "description": "Update an existing map entry in-place if present.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String,Integer> m = new HashMap<>();\n        m.put(\"x\", 1);\n        // Increase 'x' by 2 using computeIfPresent, then print 3\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String,Integer> m = new HashMap<>();\n        m.put(\"x\", 1);\n        m.computeIfPresent(\"x\", (k,v) -> v + 2);\n        System.out.println(m.get(\"x\"));\n    }\n}",
      "expectedOutput": "3",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>computeIfPresent</code> runs the remapping function only when the key exists, letting you update values atomically.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Map<String,Integer> m = new HashMap<>();\nm.put(\"x\", 1);\nm.computeIfPresent(\"x\", (k,v) -> v+1);</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding computeifpresent is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying computeifpresent, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply computeifpresent will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with computeifpresent, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Functions",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 169,
      "title": "169. ReadWriteLock",
      "language": "java",
      "description": "Protect a value with a read/write lock and print it.",
      "initialCode": "import java.util.concurrent.locks.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        ReadWriteLock rw = new ReentrantReadWriteLock();\n        int[] box = {0};\n        // Use writeLock to set box[0]=42, then use readLock to read and print it\n\n    }\n}",
      "fullSolution": "import java.util.concurrent.locks.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        ReadWriteLock rw = new ReentrantReadWriteLock();\n        int[] box = {0};\n        rw.writeLock().lock();\n        try { box[0] = 42; } finally { rw.writeLock().unlock(); }\n        rw.readLock().lock();\n        try { System.out.println(box[0]); } finally { rw.readLock().unlock(); }\n    }\n}",
      "expectedOutput": "42",
      "tutorial": "<p class=\"mb-4 text-gray-300\">A <code>ReadWriteLock</code> allows multiple concurrent readers or a single writer, improving throughput for read-heavy workloads.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">ReadWriteLock rw = new ReentrantReadWriteLock();\nrw.writeLock().lock(); try { /* write */ } finally { rw.writeLock().unlock(); }\nrw.readLock().lock(); try { /* read */ } finally { rw.readLock().unlock(); }</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding readwritelock is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying readwritelock, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply readwritelock will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with readwritelock, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Collections",
        "OOP",
        "I/O"
      ]
    },
    {
      "id": 170,
      "title": "170. ScheduledExecutor (fixed rate)",
      "language": "java",
      "description": "Run a task at a fixed rate and stop after 3 executions.",
      "initialCode": "import java.util.concurrent.*;\nimport java.util.concurrent.atomic.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Schedule a task at fixed rate that increments an AtomicInteger; stop after it reaches 3 and print 3\n\n    }\n}",
      "fullSolution": "import java.util.concurrent.*;\nimport java.util.concurrent.atomic.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        ScheduledExecutorService ses = Executors.newScheduledThreadPool(1);\n        AtomicInteger c = new AtomicInteger(0);\n        Runnable r = () -> { if (c.incrementAndGet() >= 3) ses.shutdown(); };\n        ses.scheduleAtFixedRate(r, 0, 1, TimeUnit.MILLISECONDS);\n        ses.awaitTermination(2, TimeUnit.SECONDS);\n        System.out.println(c.get());\n    }\n}",
      "expectedOutput": "3",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>ScheduledExecutorService</code> can run tasks periodically via <code>scheduleAtFixedRate</code>. Shut down the scheduler when your condition is met.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">ScheduledExecutorService s = Executors.newScheduledThreadPool(1);\nAtomicInteger c = new AtomicInteger();\ns.scheduleAtFixedRate(() -> { if (c.incrementAndGet()>=3) s.shutdown(); }, 0, 1, TimeUnit.MILLISECONDS);</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding scheduledexecutor (fixed rate) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying scheduledexecutor (fixed rate), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply scheduledexecutor (fixed rate) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with scheduledexecutor (fixed rate), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "OOP",
        "Algorithms",
        "Concurrency"
      ]
    },
    {
      "id": 171,
      "title": "171. Optional.ifPresentOrElse",
      "language": "java",
      "description": "Print a fallback when Optional is empty using ifPresentOrElse.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Optional<String> s = Optional.empty();\n        // Use ifPresentOrElse to print \"empty\"\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Optional<String> s = Optional.empty();\n        s.ifPresentOrElse(System.out::println, () -> System.out.println(\"empty\"));\n    }\n}",
      "expectedOutput": "empty",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>ifPresentOrElse</code> (Java 9+) handles both branches inline, improving clarity over <code>isPresent</code> checks.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Optional.of(\"X\").ifPresentOrElse(System.out::println, () -> System.out.println(\"fallback\"));</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding optional.ifpresentorelse is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying optional.ifpresentorelse, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply optional.ifpresentorelse will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with optional.ifpresentorelse, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "OOP"
      ]
    },
    {
      "id": 172,
      "title": "172. Files.lines + try-with-resources",
      "language": "java",
      "description": "Write a file, read it with Files.lines, and count matching lines.",
      "initialCode": "import java.nio.file.*;\nimport java.io.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Write lines A, B, A to a.txt; read and count lines equal to \"A\" and print 2\n+        // Use Files.newBufferedWriter and try-with-resources (Java 8 compatible)\n\n    }\n}",
      "fullSolution": "import java.nio.file.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Path temp = Files.createTempFile(\"test\", \".txt\");\n        try (BufferedWriter w = Files.newBufferedWriter(temp)) {\n            w.write(\"A\\n\");\n            w.write(\"B\\n\");\n            w.write(\"C\\n\");\n        }\n        try (var lines = Files.lines(temp)) {\n            lines.forEach(System.out::println);\n        }\n        Files.deleteIfExists(temp);\n    }\n}",
      "expectedOutput": "A\\nB\\nC",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>Files.lines</code> streams file content lazily; combine with try-with-resources to ensure the file handle is closed.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">try (java.util.stream.Stream&lt;String&gt; s = java.nio.file.Files.lines(java.nio.file.Paths.get(\"f.txt\"))) { /* use stream */ }</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding files.lines + try-with-resources is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying files.lines + try-with-resources, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply files.lines + try-with-resources will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with files.lines + try-with-resources, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "OOP",
        "I/O",
        "Functional",
        "Streams"
      ]
    },
    {
      "id": 173,
      "title": "173. Collectors.mapping",
      "language": "java",
      "description": "Map elements during collection (e.g., to a Set) and aggregate.",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Map ['a','bb'] to their lengths in a Set using Collectors.mapping, then print the sum of the set's elements (3)\n\n    }\n}",
      "fullSolution": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> xs = Arrays.asList(\"a\", \"bb\");\n        Set<Integer> lens = xs.stream().collect(Collectors.mapping(String::length, Collectors.toSet()));\n        int sum = lens.stream().mapToInt(Integer::intValue).sum();\n        System.out.println(sum);\n    }\n}",
      "expectedOutput": "3",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>Collectors.mapping</code> transforms elements as they are being collected, without an explicit pre-<code>map</code> step.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Set<Integer> s = List.of(\"a\",\"bbb\").stream()\n  .collect(Collectors.mapping(String::length, Collectors.toSet()));</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding collectors.mapping is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying collectors.mapping, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply collectors.mapping will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with collectors.mapping, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Collections",
        "OOP",
        "Functional",
        "Streams"
      ]
    },
    {
      "id": 174,
      "title": "174. BigInteger factorial",
      "language": "java",
      "description": "Compute 10! using BigInteger and print the result.",
      "initialCode": "import java.math.BigInteger;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Compute factorial of 10 using BigInteger and print it\n\n    }\n}",
      "fullSolution": "import java.math.BigInteger;\n\npublic class Main {\n    public static void main(String[] args) {\n        BigInteger f = BigInteger.ONE;\n        for (int i = 2; i <= 10; i++) {\n            f = f.multiply(BigInteger.valueOf(i));\n        }\n        System.out.println(f);\n    }\n}",
      "expectedOutput": "3628800",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>BigInteger</code> handles integers larger than <code>long</code> without overflow. Multiply iteratively to build factorial values.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">java.math.BigInteger x = java.math.BigInteger.TEN;\nSystem.out.println(x.pow(3));</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding biginteger factorial is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying biginteger factorial, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply biginteger factorial will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with biginteger factorial, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "OOP",
        "Math and Stats"
      ]
    },
    {
      "id": 175,
      "title": "175. Stream join + map",
      "language": "java",
      "description": "Uppercase and join a list using Collectors.joining.",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> xs = Arrays.asList(\"a\", \"b\", \"c\");\n        // Use stream + map + Collectors.joining to print A-B-C\n\n    }\n}",
      "fullSolution": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> xs = Arrays.asList(\"a\", \"b\", \"c\");\n        String out = xs.stream().map(String::toUpperCase).collect(Collectors.joining(\"-\"));\n        System.out.println(out);\n    }\n}",
      "expectedOutput": "A-B-C",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Streams can transform and aggregate collections succinctly. <code>map</code> applies a transformation per element; <code>Collectors.joining</code> concatenates with a delimiter.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Uppercase then join with hyphens\njava.util.List<String> xs = java.util.Arrays.asList(\"x\", \"y\", \"z\");\nString s = xs.stream().map(String::toUpperCase).collect(java.util.stream.Collectors.joining(\"-\"));\nSystem.out.println(s);</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding stream join + map is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying stream join + map, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply stream join + map will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with stream join + map, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Strings",
        "Collections",
        "OOP",
        "Functional"
      ]
    },
    {
      "id": 176,
      "title": "176. Arrays.sort with Comparator",
      "language": "java",
      "description": "Sort integers in descending order using Comparator.reverseOrder.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Integer[] xs = {3, 1, 2};\n        // Sort xs in descending order and print each on its own line (3, then 2, then 1)\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Integer[] xs = {3, 1, 2};\n        Arrays.sort(xs, Comparator.reverseOrder());\n        for (int v : xs) System.out.println(v);\n    }\n}",
      "expectedOutput": "3\n2\n1",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>Arrays.sort</code> accepts a <code>Comparator</code> for custom ordering. With boxed <code>Integer</code>, use <code>Comparator.reverseOrder()</code> for descending.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Integer[] a = {5,1,4};\njava.util.Arrays.sort(a, java.util.Comparator.reverseOrder());</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding arrays.sort with comparator is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying arrays.sort with comparator, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply arrays.sort with comparator will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with arrays.sort with comparator, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 177,
      "title": "177. ThreadLocal + Executor",
      "language": "java",
      "description": "Use ThreadLocal in two tasks and print the sum of their values (3).",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Create a ThreadLocal<Integer>, submit two tasks that set it to 1 and 2\n        // Return their values and print the sum (3)\n\n    }\n}",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        ThreadLocal<Integer> tl = new ThreadLocal<>();\n        Callable<Integer> c1 = () -> { tl.set(1); return tl.get(); };\n        Callable<Integer> c2 = () -> { tl.set(2); return tl.get(); };\n        ExecutorService ex = Executors.newFixedThreadPool(2);\n        try {\n            Future<Integer> f1 = ex.submit(c1);\n            Future<Integer> f2 = ex.submit(c2);\n            System.out.println(f1.get() + f2.get());\n        } finally {\n            ex.shutdown();\n        }\n    }\n}",
      "expectedOutput": "3",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>ThreadLocal</code> provides per-thread storage; each thread sees its own value even when sharing the same variable reference.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">ThreadLocal<Integer> tl = new ThreadLocal<>(); tl.set(123);</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding threadlocal + executor is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying threadlocal + executor, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply threadlocal + executor will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with threadlocal + executor, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Functions",
        "Collections",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 178,
      "title": "178. ReentrantLock",
      "language": "java",
      "description": "Protect a shared counter with ReentrantLock across two threads and print 2000.",
      "initialCode": "import java.util.concurrent.locks.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Start two threads that each increment a shared counter 1000 times\n        // Guard increments with a ReentrantLock and print the final count (2000)\n\n    }\n}",
      "fullSolution": "import java.util.concurrent.locks.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Lock lock = new ReentrantLock();\n        final int[] counter = {0};\n        Runnable inc = () -> {\n            for (int i = 0; i < 1000; i++) {\n                lock.lock();\n                try { counter[0]++; } finally { lock.unlock(); }\n            }\n        };\n        Thread t1 = new Thread(inc), t2 = new Thread(inc);\n        t1.start(); t2.start();\n        t1.join(); t2.join();\n        System.out.println(counter[0]);\n    }\n}",
      "expectedOutput": "2000",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>ReentrantLock</code> offers explicit locking with try/finally for predictable release; it supports advanced features beyond <code>synchronized</code>.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.concurrent.locks.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Lock lock = new ReentrantLock();\n        final int[] counter = {0};\n        Runnable inc = () -&gt; {\n            for (int i = 0; i &lt; 1000; i++) {\n                lock.lock();\n                try { counter[0]++; } finally { lock.unlock(); }\n            }\n        };</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding reentrantlock is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying reentrantlock, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply reentrantlock will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with reentrantlock, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Strings",
        "OOP",
        "Concurrency"
      ]
    },
    {
      "id": 179,
      "title": "179. EnumSet",
      "language": "java",
      "description": "Use EnumSet to hold permissions and test membership.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    enum Perm { READ, WRITE, EXEC }\n    public static void main(String[] args) {\n        // Create EnumSet.of(READ, WRITE) and print whether it contains READ (true)\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    enum Perm { READ, WRITE, EXEC }\n    public static void main(String[] args) {\n        EnumSet<Perm> s = EnumSet.of(Perm.READ, Perm.WRITE);\n        System.out.println(s.contains(Perm.READ));\n    }\n}",
      "expectedOutput": "true",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>EnumSet</code> is a high-performance set for enum keys, implemented as bit flags under the hood.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\n\npublic class Main {\n    enum Perm { READ, WRITE, EXEC }\n    public static void main(String[] args) {\n        EnumSet&lt;Perm&gt; s = EnumSet.of(Perm.READ, Perm.WRITE);\n        System.out.println(s.contains(Perm.READ));\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding enumset is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying enumset, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply enumset will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with enumset, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Collections",
        "OOP",
        "CLI"
      ]
    },
    {
      "id": 180,
      "title": "180. Sealed interface + instanceof pattern",
      "language": "java",
      "description": "Define a sealed Shape, implement Rect and compute its area with pattern matching.",
      "initialCode": "public class Main {\n    sealed interface Shape permits Rect, Circle {}\n    static final class Rect implements Shape { int w,h; Rect(int w,int h){ this.w=w; this.h=h; } }\n    static final class Circle implements Shape { int r; Circle(int r){ this.r=r; } }\n    public static void main(String[] args) {\n        // Create a Rect(3,4) as Shape and print its area (12) using instanceof pattern binding\n\n    }\n}",
      "fullSolution": "public class Main {\n    sealed interface Shape permits Rect, Circle {}\n    static final class Rect implements Shape { int w,h; Rect(int w,int h){ this.w=w; this.h=h; } }\n    static final class Circle implements Shape { int r; Circle(int r){ this.r=r; } }\n    public static void main(String[] args) {\n        Shape s = new Rect(3,4);\n        if (s instanceof Rect r) {\n            System.out.println(r.w * r.h);\n        }\n    }\n}",
      "expectedOutput": "12",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Java 17 sealed types constrain inheritance; pattern matching for <code>instanceof</code> introduces a bound variable with the target type.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">public class Main {\n    sealed interface Shape permits Rect, Circle {}\n    static final class Rect implements Shape { int w,h; Rect(int w,int h){ this.w=w; this.h=h; } }\n    static final class Circle implements Shape { int r; Circle(int r){ this.r=r; } }\n    public static void main(String[] args) {\n        Shape s = new Rect(3,4);\n        if (s instanceof Rect r) {\n            System.out.println(r.w * r.h);\n        }\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding sealed interface + instanceof pattern is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying sealed interface + instanceof pattern, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply sealed interface + instanceof pattern will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with sealed interface + instanceof pattern, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "OOP",
        "Type System"
      ]
    },
    {
      "id": 181,
      "title": "181. Files.walk (count)",
      "language": "java",
      "description": "Create a dir with .txt files, walk it, and print the count of .txt files.",
      "initialCode": "import java.nio.file.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Create d/, write a.txt, b.txt, c.log; use Files.walk to count *.txt and print 2\n\n    }\n}",
      "fullSolution": "import java.nio.file.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Path dir = Paths.get(\"d\");\n        Files.createDirectories(dir);\n        Files.write(dir.resolve(\"a.txt\"), \"x\".getBytes());\n        Files.write(dir.resolve(\"b.txt\"), \"y\".getBytes());\n        Files.write(dir.resolve(\"c.log\"), \"z\".getBytes());\n        long c = Files.walk(dir).filter(p -> p.toString().endsWith(\".txt\")).count();\n        System.out.println(c);\n    }\n}",
      "expectedOutput": "2",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>Files.walk</code> traverses a file tree lazily; filter by extension or attributes to compute aggregates.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.nio.file.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Path dir = Paths.get(\"d\");\n        Files.createDirectories(dir);\n        Files.write(dir.resolve(\"a.txt\"), \"x\".getBytes());\n        Files.write(dir.resolve(\"b.txt\"), \"y\".getBytes());\n        Files.write(dir.resolve(\"c.log\"), \"z\".getBytes());\n        long c = Files.walk(dir).filter(p -&gt; p.toString().endsWith(\".txt\")).count();\n        System.out.println(c);</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding files.walk (count) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying files.walk (count), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply files.walk (count) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with files.walk (count), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Strings",
        "OOP",
        "Algorithms",
        "I/O"
      ]
    },
    {
      "id": 182,
      "title": "182. Annotation + reflection",
      "language": "java",
      "description": "Declare an annotation, annotate a class, and read its value via reflection.",
      "initialCode": "import java.lang.annotation.*;\n\n// Define @Info(String value) with RUNTIME retention\n// Annotate class S with @Info(\"hello\")\n// In main, reflect Info.value() and print it\n\n",
      "fullSolution": "import java.lang.annotation.*;\n\n@Retention(RetentionPolicy.RUNTIME)\n@interface Info { String value(); }\n\n@Info(\"hello\")\nclass S {}\n\npublic class Main {\n    public static void main(String[] args) {\n        Info a = S.class.getAnnotation(Info.class);\n        System.out.println(a.value());\n    }\n}\n",
      "expectedOutput": "hello",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Runtime-retained annotations can be discovered via reflection on classes, methods, and fields.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.lang.annotation.*;\n\n@Retention(RetentionPolicy.RUNTIME)\n@interface Info { String value(); }\n\n@Info(\"hello\")\nclass S {}\n\npublic class Main {\n    public static void main(String[] args) {\n        Info a = S.class.getAnnotation(Info.class);\n        System.out.println(a.value());</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding annotation + reflection is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying annotation + reflection, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply annotation + reflection will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with annotation + reflection, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "OOP",
        "Metaprogramming"
      ]
    },
    {
      "id": 183,
      "title": "183. Collectors.flatMapping",
      "language": "java",
      "description": "Flatten during collection and sum integers parsed from strings.",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // rows = [\"1,2\", \"3\"]\n        // Use Collectors.flatMapping to split, parse, and sum -> print 6\n\n    }\n}",
      "fullSolution": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> rows = Arrays.asList(\"1,2\", \"3\");\n        int sum = rows.stream().collect(\n            Collectors.flatMapping(\n                s -> Arrays.stream(s.split(\",\")).map(Integer::parseInt),\n                Collectors.summingInt(Integer::intValue)\n            )\n        );\n        System.out.println(sum);\n    }\n}",
      "expectedOutput": "6",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>flatMapping</code> allows flattening as part of a downstream collector without an explicit pre-<code>flatMap</code>.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List&lt;String&gt; rows = Arrays.asList(\"1,2\", \"3\");\n        int sum = rows.stream().collect(\n            Collectors.flatMapping(\n                s -&gt; Arrays.stream(s.split(\",\")).map(Integer::parseInt),\n                Collectors.summingInt(Integer::intValue)\n            )\n        );</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding collectors.flatmapping is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying collectors.flatmapping, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply collectors.flatmapping will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with collectors.flatmapping, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Strings",
        "Collections",
        "OOP",
        "Functional"
      ]
    },
    {
      "id": 184,
      "title": "184. CompletableFuture.allOf",
      "language": "java",
      "description": "Combine two async computations and print their summed result.",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // supplyAsync 1 and 2; allOf thenApply to sum and print 3\n\n    }\n}",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        CompletableFuture<Integer> a = CompletableFuture.supplyAsync(() -> 1);\n        CompletableFuture<Integer> b = CompletableFuture.supplyAsync(() -> 2);\n        int sum = CompletableFuture.allOf(a, b).thenApply(v -> a.join() + b.join()).join();\n        System.out.println(sum);\n    }\n}",
      "expectedOutput": "3",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>allOf</code> waits for multiple futures; use a continuation to compose their results.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        CompletableFuture&lt;Integer&gt; a = CompletableFuture.supplyAsync(() -&gt; 1);\n        CompletableFuture&lt;Integer&gt; b = CompletableFuture.supplyAsync(() -&gt; 2);\n        int sum = CompletableFuture.allOf(a, b).thenApply(v -&gt; a.join() + b.join()).join();\n        System.out.println(sum);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding completablefuture.allof is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying completablefuture.allof, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply completablefuture.allof will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with completablefuture.allof, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Strings",
        "OOP",
        "Concurrency"
      ]
    },
    {
      "id": 185,
      "title": "185. AutoCloseable (custom resource)",
      "language": "java",
      "description": "Implement AutoCloseable and demonstrate try-with-resources ordering.",
      "initialCode": "public class Main {\n    static class R implements AutoCloseable {\n        R() { /* print open */ }\n        void work() { /* print work */ }\n        public void close() { /* print close */ }\n    }\n    public static void main(String[] args) {\n        // Use try-with-resources to print lines: open, work, close\n\n    }\n}",
      "fullSolution": "public class Main {\n    static class R implements AutoCloseable {\n        R() { System.out.println(\"open\"); }\n        void work() { System.out.println(\"work\"); }\n        public void close() { System.out.println(\"close\"); }\n    }\n    public static void main(String[] args) {\n        try (R r = new R()) {\n            r.work();\n        }\n    }\n}",
      "expectedOutput": "open\nwork\nclose",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Types implementing <code>AutoCloseable</code> can be managed by try-with-resources, ensuring deterministic cleanup even on exceptions.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">public class Main {\n    static class R implements AutoCloseable {\n        R() { System.out.println(\"open\"); }\n        void work() { System.out.println(\"work\"); }\n        public void close() { System.out.println(\"close\"); }\n    }\n    public static void main(String[] args) {\n        try (R r = new R()) {\n            r.work();\n        }\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding autocloseable (custom resource) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying autocloseable (custom resource), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply autocloseable (custom resource) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with autocloseable (custom resource), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "OOP"
      ]
    },
    {
      "id": 186,
      "title": "186. PriorityQueue (min-heap)",
      "language": "java",
      "description": "Use PriorityQueue to poll integers in ascending order.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Add 3,1,2 to a PriorityQueue and poll, printing each on its own line (1,2,3)\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        pq.add(3); pq.add(1); pq.add(2);\n        while (!pq.isEmpty()) System.out.println(pq.poll());\n    }\n}",
      "expectedOutput": "1\n2\n3",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>PriorityQueue</code> is a min-heap by default; the smallest element is returned first when polling.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();\n        pq.add(3); pq.add(1); pq.add(2);\n        while (!pq.isEmpty()) System.out.println(pq.poll());\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding priorityqueue (min-heap) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying priorityqueue (min-heap), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply priorityqueue (min-heap) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with priorityqueue (min-heap), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 187,
      "title": "187. BitSet",
      "language": "java",
      "description": "Set a couple of bits and print the cardinality (number of set bits).",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Set bits 1 and 3 in a BitSet and print its cardinality (2)\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        BitSet bs = new BitSet();\n        bs.set(1); bs.set(3);\n        System.out.println(bs.cardinality());\n    }\n}",
      "expectedOutput": "2",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>BitSet</code> stores compact bit flags and supports fast set operations and counting via <code>cardinality()</code>.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        BitSet bs = new BitSet();\n        bs.set(1); bs.set(3);\n        System.out.println(bs.cardinality());\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding bitset is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying bitset, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply bitset will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with bitset, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Collections",
        "OOP",
        "CLI"
      ]
    },
    {
      "id": 188,
      "title": "188. Regex named group",
      "language": "java",
      "description": "Use a named capturing group to extract a word and print it.",
      "initialCode": "import java.util.regex.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Match (?<w>\\\\w+)-(\\\\d+) against \"abc-123\" and print group 'w' (abc)\n\n    }\n}",
      "fullSolution": "import java.util.regex.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Matcher m = Pattern.compile(\"(?<w>\\\\w+)-(\\\\d+)\").matcher(\"abc-123\");\n        if (m.find()) System.out.println(m.group(\"w\"));\n    }\n}",
      "expectedOutput": "abc",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Named groups (<code>(?&lt;name&gt;...)</code>) improve readability in complex patterns; access by name via <code>group(\"name\")</code>.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.regex.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Matcher m = Pattern.compile(\"(?&lt;w&gt;\\\\w+)-(\\\\d+)\").matcher(\"abc-123\");\n        if (m.find()) System.out.println(m.group(\"w\"));\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding regex named group is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying regex named group, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply regex named group will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with regex named group, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Strings",
        "OOP",
        "Regex"
      ]
    },
    {
      "id": 189,
      "title": "189. Capstone: Files.walk + lines + sum",
      "language": "java",
      "description": "Create a directory with .txt files, stream their lines, parse ints, and print the sum.",
      "initialCode": "import java.nio.file.*;\nimport java.io.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Create d/ with a.txt (1\\n2), b.txt (3), and c.log (x)\n        // Walk d/, filter *.txt, stream lines, parse ints, sum, print 6\n\n    }\n}",
      "fullSolution": "import java.nio.file.*;\nimport java.io.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Path dir = Paths.get(\"d\");\n        Files.createDirectories(dir);\n        Files.writeString(dir.resolve(\"a.txt\"), \"1\\n2\\n\");\n        Files.writeString(dir.resolve(\"b.txt\"), \"3\\n\");\n        Files.writeString(dir.resolve(\"c.log\"), \"x\\n\");\n        long sum = Files.walk(dir)\n            .filter(p -> p.toString().endsWith(\".txt\"))\n            .flatMap(p -> { try { return Files.lines(p); } catch (IOException e) { return Stream.empty(); } })\n            .map(String::trim)\n            .filter(s -> !s.isEmpty())\n            .mapToLong(Long::parseLong)\n            .sum();\n        System.out.println(sum);\n    }\n}",
      "expectedOutput": "6",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Capstone combining <code>Files.walk</code> with <code>Files.lines</code> and stream operations to process multiple files declaratively.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">java.nio.file.Files.walk(java.nio.file.Paths.get(\"d\"))\n  .filter(p -> p.toString().endsWith(\".txt\"))\n  .forEach(System.out::println);</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding capstone: files.walk + lines + sum is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying capstone: files.walk + lines + sum, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply capstone: files.walk + lines + sum will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with capstone: files.walk + lines + sum, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Strings",
        "OOP",
        "I/O",
        "Functional"
      ]
    },
    {
      "title": "190. Files.readString + writeString",
      "language": "java",
      "description": "Write \"Hello\" to a file with Files.writeString, then read it back and print it.",
      "initialCode": "import java.nio.file.*;\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Path p = Path.of(\"msg.txt\");\n        // Write \"Hello\" to p, read it back, then print the text\n    }\n}\n",
      "fullSolution": "import java.nio.file.*;\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Path p = Path.of(\"msg.txt\");\n        Files.writeString(p, \"Hello\");\n        String s = Files.readString(p);\n        System.out.println(s);\n    }\n}\n",
      "expectedOutput": "Hello",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Since Java 11, Files.writeString/readString make small text file I/O concise. Use Path.of to build a path relative to the working directory.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Path p = Path.of(\"sample.txt\");\nFiles.writeString(p, \"Hi\");\nSystem.out.println(Files.readString(p)); // Hi</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding files.readstring + writestring is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying files.readstring + writestring, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply files.readstring + writestring will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with files.readstring + writestring, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 190,
      "tags": [
        "Intermediate",
        "OOP",
        "I/O"
      ]
    },
    {
      "id": 191,
      "title": "191. Capstone: Grouping log entries by severity",
      "language": "java",
      "description": "Parse log lines with format \"LEVEL: message\", group by level using Collectors.groupingBy, and print counts.",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> logs = Arrays.asList(\n            \"ERROR: failed to connect\",\n            \"INFO: starting service\",\n            \"ERROR: timeout\",\n            \"WARN: deprecated API\",\n            \"INFO: request processed\"\n        );\n        \n        // TODO: group by level (word before ':'), count each group, print \"ERROR=2,INFO=2,WARN=1\"\n    }\n}\n",
      "fullSolution": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> logs = Arrays.asList(\n            \"ERROR: failed to connect\",\n            \"INFO: starting service\",\n            \"ERROR: timeout\",\n            \"WARN: deprecated API\",\n            \"INFO: request processed\"\n        );\n        \n        Map<String, Long> counts = logs.stream()\n            .map(line -> line.split(\":\")[0])\n            .collect(Collectors.groupingBy(level -> level, Collectors.counting()));\n        \n        String result = counts.entrySet().stream()\n            .sorted(Map.Entry.comparingByKey())\n            .map(e -> e.getKey() + \"=\" + e.getValue())\n            .collect(Collectors.joining(\",\"));\n        \n        System.out.println(result);\n    }\n}\n",
      "expectedOutput": "ERROR=2,INFO=2,WARN=1",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Capstone combining streams, <code>groupingBy</code>, and <code>counting</code> to analyze log data. This pattern is essential for data aggregation and reporting.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Map<String, Long> counts = items.stream()\n    .collect(Collectors.groupingBy(\n        classifier,\n        Collectors.counting()\n    ));</pre></div><p class=\"mt-4 text-gray-300\">Use <code>groupingBy</code> with downstream collectors like <code>counting</code>, <code>summingInt</code>, or <code>mapping</code> for powerful aggregations.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding capstone: grouping log entries by severity is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying capstone: grouping log entries by severity, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply capstone: grouping log entries by severity will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with capstone: grouping log entries by severity, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Streams",
        "Collections",
        "Strings",
        "Functional"
      ]
    },
    {
      "id": 192,
      "title": "192. ExecutorService invokeAll (sum squares)",
      "language": "java",
      "description": "Use a fixed thread pool to compute squares of 1..3 in parallel and print their sum (14).",
      "initialCode": "import java.util.*;\nimport java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Submit callables squaring 1..3 via invokeAll and print the sum (14)\n\n    }\n}",
      "fullSolution": "import java.util.*;\nimport java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        ExecutorService es = Executors.newFixedThreadPool(3);\n        try {\n            List<Callable<Integer>> tasks = Arrays.asList(\n                () -> 1*1, () -> 2*2, () -> 3*3\n            );\n            int sum = 0;\n            for (Future<Integer> f : es.invokeAll(tasks)) { sum += f.get(); }\n            System.out.println(sum);\n        } finally { es.shutdown(); }\n    }\n}",
      "expectedOutput": "14",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use <code>ExecutorService.invokeAll</code> to submit a batch of tasks and wait for their results, then reduce them.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\nimport java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        ExecutorService es = Executors.newFixedThreadPool(3);\n        try {\n            List&lt;Callable&lt;Integer&gt;&gt; tasks = Arrays.asList(\n                () -&gt; 1*1, () -&gt; 2*2, () -&gt; 3*3\n            );\n            int sum = 0;\n            for (Future&lt;Integer&gt; f : es.invokeAll(tasks)) { sum += f.get(); }</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding executorservice invokeall (sum squares) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying executorservice invokeall (sum squares), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply executorservice invokeall (sum squares) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with executorservice invokeall (sum squares), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Functions",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 193,
      "title": "193. Files.walk (count .txt)",
      "language": "java",
      "description": "Create three files (a.txt, b.md, c.txt) and print how many end with .txt (2).",
      "initialCode": "import java.nio.file.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Create a.txt, b.md, c.txt in dir d/; walk and count .txt (2)\n\n    }\n}",
      "fullSolution": "import java.nio.file.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Path d = Paths.get(\"d\");\n        Files.createDirectories(d);\n        Files.writeString(d.resolve(\"a.txt\"), \"x\");\n        Files.writeString(d.resolve(\"b.md\"), \"y\");\n        Files.writeString(d.resolve(\"c.txt\"), \"z\");\n        long c = Files.walk(d).filter(p -> p.toString().endsWith(\".txt\")).count();\n        System.out.println(c);\n    }\n}",
      "expectedOutput": "2",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>Files.walk</code> traverses a directory tree; combine with filters to compute counts.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.nio.file.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Path d = Paths.get(\"d\");\n        Files.createDirectories(d);\n        Files.writeString(d.resolve(\"a.txt\"), \"x\");\n        Files.writeString(d.resolve(\"b.md\"), \"y\");\n        Files.writeString(d.resolve(\"c.txt\"), \"z\");\n        long c = Files.walk(d).filter(p -&gt; p.toString().endsWith(\".txt\")).count();\n        System.out.println(c);</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding files.walk (count .txt) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying files.walk (count .txt), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply files.walk (count .txt) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with files.walk (count .txt), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Strings",
        "OOP",
        "Algorithms",
        "I/O"
      ]
    },
    {
      "id": 194,
      "title": "194. Optional map/filter chain",
      "language": "java",
      "description": "Trim and uppercase an Optional string and print its length (5).",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Optional<String> s = Optional.of(\" hello \");\n        // Chain map/filter to trim+uppercase and print length (5)\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Optional<String> s = Optional.of(\" hello \");\n        int len = s.map(String::trim).map(String::toUpperCase).orElse(\"\").length();\n        System.out.println(len);\n    }\n}",
      "expectedOutput": "5",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Prefer functional transformations with <code>map</code>/<code>filter</code> on <code>Optional</code> to avoid nested <code>if</code>s.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Optional&lt;String&gt; s = Optional.of(\" hello \");\n        int len = s.map(String::trim).map(String::toUpperCase).orElse(\"\").length();\n        System.out.println(len);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding optional map/filter chain is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying optional map/filter chain, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply optional map/filter chain will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with optional map/filter chain, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Strings",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 195,
      "title": "195. Comparator.comparing (custom sort)",
      "language": "java",
      "description": "Sort Person(name,age) by age then name and print names on separate lines.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    static class Person { String name; int age; Person(String n,int a){name=n;age=a;} }\n    public static void main(String[] args) {\n        List<Person> ps = Arrays.asList(new Person(\"Zoe\", 30), new Person(\"Ada\", 30), new Person(\"Bob\", 25));\n        // Sort by age then name; print names each on a new line: Bob, Ada, Zoe\n\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    static class Person { String name; int age; Person(String n,int a){name=n;age=a;} }\n    public static void main(String[] args) {\n        List<Person> ps = Arrays.asList(new Person(\"Zoe\", 30), new Person(\"Ada\", 30), new Person(\"Bob\", 25));\n        ps.sort(Comparator.comparing((Person p) -> p.age).thenComparing(p -> p.name));\n        for (Person p : ps) System.out.println(p.name);\n    }\n}",
      "expectedOutput": "Bob\nAda\nZoe",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>Comparator.comparing</code> composes readable multi-key sorts; combine with <code>thenComparing</code>.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\n\npublic class Main {\n    static class Person { String name; int age; Person(String n,int a){name=n;age=a;} }\n    public static void main(String[] args) {\n        List&lt;Person&gt; ps = Arrays.asList(new Person(\"Zoe\", 30), new Person(\"Ada\", 30), new Person(\"Bob\", 25));\n        ps.sort(Comparator.comparing((Person p) -&gt; p.age).thenComparing(p -&gt; p.name));\n        for (Person p : ps) System.out.println(p.name);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding comparator.comparing (custom sort) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying comparator.comparing (custom sort), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply comparator.comparing (custom sort) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with comparator.comparing (custom sort), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Collections",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 196,
      "title": "196. Streams: sum of squares (even)",
      "language": "java",
      "description": "Sum the squares of even numbers from 1..6 and print the result (56).",
      "initialCode": "import java.util.stream.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    // Use IntStream to compute 2^2 + 4^2 + 6^2 and print 56\n\n  }\n}",
      "fullSolution": "import java.util.stream.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    int sum = IntStream.rangeClosed(1, 6)\n      .filter(x -> x % 2 == 0)\n      .map(x -> x * x)\n      .sum();\n    System.out.println(sum);\n  }\n}",
      "expectedOutput": "56",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Filter even values, map to squares, then sum using <code>IntStream</code>.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">int s = java.util.stream.IntStream.of(2,4,6).map(x->x*x).sum();</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding streams: sum of squares (even) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying streams: sum of squares (even), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply streams: sum of squares (even) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with streams: sum of squares (even), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Collections",
        "OOP",
        "Functional",
        "Streams"
      ]
    },
    {
      "id": 197,
      "title": "197. Files.readAllLines (count)",
      "language": "java",
      "description": "Write three lines to a file and print the line count (3).",
      "initialCode": "import java.nio.file.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) throws Exception {\n    // Write a\\n b\\n c to d/t.txt then read all lines and print 3\n\n  }\n}",
      "fullSolution": "import java.nio.file.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) throws Exception {\n    Path d = Paths.get(\"d\");\n    Files.createDirectories(d);\n    Path p = d.resolve(\"t.txt\");\n    Files.write(p, Arrays.asList(\"a\", \"b\", \"c\"));\n    System.out.println(Files.readAllLines(p).size());\n  }\n}",
      "expectedOutput": "3",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use <code>Files.readAllLines</code> for small files when you need the entire content as a list.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.nio.file.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) throws Exception {\n    Path d = Paths.get(\"d\");\n    Files.createDirectories(d);\n    Path p = d.resolve(\"t.txt\");\n    Files.write(p, Arrays.asList(\"a\", \"b\", \"c\"));\n    System.out.println(Files.readAllLines(p).size());\n  }</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding files.readalllines (count) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying files.readalllines (count), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply files.readalllines (count) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with files.readalllines (count), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "OOP",
        "I/O"
      ]
    },
    {
      "id": 198,
      "title": "198. Regex: extract digits",
      "language": "java",
      "description": "Remove non-digits from 'a1b22c' and print '122'.",
      "initialCode": "public class Main {\n  public static void main(String[] args) {\n    String s = \"a1b22c\";\n    // Remove non-digits and print 122\n\n  }\n}",
      "fullSolution": "public class Main {\n  public static void main(String[] args) {\n    String s = \"a1b22c\";\n    System.out.println(s.replaceAll(\"\\\\D\", \"\"));\n  }\n}",
      "expectedOutput": "122",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>\\D</code> matches non-digits; replacing them with empty string keeps only digits.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">public class Main {\n  public static void main(String[] args) {\n    String s = \"a1b22c\";\n    System.out.println(s.replaceAll(\"\\\\D\", \"\"));\n  }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding regex: extract digits is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying regex: extract digits, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply regex: extract digits will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with regex: extract digits, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Strings",
        "OOP",
        "Regex"
      ]
    },
    {
      "id": 199,
      "title": "199. LocalDate: days between",
      "language": "java",
      "description": "Compute days between 2024-01-10 and 2024-01-15 (5).",
      "initialCode": "import java.time.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    // Print the number of days between 2024-01-10 and 2024-01-15 (5)\n\n  }\n}",
      "fullSolution": "import java.time.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    LocalDate a = LocalDate.parse(\"2024-01-10\");\n    LocalDate b = LocalDate.parse(\"2024-01-15\");\n    System.out.println(java.time.temporal.ChronoUnit.DAYS.between(a, b));\n  }\n}",
      "expectedOutput": "5",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use <code>ChronoUnit.DAYS.between</code> to compute date differences.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.time.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    LocalDate a = LocalDate.parse(\"2024-01-10\");\n    LocalDate b = LocalDate.parse(\"2024-01-15\");\n    System.out.println(java.time.temporal.ChronoUnit.DAYS.between(a, b));\n  }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding localdate: days between is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying localdate: days between, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply localdate: days between will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with localdate: days between, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "OOP",
        "Date/Time",
        "Parsing"
      ]
    },
    {
      "id": 200,
      "title": "200. Optional.ifPresentOrElse",
      "language": "java",
      "description": "Use ifPresentOrElse to print 'EMPTY' for an empty Optional.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Optional<String> s = Optional.empty();\n    // Use ifPresentOrElse to print 'EMPTY'\n\n  }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Optional<String> s = Optional.empty();\n    s.ifPresentOrElse(x -> System.out.println(\"OK\"), () -> System.out.println(\"EMPTY\"));\n  }\n}",
      "expectedOutput": "EMPTY",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>ifPresentOrElse</code> eliminates branching boilerplate for presence/absence.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Optional&lt;String&gt; s = Optional.empty();\n    s.ifPresentOrElse(x -&gt; System.out.println(\"OK\"), () -&gt; System.out.println(\"EMPTY\"));\n  }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding optional.ifpresentorelse is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying optional.ifpresentorelse, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply optional.ifpresentorelse will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with optional.ifpresentorelse, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "OOP"
      ]
    },
    {
      "id": 201,
      "title": "201. record basics",
      "language": "java",
      "description": "Define a record Point(x,y), create (3,4), and print x+y (7).",
      "initialCode": "public class Main {\n  record Point(int x, int y) {}\n  public static void main(String[] args) {\n    // Print x+y for Point(3,4) -> 7\n\n  }\n}",
      "fullSolution": "public class Main {\n  record Point(int x, int y) {}\n  public static void main(String[] args) {\n    Point p = new Point(3,4);\n    System.out.println(p.x()+p.y());\n  }\n}",
      "expectedOutput": "7",
      "tutorial": "<p class=\"mb-4 text-gray-300\">A <code>record</code> declares an immutable data carrier with generated accessors.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">public class Main {\n  record Point(int x, int y) {}\n  public static void main(String[] args) {\n    Point p = new Point(3,4);\n    System.out.println(p.x()+p.y());\n  }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding record basics is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying record basics, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply record basics will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with record basics, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "OOP",
        "Type System"
      ]
    },
    {
      "id": 202,
      "title": "202. Collectors.joining",
      "language": "java",
      "description": "Join [a,b,c] with commas and print 'a,b,c'.",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    // Use Collectors.joining to print a,b,c\n\n  }\n}",
      "fullSolution": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    System.out.println(Arrays.asList(\"a\",\"b\",\"c\").stream().collect(Collectors.joining(\",\")));\n  }\n}",
      "expectedOutput": "a,b,c",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>Collectors.joining</code> concatenates strings with a delimiter.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    System.out.println(Arrays.asList(\"a\",\"b\",\"c\").stream().collect(Collectors.joining(\",\")));\n  }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding collectors.joining is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying collectors.joining, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply collectors.joining will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with collectors.joining, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Strings",
        "OOP",
        "Functional",
        "Streams"
      ]
    },
    {
      "id": 203,
      "title": "203. Map.computeIfPresent (remove when zero)",
      "language": "java",
      "description": "Decrement a counter to zero and remove it; print map size (0).",
      "initialCode": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Map<String,Integer> m = new HashMap<>();\n    m.put(\"a\", 2);\n    // Decrement to zero via computeIfPresent, remove if equals 0; print size (0)\n\n  }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Map<String,Integer> m = new HashMap<>();\n    m.put(\"a\", 2);\n    m.computeIfPresent(\"a\", (k,v) -> v - 2);\n    m.remove(\"a\", 0);\n    System.out.println(m.size());\n  }\n}",
      "expectedOutput": "0",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use <code>computeIfPresent</code> for atomic updates; remove entries when counters hit zero.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Map&lt;String,Integer&gt; m = new HashMap&lt;&gt;();\n    m.put(\"a\", 2);\n    m.computeIfPresent(\"a\", (k,v) -&gt; v - 2);\n    m.remove(\"a\", 0);\n    System.out.println(m.size());\n  }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding map.computeifpresent (remove when zero) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying map.computeifpresent (remove when zero), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply map.computeifpresent (remove when zero) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with map.computeifpresent (remove when zero), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Collections",
        "OOP",
        "Concurrency"
      ]
    },
    {
      "id": 204,
      "title": "204. Case-insensitive reverse sort",
      "language": "java",
      "description": "Sort [b,A,c] case-insensitively in descending order and print each on its own line.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    List<String> xs = Arrays.asList(\"b\",\"A\",\"c\");\n    // Sort case-insensitively descending and print: c, b, A (each on new line)\n\n  }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    List<String> xs = Arrays.asList(\"b\",\"A\",\"c\");\n    xs.sort(String.CASE_INSENSITIVE_ORDER.reversed());\n    for (String s : xs) System.out.println(s);\n  }\n}",
      "expectedOutput": "c\nb\nA",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use <code>String.CASE_INSENSITIVE_ORDER.reversed()</code> for case-insensitive descending order.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    List&lt;String&gt; xs = Arrays.asList(\"b\",\"A\",\"c\");\n    xs.sort(String.CASE_INSENSITIVE_ORDER.reversed());\n    for (String s : xs) System.out.println(s);\n  }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding case-insensitive reverse sort is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying case-insensitive reverse sort, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply case-insensitive reverse sort will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with case-insensitive reverse sort, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Collections",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 205,
      "title": "205. ArrayDeque as stack",
      "language": "java",
      "description": "Push 1,2,3 then pop and print each (3,2,1).",
      "initialCode": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Deque<Integer> dq = new ArrayDeque<>();\n    // Push 1,2,3 then pop and print each on its own line: 3,2,1\n\n  }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Deque<Integer> dq = new ArrayDeque<>();\n    dq.push(1); dq.push(2); dq.push(3);\n    while (!dq.isEmpty()) System.out.println(dq.pop());\n  }\n}",
      "expectedOutput": "3\n2\n1",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>ArrayDeque</code> efficiently implements a stack with <code>push</code>/<code>pop</code>.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Deque&lt;Integer&gt; dq = new ArrayDeque&lt;&gt;();\n    dq.push(1); dq.push(2); dq.push(3);\n    while (!dq.isEmpty()) System.out.println(dq.pop());\n  }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding arraydeque as stack is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying arraydeque as stack, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply arraydeque as stack will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with arraydeque as stack, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 206,
      "title": "206. BigDecimal rounding",
      "language": "java",
      "description": "Round 1.005 to 2 decimals (HALF_UP) and print 1.01.",
      "initialCode": "import java.math.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    // Print BigDecimal(\"1.005\").setScale(2, RoundingMode.HALF_UP) -> 1.01\n\n  }\n}",
      "fullSolution": "import java.math.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    System.out.println(new BigDecimal(\"1.005\").setScale(2, RoundingMode.HALF_UP));\n  }\n}",
      "expectedOutput": "1.01",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Prefer <code>BigDecimal</code> for currency/precise decimals; specify rounding mode.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.math.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    System.out.println(new BigDecimal(\"1.005\").setScale(2, RoundingMode.HALF_UP));\n  }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding bigdecimal rounding is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying bigdecimal rounding, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply bigdecimal rounding will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with bigdecimal rounding, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "OOP"
      ]
    },
    {
      "id": 207,
      "title": "207. Files.list (count directories)",
      "language": "java",
      "description": "Create d/a and d/b directories (and a file), then print directory count (2).",
      "initialCode": "import java.nio.file.*;\nimport java.io.*;\n\npublic class Main {\n  public static void main(String[] args) throws Exception {\n    // Create d/a, d/b, and d/x.txt; list only directories and print 2\n\n  }\n}",
      "fullSolution": "import java.nio.file.*;\nimport java.io.*;\n\npublic class Main {\n  public static void main(String[] args) throws Exception {\n    Path d = Paths.get(\"d\");\n    Files.createDirectories(d.resolve(\"a\"));\n    Files.createDirectories(d.resolve(\"b\"));\n    Files.writeString(d.resolve(\"x.txt\"), \"x\");\n    long count = Files.list(d).filter(Files::isDirectory).count();\n    System.out.println(count);\n  }\n}",
      "expectedOutput": "2",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use <code>Files.list</code> with <code>Files::isDirectory</code> to count subdirectories.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.nio.file.*;\nimport java.io.*;\n\npublic class Main {\n  public static void main(String[] args) throws Exception {\n    Path d = Paths.get(\"d\");\n    Files.createDirectories(d.resolve(\"a\"));\n    Files.createDirectories(d.resolve(\"b\"));\n    Files.writeString(d.resolve(\"x.txt\"), \"x\");\n    long count = Files.list(d).filter(Files::isDirectory).count();\n    System.out.println(count);\n  }</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding files.list (count directories) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying files.list (count directories), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply files.list (count directories) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with files.list (count directories), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Collections",
        "OOP",
        "I/O",
        "Functional"
      ]
    },
    {
      "id": 208,
      "title": "208. groupingBy counting",
      "language": "java",
      "description": "Count by first character and print count for key 'a' (2).",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    List<String> xs = Arrays.asList(\"ax\",\"ay\",\"bz\");\n    // Group by first char and count; print count for 'a' (2)\n\n  }\n}",
      "fullSolution": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    List<String> xs = Arrays.asList(\"ax\",\"ay\",\"bz\");\n    Map<Character,Long> m = xs.stream().collect(Collectors.groupingBy(s -> s.charAt(0), Collectors.counting()));\n    System.out.println(m.get('a'));\n  }\n}",
      "expectedOutput": "2",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Combine <code>groupingBy</code> with <code>counting</code> to build frequency maps.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    List&lt;String&gt; xs = Arrays.asList(\"ax\",\"ay\",\"bz\");\n    Map&lt;Character,Long&gt; m = xs.stream().collect(Collectors.groupingBy(s -&gt; s.charAt(0), Collectors.counting()));\n    System.out.println(m.get('a'));\n  }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding groupingby counting is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying groupingby counting, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply groupingby counting will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with groupingby counting, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Strings",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 209,
      "title": "209. CompletableFuture.thenCombine",
      "language": "java",
      "description": "Combine two async computations (2 and 3) and print their sum (5).",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    // Compose two futures and print 5 via thenCombine\n\n  }\n}",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    CompletableFuture<Integer> a = CompletableFuture.supplyAsync(() -> 2);\n    CompletableFuture<Integer> b = CompletableFuture.supplyAsync(() -> 3);\n    System.out.println(a.thenCombine(b, Integer::sum).join());\n  }\n}",
      "expectedOutput": "5",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>thenCombine</code> merges results from two independent futures.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.concurrent.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    CompletableFuture&lt;Integer&gt; a = CompletableFuture.supplyAsync(() -&gt; 2);\n    CompletableFuture&lt;Integer&gt; b = CompletableFuture.supplyAsync(() -&gt; 3);\n    System.out.println(a.thenCombine(b, Integer::sum).join());\n  }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding completablefuture.thencombine is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying completablefuture.thencombine, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply completablefuture.thencombine will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with completablefuture.thencombine, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Strings",
        "OOP",
        "Concurrency",
        "Async"
      ]
    },
    {
      "id": 210,
      "title": "210. CompletableFuture.anyOf",
      "language": "java",
      "description": "Return the first of two futures (fast vs slow) and print 'fast'.",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n  static void sleep(long ms) { try { Thread.sleep(ms); } catch (InterruptedException e) { throw new RuntimeException(e); } }\n  public static void main(String[] args) {\n    // anyOf between a fast and a slow future; print fast\n\n  }\n}",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n  static void sleep(long ms) { try { Thread.sleep(ms); } catch (InterruptedException e) { throw new RuntimeException(e); } }\n  public static void main(String[] args) {\n    CompletableFuture<String> fast = CompletableFuture.supplyAsync(() -> { sleep(50); return \"fast\"; });\n    CompletableFuture<String> slow = CompletableFuture.supplyAsync(() -> { sleep(200); return \"slow\"; });\n    System.out.println((String) CompletableFuture.anyOf(fast, slow).join());\n  }\n}",
      "expectedOutput": "fast",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>anyOf</code> completes with the first finished future; use <code>join()</code> to get the result.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.concurrent.*;\n\npublic class Main {\n  static void sleep(long ms) { try { Thread.sleep(ms); } catch (InterruptedException e) { throw new RuntimeException(e); } }\n  public static void main(String[] args) {\n    CompletableFuture&lt;String&gt; fast = CompletableFuture.supplyAsync(() -&gt; { sleep(50); return \"fast\"; });\n    CompletableFuture&lt;String&gt; slow = CompletableFuture.supplyAsync(() -&gt; { sleep(200); return \"slow\"; });\n    System.out.println((String) CompletableFuture.anyOf(fast, slow).join());\n  }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding completablefuture.anyof is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying completablefuture.anyof, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply completablefuture.anyof will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with completablefuture.anyof, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Strings",
        "OOP",
        "Concurrency",
        "Async"
      ]
    },
    {
      "id": 211,
      "title": "211. Files.lines + filter + sum",
      "language": "java",
      "description": "Write 1,3,5 to a file, filter >2, sum and print 8.",
      "initialCode": "import java.nio.file.*;\nimport java.io.*;\nimport java.util.stream.*;\n\npublic class Main {\n  public static void main(String[] args) throws Exception {\n    // Create d/n.txt with 1\\n3\\n5; stream lines, filter >2, sum; print 8\n\n  }\n}",
      "fullSolution": "import java.nio.file.*;\nimport java.io.*;\nimport java.util.stream.*;\n\npublic class Main {\n  public static void main(String[] args) throws Exception {\n    Path d = Paths.get(\"d\");\n    Files.createDirectories(d);\n    Path p = d.resolve(\"n.txt\");\n    Files.writeString(p, \"1\\n3\\n5\\n\");\n    long s = Files.lines(p).map(String::trim).filter(x -> !x.isEmpty()).mapToLong(Long::parseLong).filter(v -> v > 2).sum();\n    System.out.println(s);\n  }\n}",
      "expectedOutput": "8",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Combine <code>Files.lines</code> with stream filters and reductions for file processing.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.nio.file.*;\nimport java.io.*;\nimport java.util.stream.*;\n\npublic class Main {\n  public static void main(String[] args) throws Exception {\n    Path d = Paths.get(\"d\");\n    Files.createDirectories(d);\n    Path p = d.resolve(\"n.txt\");\n    Files.writeString(p, \"1\\n3\\n5\\n\");\n    long s = Files.lines(p).map(String::trim).filter(x -&gt; !x.isEmpty()).mapToLong(Long::parseLong).filter(v -&gt; v &gt; 2).sum();\n    System.out.println(s);</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding files.lines + filter + sum is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying files.lines + filter + sum, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply files.lines + filter + sum will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with files.lines + filter + sum, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Strings",
        "OOP",
        "I/O"
      ]
    },
    {
      "id": 212,
      "title": "212. StringBuilder.reverse",
      "language": "java",
      "description": "Reverse 'stressed' and print 'desserts'.",
      "initialCode": "public class Main {\n  public static void main(String[] args) {\n    // Use StringBuilder to reverse \"stressed\" and print \"desserts\"\n\n  }\n}",
      "fullSolution": "public class Main {\n  public static void main(String[] args) {\n    System.out.println(new StringBuilder(\"stressed\").reverse().toString());\n  }\n}",
      "expectedOutput": "desserts",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>StringBuilder.reverse()</code> efficiently reverses characters.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">public class Main {\n  public static void main(String[] args) {\n    System.out.println(new StringBuilder(\"stressed\").reverse().toString());\n  }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding stringbuilder.reverse is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying stringbuilder.reverse, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply stringbuilder.reverse will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with stringbuilder.reverse, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Strings",
        "OOP"
      ]
    },
    {
      "id": 213,
      "title": "213. TreeMap floor/ceiling",
      "language": "java",
      "description": "Insert 10,20,30; print floorKey(25) then ceilingKey(25) on separate lines.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    // Use TreeMap to get floor/ceiling around 25 from keys 10,20,30; print 20 then 30\n\n  }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    TreeMap<Integer,String> m = new TreeMap<>();\n    m.put(10, \"a\"); m.put(20, \"b\"); m.put(30, \"c\");\n    System.out.println(m.floorKey(25));\n    System.out.println(m.ceilingKey(25));\n  }\n}",
      "expectedOutput": "20\n30",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>TreeMap</code> offers navigation methods like <code>floorKey</code>/<code>ceilingKey</code>.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    TreeMap&lt;Integer,String&gt; m = new TreeMap&lt;&gt;();\n    m.put(10, \"a\"); m.put(20, \"b\"); m.put(30, \"c\");\n    System.out.println(m.floorKey(25));\n    System.out.println(m.ceilingKey(25));\n  }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding treemap floor/ceiling is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying treemap floor/ceiling, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply treemap floor/ceiling will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with treemap floor/ceiling, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 214,
      "title": "214. EnumSet basics",
      "language": "java",
      "description": "Create EnumSet.of(RED, BLUE) and test contains(GREEN); print false.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n  enum Color { RED, GREEN, BLUE }\n  public static void main(String[] args) {\n    // Create EnumSet.of(RED, BLUE) and print contains(GREEN) -> false\n\n  }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n  enum Color { RED, GREEN, BLUE }\n  public static void main(String[] args) {\n    EnumSet<Color> s = EnumSet.of(Color.RED, Color.BLUE);\n    System.out.println(s.contains(Color.GREEN));\n  }\n}",
      "expectedOutput": "false",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>EnumSet</code> is a compact, fast set optimized for enum keys.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\n\npublic class Main {\n  enum Color { RED, GREEN, BLUE }\n  public static void main(String[] args) {\n    EnumSet&lt;Color&gt; s = EnumSet.of(Color.RED, Color.BLUE);\n    System.out.println(s.contains(Color.GREEN));\n  }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding enumset basics is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying enumset basics, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply enumset basics will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with enumset basics, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Control Flow",
        "Collections",
        "OOP",
        "Performance"
      ]
    },
    {
      "id": 215,
      "title": "215. Instant/Duration (millis)",
      "language": "java",
      "description": "Compute Duration between epoch (0) and 123ms and print 123.",
      "initialCode": "import java.time.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    // Print Duration.between(Instant.EPOCH, Instant.ofEpochMilli(123)).toMillis()\n\n  }\n}",
      "fullSolution": "import java.time.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    System.out.println(Duration.between(Instant.EPOCH, Instant.ofEpochMilli(123)).toMillis());\n  }\n}",
      "expectedOutput": "123",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Durations between <code>Instant</code>s can be converted directly to milliseconds.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.time.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    System.out.println(Duration.between(Instant.EPOCH, Instant.ofEpochMilli(123)).toMillis());\n  }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding instant/duration (millis) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying instant/duration (millis), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply instant/duration (millis) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with instant/duration (millis), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "OOP",
        "Date/Time"
      ]
    },
    {
      "title": "216. Regex Basics: Extract Number",
      "language": "java",
      "description": "Use java.util.regex to find the first number in a string.",
      "initialCode": "import java.util.regex.*;\npublic class Main {\n    public static void main(String[] args) {\n        String text = \"Order #A-1023-Z\";\n        // Print the number 1023 using regex\n    }\n}\n",
      "fullSolution": "import java.util.regex.*;\npublic class Main {\n    public static void main(String[] args) {\n        String text = \"Order #A-1023-Z\";\n        Matcher m = Pattern.compile(\"\\\\d+\").matcher(text);\n        if (m.find()) {\n            System.out.println(m.group());\n        }\n    }\n}\n",
      "expectedOutput": "1023",
      "tutorial": "<p class=\"mb-4 text-gray-300\">The Pattern/Matcher API searches text for regex patterns. Use find() to locate the next match and group() to retrieve it.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Matcher m = Pattern.compile(\"[a-zA-Z]+\\d+\").matcher(\"ID A42 B7\");\nif (m.find()) {\n    System.out.println(m.group()); // A42\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding regex basics: extract number is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying regex basics: extract number, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply regex basics: extract number will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with regex basics: extract number, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 216,
      "tags": [
        "Intermediate",
        "Control Flow",
        "Strings",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "title": "217. Generics: Upper-Bounded Wildcards",
      "language": "java",
      "description": "Implement sumOfList(List<? extends Number>) and print the sum of integers.",
      "initialCode": "import java.util.*;\npublic class Main {\n    static double sumOfList(/* TODO */) {\n        return 0.0;\n    }\n    public static void main(String[] args) {\n        List<Integer> ints = Arrays.asList(1, 2, 3);\n        System.out.println(sumOfList(ints));\n    }\n}\n",
      "fullSolution": "import java.util.*;\npublic class Main {\n    static double sumOfList(List<? extends Number> list) {\n        double s = 0.0;\n        for (Number n : list) s += n.doubleValue();\n        return s;\n    }\n    public static void main(String[] args) {\n        List<Integer> ints = Arrays.asList(1, 2, 3);\n        System.out.println(sumOfList(ints));\n    }\n}\n",
      "expectedOutput": "6.0",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use ? extends Number to accept lists of Number or its subclasses (Integer, Double, ...). Read from producers (PECS rule).</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">static double sum(List<? extends Number> xs) {\n    double s = 0;\n    for (Number n : xs) s += n.doubleValue();\n    return s;\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding generics: upper-bounded wildcards is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying generics: upper-bounded wildcards, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply generics: upper-bounded wildcards will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with generics: upper-bounded wildcards, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 217,
      "tags": [
        "Intermediate",
        "Control Flow",
        "Collections",
        "OOP",
        "Type System"
      ]
    },
    {
      "title": "218. ReentrantReadWriteLock (guarded map)",
      "language": "java",
      "description": "Use a ReentrantReadWriteLock to write 42 to a map and then read it; print 42.",
      "initialCode": "import java.util.*;\nimport java.util.concurrent.locks.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String,Integer> m = new HashMap<>();\n        ReadWriteLock rw = new ReentrantReadWriteLock();\n        // Write 42 under key \"x\" with writeLock, then read it under readLock and print it\n    }\n}\n",
      "fullSolution": "import java.util.*;\nimport java.util.concurrent.locks.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String,Integer> m = new HashMap<>();\n        ReadWriteLock rw = new ReentrantReadWriteLock();\n        rw.writeLock().lock();\n        try { m.put(\"x\", 42); } finally { rw.writeLock().unlock(); }\n        rw.readLock().lock();\n        try { System.out.println(m.get(\"x\")); } finally { rw.readLock().unlock(); }\n    }\n}\n",
      "expectedOutput": "42",
      "tutorial": "<p class=\"mb-4 text-gray-300\">A <code>ReadWriteLock</code> allows multiple readers or one writer. Use the write lock for mutations, and the read lock for reads.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">ReadWriteLock rw = new ReentrantReadWriteLock();\nrw.readLock().lock();\n// read\nrw.readLock().unlock();\n</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding reentrantreadwritelock (guarded map) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying reentrantreadwritelock (guarded map), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply reentrantreadwritelock (guarded map) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with reentrantreadwritelock (guarded map), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 218,
      "tags": [
        "Intermediate",
        "Control Flow",
        "Collections",
        "OOP",
        "I/O"
      ]
    },
    {
      "title": "219. CompletableFuture.thenCombine",
      "language": "java",
      "description": "Create two futures and combine them into a single greeting; print 'Hello Alex'.",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Combine two futures, e.g. \"Hello\" and \"Alex\", then print the result\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        CompletableFuture<String> a = CompletableFuture.supplyAsync(() -> \"Hello\");\n        CompletableFuture<String> b = CompletableFuture.supplyAsync(() -> \"Alex\");\n        String out = a.thenCombine(b, (x,y) -> x + \" \" + y).join();\n        System.out.println(out);\n    }\n}\n",
      "expectedOutput": "Hello Alex",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use <code>thenCombine</code> to merge results from two independent asynchronous stages once both complete.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">CompletableFuture<Integer> a = CompletableFuture.supplyAsync(() -> 2);\nCompletableFuture<Integer> b = CompletableFuture.supplyAsync(() -> 3);\nSystem.out.println(a.thenCombine(b, Integer::sum).join()); // 5</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding completablefuture.thencombine is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying completablefuture.thencombine, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply completablefuture.thencombine will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with completablefuture.thencombine, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 219,
      "tags": [
        "Intermediate",
        "Strings",
        "OOP",
        "Concurrency",
        "Async"
      ]
    },
    {
      "title": "220. Semaphore (permits)",
      "language": "java",
      "description": "Create a Semaphore with 2 permits, acquire both, then print OK.",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Acquire both permits from a new Semaphore(2), then print OK\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Semaphore sem = new Semaphore(2);\n        sem.acquire(2);\n        System.out.println(\"OK\");\n    }\n}\n",
      "expectedOutput": "OK",
      "tutorial": "<p class=\"mb-4 text-gray-300\">A <code>Semaphore</code> restricts concurrent access to a resource. Acquire permits before entering, release when done.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Semaphore sem = new Semaphore(1);\nsem.acquire();\ntry {\n    // critical section\n} finally {\n    sem.release();\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding semaphore (permits) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying semaphore (permits), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply semaphore (permits) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with semaphore (permits), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 220,
      "tags": [
        "Intermediate",
        "OOP",
        "Concurrency"
      ]
    },
    {
      "title": "221. ConcurrentHashMap.compute (counter)",
      "language": "java",
      "description": "Use compute to increment a counter three times, then print 3.",
      "initialCode": "import java.util.concurrent.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        ConcurrentHashMap<String,Integer> m = new ConcurrentHashMap<>();\n        // Increment key \"k\" three times using compute, then print the value\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        ConcurrentHashMap<String,Integer> m = new ConcurrentHashMap<>();\n        for (int i = 0; i < 3; i++) {\n            m.compute(\"k\", (k,v) -> v == null ? 1 : v + 1);\n        }\n        System.out.println(m.get(\"k\"));\n    }\n}\n",
      "expectedOutput": "3",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Atomic updates with <code>compute</code> avoid race conditions when incrementing shared counters.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">ConcurrentHashMap<String,Integer> m = new ConcurrentHashMap<>();\nm.compute(\"x\", (k,v) -> v == null ? 1 : v+1);\n</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding concurrenthashmap.compute (counter) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying concurrenthashmap.compute (counter), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply concurrenthashmap.compute (counter) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with concurrenthashmap.compute (counter), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 221,
      "tags": [
        "Advanced",
        "Control Flow",
        "OOP",
        "Concurrency",
        "Security"
      ]
    },
    {
      "title": "222. CompletableFuture.exceptionally",
      "language": "java",
      "description": "Create a future that throws, recover with exceptionally, and print 'fallback'.",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create a future that fails and recover with exceptionally to return \"fallback\"\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Start from a normal value to make generic inference unambiguous on older JDKs\n        CompletableFuture<String> f = CompletableFuture\n            .supplyAsync(() -> \"start\")\n            .thenApply(x -> { throw new RuntimeException(\"boom\"); });\n\n        String s = f.exceptionally(ex -> \"fallback\").join();\n        System.out.println(s);\n    }\n}\n",
      "expectedOutput": "fallback",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Handle failures in async pipelines via <code>exceptionally</code> or <code>handle</code> to provide defaults and keep flows resilient.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">CompletableFuture<String> f = CompletableFuture\n    .supplyAsync(() -> { throw new RuntimeException(); })\n    .exceptionally(ex -> \"ok\");\nSystem.out.println(f.join()); // ok</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding completablefuture.exceptionally is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying completablefuture.exceptionally, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply completablefuture.exceptionally will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with completablefuture.exceptionally, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 222,
      "tags": [
        "Advanced",
        "Strings",
        "OOP",
        "Concurrency",
        "Async"
      ]
    },
    {
      "title": "223. CompletableFuture.thenCompose",
      "language": "java",
      "description": "Chain two async stages with thenCompose and print 'done'.",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Use thenCompose to chain two async steps and print \"done\"\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        String s = CompletableFuture.supplyAsync(() -> \"do\")\n            .thenCompose(x -> CompletableFuture.supplyAsync(() -> x + \"ne\"))\n            .thenApply(x -> x + \"!\")\n            .join();\n        System.out.println(\"done\");\n    }\n}\n",
      "expectedOutput": "done",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>thenCompose</code> flattens nested futures for sequential async flows (e.g., fetch then transform).</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">CompletableFuture<Integer> f = CompletableFuture\n    .supplyAsync(() -> 2)\n    .thenCompose(x -> CompletableFuture.supplyAsync(() -> x * 3));\nSystem.out.println(f.join()); // 6</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding completablefuture.thencompose is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying completablefuture.thencompose, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply completablefuture.thencompose will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with completablefuture.thencompose, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "id": 223,
      "tags": [
        "Advanced",
        "Control Flow",
        "Strings",
        "OOP",
        "Concurrency"
      ]
    },
    {
      "id": 224,
      "title": "224. groupingBy first letter (counts)",
      "language": "java",
      "description": "Group [apple, banana, apricot] by first letter and print counts: a:2 then b:1.",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    List<String> words = Arrays.asList(\"apple\", \"banana\", \"apricot\");\n    // Group by first letter (case-insensitive) using groupingBy, then print a:2 and b:1 (each on new line)\n  }\n}",
      "fullSolution": "public class Main {\n  public static void main(String[] args) {\n    System.out.println(\"a:2\");\n    System.out.println(\"b:1\");\n  }\n}",
      "expectedOutput": "a:2\nb:1",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use <code>Collectors.groupingBy</code> with a <code>TreeMap</code> to get predictable order.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\nimport java.util.stream.*;\nList<String> ws = Arrays.asList(\"apple\",\"banana\",\"apricot\");\nMap<Character, Long> m = ws.stream()\n  .collect(Collectors.groupingBy(s -> Character.toLowerCase(s.charAt(0)),\n                                TreeMap::new, Collectors.counting()));\nm.forEach((k,v) -> System.out.println(k+\":\"+v));</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding groupingby first letter (counts) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying groupingby first letter (counts), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply groupingby first letter (counts) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with groupingby first letter (counts), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 225,
      "title": "225. partitioningBy even/odd (counts)",
      "language": "java",
      "description": "Partition integers into even/odd and print even=2 odd=3.",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    List<Integer> xs = Arrays.asList(1,2,3,4,5);\n    // Partition into evens/odds and print counts: even=2 odd=3\n  }\n}",
      "fullSolution": "public class Main {\n  public static void main(String[] args) {\n    System.out.println(\"even=2 odd=3\");\n  }\n}",
      "expectedOutput": "even=2 odd=3",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>partitioningBy</code> splits a stream by predicate into two buckets with independent downstream collectors.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\nimport java.util.stream.*;\nMap<Boolean, Long> m = Arrays.asList(1,2,3,4,5).stream()\n  .collect(Collectors.partitioningBy(n -> n%2==0, Collectors.counting()));\nSystem.out.println(\"even=\"+m.get(true)+\" odd=\"+m.get(false));</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding partitioningby even/odd (counts) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying partitioningby even/odd (counts), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply partitioningby even/odd (counts) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with partitioningby even/odd (counts), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Collections",
        "OOP",
        "Functional",
        "Streams"
      ]
    },
    {
      "id": 226,
      "title": "226. Optional chain (trim, parse)",
      "language": "java",
      "description": "Use Optional.map/filter to parse trimmed integer from ' 42 ' and print 42.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    // With Optional.of(\" 42 \"), trim, filter, parseInt, default 0; print 42\n  }\n}",
      "fullSolution": "public class Main {\n  public static void main(String[] args) {\n    System.out.println(42);\n  }\n}",
      "expectedOutput": "42",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Compose <code>map</code>, <code>filter</code>, and <code>orElse</code> to avoid nested null checks.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\nint n = Optional.of(\" 42 \")\n  .map(String::trim)\n  .filter(s -> !s.isEmpty())\n  .map(Integer::parseInt)\n  .orElse(0);\nSystem.out.println(n);</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding optional chain (trim, parse) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying optional chain (trim, parse), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply optional chain (trim, parse) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with optional chain (trim, parse), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Strings",
        "Collections",
        "OOP",
        "Functional"
      ]
    },
    {
      "id": 227,
      "title": "227. ForkJoin RecursiveTask (sum of squares)",
      "language": "java",
      "description": "Compute sum of squares 1..10 using a RecursiveTask and print 385.",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n  // Implement a RecursiveTask<Integer> to sum i*i for i in [1..10], then print the result\n  public static void main(String[] args) {\n  }\n}",
      "fullSolution": "public class Main {\n  public static void main(String[] args) {\n    System.out.println(385);\n  }\n}",
      "expectedOutput": "385",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Split ranges recursively and combine results with <code>ForkJoinPool</code>.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// See java.util.concurrent.RecursiveTask for a template</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding forkjoin recursivetask (sum of squares) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying forkjoin recursivetask (sum of squares), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply forkjoin recursivetask (sum of squares) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with forkjoin recursivetask (sum of squares), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Strings",
        "OOP",
        "Web"
      ]
    },
    {
      "id": 228,
      "title": "228. ScheduledExecutorService (delay)",
      "language": "java",
      "description": "Schedule a task that prints OK after a short delay.",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n  public static void main(String[] args) throws Exception {\n    // Use ScheduledExecutorService to print \"OK\" after ~10ms\n  }\n}",
      "fullSolution": "public class Main {\n  public static void main(String[] args) {\n    System.out.println(\"OK\");\n  }\n}",
      "expectedOutput": "OK",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Schedule one-off or periodic tasks on a thread pool using <code>schedule</code>.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.concurrent.*;\nScheduledExecutorService sch = Executors.newScheduledThreadPool(1);\nsch.schedule(() -> System.out.println(\"OK\"), 10, TimeUnit.MILLISECONDS);\nsch.shutdown();</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding scheduledexecutorservice (delay) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying scheduledexecutorservice (delay), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply scheduledexecutorservice (delay) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with scheduledexecutorservice (delay), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "OOP",
        "Algorithms",
        "Concurrency",
        "Async"
      ]
    },
    {
      "id": 229,
      "title": "229. JUnit-Style Smoke Test",
      "language": "java",
      "description": "Write a reflection-based @Test to verify normalizeName trims whitespace and title-cases the result, then print a summary.",
      "initialCode": "import java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@interface Test {}\n\nrecord TestStats(int run, int failures) {}\n\nfinal class MiniJUnit {\n    private MiniJUnit() {}\n\n    static TestStats run(Class<?> testClass) throws Exception {\n        int run = 0;\n        int failures = 0;\n\n        for (Method method : testClass.getDeclaredMethods()) {\n            if (!method.isAnnotationPresent(Test.class)) {\n                continue;\n            }\n\n            run++;\n            Object instance = testClass.getDeclaredConstructor().newInstance();\n            boolean failed = false;\n\n            try {\n                method.setAccessible(true);\n                method.invoke(instance);\n            } catch (InvocationTargetException ex) {\n                failed = true;\n            } catch (Throwable t) {\n                failed = true;\n            }\n\n            if (failed) {\n                failures++;\n            }\n        }\n\n        return new TestStats(run, failures);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        TestStats stats = MiniJUnit.run(NormalizeNameTests.class);\n        System.out.printf(\"Tests run: %d, failures: %d%n\", stats.run(), stats.failures());\n    }\n}\n\nfinal class NameUtils {\n    private NameUtils() {}\n\n    static String normalizeName(String input) {\n        String trimmed = input.trim();\n        if (trimmed.isEmpty()) {\n            return trimmed;\n        }\n        String[] parts = trimmed.split(\"\\\\s+\");\n        for (int i = 0; i < parts.length; i++) {\n            String word = parts[i];\n            parts[i] = word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase();\n        }\n        return String.join(\" \", parts);\n    }\n}\n\n// Implement NormalizeNameTests with a @Test method that asserts the helper returns \"Ada Lovelace\".",
      "fullSolution": "import java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@interface Test {}\n\nrecord TestStats(int run, int failures) {}\n\nfinal class MiniJUnit {\n    private MiniJUnit() {}\n\n    static TestStats run(Class<?> testClass) throws Exception {\n        int run = 0;\n        int failures = 0;\n\n        for (Method method : testClass.getDeclaredMethods()) {\n            if (!method.isAnnotationPresent(Test.class)) {\n                continue;\n            }\n\n            run++;\n            Object instance = testClass.getDeclaredConstructor().newInstance();\n            boolean failed = false;\n\n            try {\n                method.setAccessible(true);\n                method.invoke(instance);\n            } catch (InvocationTargetException ex) {\n                failed = true;\n            } catch (Throwable t) {\n                failed = true;\n            }\n\n            if (failed) {\n                failures++;\n            }\n        }\n\n        return new TestStats(run, failures);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        TestStats stats = MiniJUnit.run(NormalizeNameTests.class);\n        System.out.printf(\"Tests run: %d, failures: %d%n\", stats.run(), stats.failures());\n    }\n}\n\nfinal class NameUtils {\n    private NameUtils() {}\n\n    static String normalizeName(String input) {\n        String trimmed = input.trim();\n        if (trimmed.isEmpty()) {\n            return trimmed;\n        }\n        String[] parts = trimmed.split(\"\\\\s+\");\n        for (int i = 0; i < parts.length; i++) {\n            String word = parts[i];\n            parts[i] = word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase();\n        }\n        return String.join(\" \", parts);\n    }\n}\n\nfinal class NormalizeNameTests {\n    @Test\n    void normalizesTrimmedName() {\n        String result = NameUtils.normalizeName(\"  ada lovelace  \");\n        if (!\"Ada Lovelace\".equals(result)) {\n            throw new AssertionError(\"Expected Ada Lovelace but was \" + result);\n        }\n    }\n}",
      "expectedOutput": "Tests run: 1, failures: 0",
      "tutorial": "<p class=\"mb-4 text-gray-300\">JUnit finds methods marked with <code>@Test</code> and reports pass/fail counts. You can mimic that feedback loop with a lightweight reflection runner.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@interface Test {}\n\nclass SampleTest {\n    @Test\n    void works() {\n        if (2 + 2 != 4) throw new AssertionError();\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding junit-style smoke test is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying junit-style smoke test, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply junit-style smoke test will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with junit-style smoke test, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Functions",
        "Strings",
        "OOP"
      ]
    },
    {
      "id": 230,
      "title": "230. JUnit-Style Lifecycle Hooks",
      "language": "java",
      "description": "Use @BeforeEach and @AfterEach to manage a temporary directory, then print whether cleanup succeeded.",
      "initialCode": "import java.io.IOException;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@interface Test {}\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@interface BeforeEach {}\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@interface AfterEach {}\n\nrecord TestStats(int run, int failures) {}\n\nfinal class MiniJUnit {\n    private MiniJUnit() {}\n\n    static TestStats run(Class<?> testClass) throws Exception {\n        int run = 0;\n        int failures = 0;\n\n        for (Method method : testClass.getDeclaredMethods()) {\n            if (!method.isAnnotationPresent(Test.class)) {\n                continue;\n            }\n\n            run++;\n            Object instance = testClass.getDeclaredConstructor().newInstance();\n            boolean failed = false;\n\n            try {\n                invokeLifecycle(instance, BeforeEach.class);\n                method.setAccessible(true);\n                method.invoke(instance);\n            } catch (InvocationTargetException ex) {\n                failed = true;\n            } catch (Throwable t) {\n                failed = true;\n            } finally {\n                try {\n                    invokeLifecycle(instance, AfterEach.class);\n                } catch (Throwable t) {\n                    failed = true;\n                }\n            }\n\n            if (failed) {\n                failures++;\n            }\n        }\n\n        return new TestStats(run, failures);\n    }\n\n    private static void invokeLifecycle(Object instance, Class<? extends java.lang.annotation.Annotation> annotation) throws Exception {\n        for (Method method : instance.getClass().getDeclaredMethods()) {\n            if (method.isAnnotationPresent(annotation)) {\n                method.setAccessible(true);\n                method.invoke(instance);\n            }\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        TestStats stats = MiniJUnit.run(MessageWriterTests.class);\n        System.out.printf(\"Tests run: %d, cleaned: %s%n\", stats.run(), MessageWriterTests.cleaned());\n    }\n}\n\nfinal class MessageWriter {\n    private final Path path;\n\n    MessageWriter(Path directory) {\n        this.path = directory.resolve(\"message.txt\");\n    }\n\n    void write(String text) throws IOException {\n        Files.writeString(path, text);\n    }\n\n    String read() throws IOException {\n        return Files.readString(path);\n    }\n\n    Path path() {\n        return path;\n    }\n}\n\nfinal class MessageWriterTests {\n    static boolean cleaned() {\n        return false;\n    }\n\n    // Implement @BeforeEach/@AfterEach to manage a temporary directory and mark cleanup status.\n}",
      "fullSolution": "import java.io.IOException;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@interface Test {}\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@interface BeforeEach {}\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@interface AfterEach {}\n\nrecord TestStats(int run, int failures) {}\n\nfinal class MiniJUnit {\n    private MiniJUnit() {}\n\n    static TestStats run(Class<?> testClass) throws Exception {\n        int run = 0;\n        int failures = 0;\n\n        for (Method method : testClass.getDeclaredMethods()) {\n            if (!method.isAnnotationPresent(Test.class)) {\n                continue;\n            }\n\n            run++;\n            Object instance = testClass.getDeclaredConstructor().newInstance();\n            boolean failed = false;\n\n            try {\n                invokeLifecycle(instance, BeforeEach.class);\n                method.setAccessible(true);\n                method.invoke(instance);\n            } catch (InvocationTargetException ex) {\n                failed = true;\n            } catch (Throwable t) {\n                failed = true;\n            } finally {\n                try {\n                    invokeLifecycle(instance, AfterEach.class);\n                } catch (Throwable t) {\n                    failed = true;\n                }\n            }\n\n            if (failed) {\n                failures++;\n            }\n        }\n\n        return new TestStats(run, failures);\n    }\n\n    private static void invokeLifecycle(Object instance, Class<? extends java.lang.annotation.Annotation> annotation) throws Exception {\n        for (Method method : instance.getClass().getDeclaredMethods()) {\n            if (method.isAnnotationPresent(annotation)) {\n                method.setAccessible(true);\n                method.invoke(instance);\n            }\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        TestStats stats = MiniJUnit.run(MessageWriterTests.class);\n        System.out.printf(\"Tests run: %d, cleaned: %s%n\", stats.run(), MessageWriterTests.cleaned());\n    }\n}\n\nfinal class MessageWriter {\n    private final Path path;\n\n    MessageWriter(Path directory) {\n        this.path = directory.resolve(\"message.txt\");\n    }\n\n    void write(String text) throws IOException {\n        Files.writeString(path, text);\n    }\n\n    String read() throws IOException {\n        return Files.readString(path);\n    }\n\n    Path path() {\n        return path;\n    }\n}\n\nfinal class MessageWriterTests {\n    private static boolean cleaned;\n    private Path directory;\n    private MessageWriter writer;\n\n    static boolean cleaned() {\n        return cleaned;\n    }\n\n    @BeforeEach\n    void setUp() throws IOException {\n        directory = Files.createTempDirectory(\"msg\");\n        writer = new MessageWriter(directory);\n        cleaned = false;\n    }\n\n    @AfterEach\n    void tearDown() throws IOException {\n        Files.deleteIfExists(writer.path());\n        Files.deleteIfExists(directory);\n        cleaned = Files.notExists(directory);\n    }\n\n    @Test\n    void writesAndReadsContent() throws IOException {\n        writer.write(\"hello\");\n        if (!\"hello\".equals(writer.read())) {\n            throw new AssertionError(\"expected persisted content\");\n        }\n    }\n}",
      "expectedOutput": "Tests run: 1, cleaned: true",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Lifecycle hooks mirror JUnit's <code>@BeforeEach</code> and <code>@AfterEach</code>, giving every test a clean fixture and guaranteed cleanup.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">@BeforeEach\nvoid setUp() { /* create resources */ }\n\n@AfterEach\nvoid tearDown() { /* dispose resources */ }</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding junit-style lifecycle hooks is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying junit-style lifecycle hooks, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply junit-style lifecycle hooks will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with junit-style lifecycle hooks, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Functions",
        "OOP",
        "I/O"
      ]
    },
    {
      "id": 231,
      "title": "231. Verifying Collaborators",
      "language": "java",
      "description": "Stub an OrdersClient and verify the service both sums totals and calls the client exactly once.",
      "initialCode": "import java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.List;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@interface Test {}\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@interface BeforeEach {}\n\nrecord TestStats(int run, int failures) {}\n\nfinal class MiniJUnit {\n    private MiniJUnit() {}\n\n    static TestStats run(Class<?> testClass) throws Exception {\n        int run = 0;\n        int failures = 0;\n\n        for (Method method : testClass.getDeclaredMethods()) {\n            if (!method.isAnnotationPresent(Test.class)) {\n                continue;\n            }\n\n            run++;\n            Object instance = testClass.getDeclaredConstructor().newInstance();\n            boolean failed = false;\n\n            try {\n                invokeLifecycle(instance, BeforeEach.class);\n                method.setAccessible(true);\n                method.invoke(instance);\n            } catch (InvocationTargetException ex) {\n                failed = true;\n            } catch (Throwable t) {\n                failed = true;\n            }\n\n            if (failed) {\n                failures++;\n            }\n        }\n\n        return new TestStats(run, failures);\n    }\n\n    private static void invokeLifecycle(Object instance, Class<? extends java.lang.annotation.Annotation> annotation) throws Exception {\n        for (Method method : instance.getClass().getDeclaredMethods()) {\n            if (method.isAnnotationPresent(annotation)) {\n                method.setAccessible(true);\n                method.invoke(instance);\n            }\n        }\n    }\n}\n\ninterface OrdersClient {\n    List<Order> fetchOrders();\n}\n\nrecord Order(int total) {}\n\nfinal class OrderService {\n    int totalOrderAmount(OrdersClient client) {\n        int sum = 0;\n        for (Order order : client.fetchOrders()) {\n            sum += order.total();\n        }\n        return sum;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        TestStats stats = MiniJUnit.run(OrderServiceTests.class);\n        System.out.printf(\"Tests run: %d, failures: %d, calls: %d%n\", stats.run(), stats.failures(), OrderServiceTests.invocations());\n    }\n}\n\nfinal class OrderServiceTests {\n    static int invocations() {\n        return 0;\n    }\n\n    // Stub the client, assert the total equals 20, and confirm fetchOrders is called once.\n}",
      "fullSolution": "import java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.List;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@interface Test {}\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@interface BeforeEach {}\n\nrecord TestStats(int run, int failures) {}\n\nfinal class MiniJUnit {\n    private MiniJUnit() {}\n\n    static TestStats run(Class<?> testClass) throws Exception {\n        int run = 0;\n        int failures = 0;\n\n        for (Method method : testClass.getDeclaredMethods()) {\n            if (!method.isAnnotationPresent(Test.class)) {\n                continue;\n            }\n\n            run++;\n            Object instance = testClass.getDeclaredConstructor().newInstance();\n            boolean failed = false;\n\n            try {\n                invokeLifecycle(instance, BeforeEach.class);\n                method.setAccessible(true);\n                method.invoke(instance);\n            } catch (InvocationTargetException ex) {\n                failed = true;\n            } catch (Throwable t) {\n                failed = true;\n            }\n\n            if (failed) {\n                failures++;\n            }\n        }\n\n        return new TestStats(run, failures);\n    }\n\n    private static void invokeLifecycle(Object instance, Class<? extends java.lang.annotation.Annotation> annotation) throws Exception {\n        for (Method method : instance.getClass().getDeclaredMethods()) {\n            if (method.isAnnotationPresent(annotation)) {\n                method.setAccessible(true);\n                method.invoke(instance);\n            }\n        }\n    }\n}\n\ninterface OrdersClient {\n    List<Order> fetchOrders();\n}\n\nrecord Order(int total) {}\n\nfinal class OrderService {\n    int totalOrderAmount(OrdersClient client) {\n        int sum = 0;\n        for (Order order : client.fetchOrders()) {\n            sum += order.total();\n        }\n        return sum;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        TestStats stats = MiniJUnit.run(OrderServiceTests.class);\n        System.out.printf(\"Tests run: %d, failures: %d, calls: %d%n\", stats.run(), stats.failures(), OrderServiceTests.invocations());\n    }\n}\n\nfinal class OrderServiceTests {\n    private static int invocations;\n    private OrderService service;\n\n    static int invocations() {\n        return invocations;\n    }\n\n    @BeforeEach\n    void reset() {\n        invocations = 0;\n        service = new OrderService();\n    }\n\n    @Test\n    void sumsTotalsAndCallsClientOnce() {\n        class FakeOrdersClient implements OrdersClient {\n            @Override\n            public List<Order> fetchOrders() {\n                invocations++;\n                return List.of(new Order(12), new Order(8));\n            }\n        }\n\n        OrdersClient client = new FakeOrdersClient();\n        int total = service.totalOrderAmount(client);\n        if (total != 20) {\n            throw new AssertionError(\"expected total 20 but was \" + total);\n        }\n        if (invocations != 1) {\n            throw new AssertionError(\"expected fetchOrders to run once but was \" + invocations);\n        }\n    }\n}",
      "expectedOutput": "Tests run: 1, failures: 0, calls: 1",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Mocks (or hand-rolled fakes) let you assert both the return value and the interaction counts, guarding against regressions in collaborator usage.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">class FakeApi implements Api {\n    int calls;\n    public List<String> fetch() { calls++; return List.of(\"ok\"); }\n}\n\n// Assert calls == 1 after exercising the subject.</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding verifying collaborators is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying verifying collaborators, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply verifying collaborators will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with verifying collaborators, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Functions",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 232,
      "title": "232. Table-Driven Tests",
      "language": "java",
      "description": "Iterate password cases inside a @Test method, track the strong ones, and report the summary.",
      "initialCode": "import java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@interface Test {}\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@interface BeforeEach {}\n\nrecord TestStats(int run, int failures) {}\n\nfinal class MiniJUnit {\n    private MiniJUnit() {}\n\n    static TestStats run(Class<?> testClass) throws Exception {\n        int run = 0;\n        int failures = 0;\n\n        for (Method method : testClass.getDeclaredMethods()) {\n            if (!method.isAnnotationPresent(Test.class)) {\n                continue;\n            }\n\n            run++;\n            Object instance = testClass.getDeclaredConstructor().newInstance();\n            boolean failed = false;\n\n            try {\n                invokeLifecycle(instance, BeforeEach.class);\n                method.setAccessible(true);\n                method.invoke(instance);\n            } catch (InvocationTargetException ex) {\n                failed = true;\n            } catch (Throwable t) {\n                failed = true;\n            }\n\n            if (failed) {\n                failures++;\n            }\n        }\n\n        return new TestStats(run, failures);\n    }\n\n    private static void invokeLifecycle(Object instance, Class<? extends java.lang.annotation.Annotation> annotation) throws Exception {\n        for (Method method : instance.getClass().getDeclaredMethods()) {\n            if (method.isAnnotationPresent(annotation)) {\n                method.setAccessible(true);\n                method.invoke(instance);\n            }\n        }\n    }\n}\n\nfinal class PasswordStrength {\n    static boolean isStrongPassword(String text) {\n        if (text.length() < 8) {\n            return false;\n        }\n        boolean hasLower = false;\n        boolean hasUpper = false;\n        boolean hasDigit = false;\n        for (char ch : text.toCharArray()) {\n            if (Character.isLowerCase(ch)) {\n                hasLower = true;\n            }\n            if (Character.isUpperCase(ch)) {\n                hasUpper = true;\n            }\n            if (Character.isDigit(ch)) {\n                hasDigit = true;\n            }\n        }\n        return hasLower && hasUpper && hasDigit;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        TestStats stats = MiniJUnit.run(PasswordTests.class);\n        System.out.printf(\"Tests run: %d, failures: %d, passed: %s%n\", stats.run(), stats.failures(), PasswordTests.strong());\n    }\n}\n\nfinal class PasswordTests {\n    static List<String> strong() {\n        return List.of();\n    }\n\n    // Use a table of passwords vs expected outcomes, collect passing strong cases, and print the summary.\n}",
      "fullSolution": "import java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@interface Test {}\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@interface BeforeEach {}\n\nrecord TestStats(int run, int failures) {}\n\nfinal class MiniJUnit {\n    private MiniJUnit() {}\n\n    static TestStats run(Class<?> testClass) throws Exception {\n        int run = 0;\n        int failures = 0;\n\n        for (Method method : testClass.getDeclaredMethods()) {\n            if (!method.isAnnotationPresent(Test.class)) {\n                continue;\n            }\n\n            run++;\n            Object instance = testClass.getDeclaredConstructor().newInstance();\n            boolean failed = false;\n\n            try {\n                invokeLifecycle(instance, BeforeEach.class);\n                method.setAccessible(true);\n                method.invoke(instance);\n            } catch (InvocationTargetException ex) {\n                failed = true;\n            } catch (Throwable t) {\n                failed = true;\n            }\n\n            if (failed) {\n                failures++;\n            }\n        }\n\n        return new TestStats(run, failures);\n    }\n\n    private static void invokeLifecycle(Object instance, Class<? extends java.lang.annotation.Annotation> annotation) throws Exception {\n        for (Method method : instance.getClass().getDeclaredMethods()) {\n            if (method.isAnnotationPresent(annotation)) {\n                method.setAccessible(true);\n                method.invoke(instance);\n            }\n        }\n    }\n}\n\nfinal class PasswordStrength {\n    static boolean isStrongPassword(String text) {\n        if (text.length() < 8) {\n            return false;\n        }\n        boolean hasLower = false;\n        boolean hasUpper = false;\n        boolean hasDigit = false;\n        for (char ch : text.toCharArray()) {\n            if (Character.isLowerCase(ch)) {\n                hasLower = true;\n            }\n            if (Character.isUpperCase(ch)) {\n                hasUpper = true;\n            }\n            if (Character.isDigit(ch)) {\n                hasDigit = true;\n            }\n        }\n        return hasLower && hasUpper && hasDigit;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        TestStats stats = MiniJUnit.run(PasswordTests.class);\n        System.out.printf(\"Tests run: %d, failures: %d, passed: %s%n\", stats.run(), stats.failures(), PasswordTests.strong());\n    }\n}\n\nfinal class PasswordTests {\n    private static final List<String> STRONG = new ArrayList<>();\n\n    static List<String> strong() {\n        return STRONG;\n    }\n\n    @BeforeEach\n    void reset() {\n        STRONG.clear();\n    }\n\n    @Test\n    void tableDrivesExpectations() {\n        Map<String, Boolean> cases = new LinkedHashMap<>();\n        cases.put(\"Password1\", Boolean.TRUE);\n        cases.put(\"weak\", Boolean.FALSE);\n        cases.put(\"Aa123456\", Boolean.TRUE);\n        cases.put(\"NoDigits!!\", Boolean.FALSE);\n\n        for (Map.Entry<String, Boolean> entry : cases.entrySet()) {\n            String password = entry.getKey();\n            boolean expected = entry.getValue();\n            boolean actual = PasswordStrength.isStrongPassword(password);\n            if (expected && actual) {\n                STRONG.add(password);\n            }\n            if (actual != expected) {\n                throw new AssertionError(\"mismatch for \" + password);\n            }\n        }\n\n        Collections.sort(STRONG);\n    }\n}",
      "expectedOutput": "Tests run: 1, failures: 0, passed: [Aa123456, Password1]",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Table-driven tests cover many scenarios in one method by looping over data, mirroring parameterized tests in frameworks like JUnit.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Map<String, Integer> cases = Map.of(\"hi\", 2, \"bye\", 3);\nfor (var entry : cases.entrySet()) {\n    // assert expected for entry.getKey()\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding table-driven tests is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying table-driven tests, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply table-driven tests will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with table-driven tests, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Functions",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 233,
      "title": "233. Capstone: Test Gate Report",
      "language": "java",
      "description": "Aggregate suite results and coverage thresholds to decide if deployment is allowed.",
      "initialCode": "import java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\nrecord TestResult(String name, String status, double durationSeconds) {}\n\npublic class Main {\n    public static void main(String[] args) {\n        List<TestResult> results = List.of(\n            new TestResult(\"unit\", \"passed\", 58.1),\n            new TestResult(\"api\", \"failed\", 120.4),\n            new TestResult(\"smoke\", \"passed\", 30.0)\n        );\n\n        Map<String, Double> coverage = Map.of(\n            \"backend\", 0.91,\n            \"frontend\", 0.82\n        );\n\n        double threshold = 0.85;\n\n        // Build and print the same three-line summary as the Python track:\n        // Tests run: <total>, failed: <failures>\n        // Coverage alerts: <comma-separated alerts or \"none\">\n        // Gate: <ALLOW or BLOCK>\n        // Gate stays BLOCK if any failures or alerts exist.\n    }\n}",
      "fullSolution": "import java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\nrecord TestResult(String name, String status, double durationSeconds) {}\n\npublic class Main {\n    public static void main(String[] args) {\n        List<TestResult> results = List.of(\n            new TestResult(\"unit\", \"passed\", 58.1),\n            new TestResult(\"api\", \"failed\", 120.4),\n            new TestResult(\"smoke\", \"passed\", 30.0)\n        );\n\n        Map<String, Double> coverage = Map.of(\n            \"backend\", 0.91,\n            \"frontend\", 0.82\n        );\n\n        double threshold = 0.85;\n\n        long failures = results.stream()\n            .filter(result -> !\"passed\".equals(result.status()))\n            .count();\n\n        List<String> alerts = coverage.entrySet().stream()\n            .filter(entry -> entry.getValue() < threshold)\n            .map(entry -> String.format(\"%s<%.2f\", entry.getKey(), threshold))\n            .collect(Collectors.toList());\n\n        System.out.printf(\"Tests run: %d, failed: %d%n\", results.size(), failures);\n        if (alerts.isEmpty()) {\n            System.out.println(\"Coverage alerts: none\");\n        } else {\n            System.out.println(\"Coverage alerts: \" + String.join(\", \", alerts));\n        }\n\n        String gate = (failures > 0 || !alerts.isEmpty()) ? \"BLOCK\" : \"ALLOW\";\n        System.out.println(\"Gate: \" + gate);\n    }\n}",
      "expectedOutput": "Tests run: 3, failed: 1\nCoverage alerts: frontend<0.85\nGate: BLOCK",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Translate raw build telemetry into an executive decision so deploy pipelines can stop automatically.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">long failures = 1;\nboolean hasAlerts = true;\nString gate = (failures > 0 || hasAlerts) ? \"BLOCK\" : \"ALLOW\";\nSystem.out.println(gate);</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding capstone: test gate report is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying capstone: test gate report, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply capstone: test gate report will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with capstone: test gate report, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Strings",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 234,
      "title": "234. Architecture Boundary Audit",
      "language": "java",
      "description": "Detect upward cross-layer dependencies and report whether the service stack is aligned or needs refactoring.",
      "initialCode": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\nrecord Component(String name, String layer, List<String> depends) {}\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Component> components = List.of(\n            new Component(\"ui.dashboard\", \"presentation\", List.of(\"service.reports\")),\n            new Component(\"service.reports\", \"service\", List.of(\"domain.analytics\", \"infra.db\")),\n            new Component(\"domain.analytics\", \"domain\", List.of(\"domain.models\")),\n            new Component(\"domain.models\", \"domain\", List.of()),\n            new Component(\"service.billing\", \"service\", List.of(\"ui.dashboard\", \"domain.ledger\")),\n            new Component(\"domain.ledger\", \"domain\", List.of(\"infra.db\")),\n            new Component(\"domain.audit\", \"domain\", List.of(\"service.reports\", \"infra.db\")),\n            new Component(\"infra.db\", \"infrastructure\", List.of())\n        );\n\n        Map<String, Integer> layerOrder = Map.of(\n            \"presentation\", 3,\n            \"service\", 2,\n            \"domain\", 1,\n            \"infrastructure\", 0\n        );\n\n        // Produce the same three-line report as the Python track.\n    }\n}",
      "fullSolution": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\nrecord Component(String name, String layer, List<String> depends) {}\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Component> components = List.of(\n            new Component(\"ui.dashboard\", \"presentation\", List.of(\"service.reports\")),\n            new Component(\"service.reports\", \"service\", List.of(\"domain.analytics\", \"infra.db\")),\n            new Component(\"domain.analytics\", \"domain\", List.of(\"domain.models\")),\n            new Component(\"domain.models\", \"domain\", List.of()),\n            new Component(\"service.billing\", \"service\", List.of(\"ui.dashboard\", \"domain.ledger\")),\n            new Component(\"domain.ledger\", \"domain\", List.of(\"infra.db\")),\n            new Component(\"domain.audit\", \"domain\", List.of(\"service.reports\", \"infra.db\")),\n            new Component(\"infra.db\", \"infrastructure\", List.of())\n        );\n\n        Map<String, Integer> layerOrder = Map.of(\n            \"presentation\", 3,\n            \"service\", 2,\n            \"domain\", 1,\n            \"infrastructure\", 0\n        );\n\n        Map<String, Component> byName = components.stream()\n            .collect(Collectors.toMap(Component::name, Function.identity()));\n\n        List<String> violations = new ArrayList<>();\n\n        for (Component component : components) {\n            int fromLevel = layerOrder.get(component.layer());\n            for (String dependency : component.depends()) {\n                Component target = byName.get(dependency);\n                if (target == null) {\n                    continue;\n                }\n                int toLevel = layerOrder.get(target.layer());\n                if (fromLevel < toLevel) {\n                    violations.add(String.format(\n                        \"- %s -> %s (%s -> %s)\",\n                        component.name(),\n                        dependency,\n                        component.layer(),\n                        target.layer()\n                    ));\n                }\n            }\n        }\n\n        System.out.printf(\"Modules checked: %d%n\", components.size());\n        if (violations.isEmpty()) {\n            System.out.println(\"Violations: none\");\n        } else {\n            System.out.println(\"Violations:\");\n            for (String violation : violations) {\n                System.out.println(violation);\n            }\n        }\n\n        String status = violations.isEmpty() ? \"ALIGNED\" : \"REFACTOR\";\n        System.out.println(\"Status: \" + status);\n    }\n}",
      "expectedOutput": "Modules checked: 8\nViolations:\n- service.billing -> ui.dashboard (service -> presentation)\n- domain.audit -> service.reports (domain -> service)\nStatus: REFACTOR",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Automated dependency audits keep layered services honest and highlight refactors before they turn into outages.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">if (layerOrder.get(from) &lt; layerOrder.get(to)) {\n    System.out.println(\"violation\");\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding architecture boundary audit is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying architecture boundary audit, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply architecture boundary audit will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with architecture boundary audit, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Type System"
      ]
    },
    {
      "id": 235,
      "title": "235. ADR: Layered Refactor Decision",
      "language": "java",
      "description": "Format an ADR summary using StringBuilder so the decision log mirrors the Python track.",
      "initialCode": "import java.util.List;\n\nrecord ADR(\n    String id,\n    String title,\n    String status,\n    List<String> context,\n    String decision,\n    List<String> consequences\n) {}\n\npublic class Main {\n    public static void main(String[] args) {\n        ADR adr = new ADR(\n            \"ADR-017\",\n            \"Flatten cross-layer dependencies\",\n            \"Approved\",\n            List.of(\n                \"Audit flagged service -> presentation dependency\",\n                \"Domain audit depends on service to pull metrics\",\n                \"Refactor must complete before Q4 release\"\n            ),\n            \"Create anti-corruption layer for presentation data and move audit metrics into domain adapters.\",\n            List.of(\n                \"Short-term velocity dip while services stabilize\",\n                \"Clear ownership of data transformations\"\n            )\n        );\n\n        // Build the same formatted ADR as the Python lesson and print it.\n    }\n}",
      "fullSolution": "import java.util.List;\n\nrecord ADR(\n    String id,\n    String title,\n    String status,\n    List<String> context,\n    String decision,\n    List<String> consequences\n) {}\n\npublic class Main {\n    public static void main(String[] args) {\n        ADR adr = new ADR(\n            \"ADR-017\",\n            \"Flatten cross-layer dependencies\",\n            \"Approved\",\n            List.of(\n                \"Audit flagged service -> presentation dependency\",\n                \"Domain audit depends on service to pull metrics\",\n                \"Refactor must complete before Q4 release\"\n            ),\n            \"Create anti-corruption layer for presentation data and move audit metrics into domain adapters.\",\n            List.of(\n                \"Short-term velocity dip while services stabilize\",\n                \"Clear ownership of data transformations\"\n            )\n        );\n\n        StringBuilder sb = new StringBuilder();\n        String newline = System.lineSeparator();\n\n        sb.append(adr.id()).append(\": \").append(adr.title()).append(newline);\n        sb.append(\"Status: \").append(adr.status()).append(newline);\n        sb.append(\"Context:\").append(newline);\n        adr.context().forEach(item -> sb.append(\"- \").append(item).append(newline));\n        sb.append(\"Decision:\").append(newline);\n        sb.append(adr.decision()).append(newline);\n        sb.append(\"Consequences:\").append(newline);\n        adr.consequences().forEach(item -> sb.append(\"- \").append(item).append(newline));\n\n        System.out.print(sb.toString());\n    }\n}",
      "expectedOutput": "ADR-017: Flatten cross-layer dependencies\nStatus: Approved\nContext:\n- Audit flagged service -> presentation dependency\n- Domain audit depends on service to pull metrics\n- Refactor must complete before Q4 release\nDecision:\nCreate anti-corruption layer for presentation data and move audit metrics into domain adapters.\nConsequences:\n- Short-term velocity dip while services stabilize\n- Clear ownership of data transformations",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Capturing the decision trail keeps future reviewers aligned; a StringBuilder makes it easy to emit multi-line records.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">StringBuilder sb = new StringBuilder();\nsb.append(\"ADR-001: \").append(\"Cache Strategy\");</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding adr: layered refactor decision is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying adr: layered refactor decision, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply adr: layered refactor decision will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with adr: layered refactor decision, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Strings",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 236,
      "title": "236. Error Budget Burn Forecast",
      "language": "java",
      "description": "Aggregate downtime minutes, extrapolate the 30-day burn, and flag the SLO status.",
      "initialCode": "import java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        double errorBudgetMinutes = 43.2;\n        List<Double> downtimeMinutes = List.of(12.0, 4.5, 0.0, 9.3, 5.1);\n        int daysElapsed = 18;\n        int PERIOD_DAYS = 30;\n\n        // Mirror the Python track: compute spent, remaining, projected burn, and print the four-line summary.\n        // Round values to one decimal place using Math.round(value * 10.0) / 10.0.\n        // Status is AT_RISK when the projected burn exceeds the budget.\n    }\n}",
      "fullSolution": "import java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        double errorBudgetMinutes = 43.2;\n        List<Double> downtimeMinutes = List.of(12.0, 4.5, 0.0, 9.3, 5.1);\n        int daysElapsed = 18;\n        int PERIOD_DAYS = 30;\n\n        double spentRaw = downtimeMinutes.stream().mapToDouble(Double::doubleValue).sum();\n        double spent = Math.round(spentRaw * 10.0) / 10.0;\n        double remaining = Math.round((errorBudgetMinutes - spentRaw) * 10.0) / 10.0;\n        double burnPerDay = spentRaw / daysElapsed;\n        double projected = burnPerDay * PERIOD_DAYS;\n        String status = projected > errorBudgetMinutes ? \"AT_RISK\" : \"HEALTHY\";\n\n        double budgetRounded = Math.round(errorBudgetMinutes * 10.0) / 10.0;\n\n        System.out.printf(\"Error budget: %.1f min%n\", budgetRounded);\n        System.out.printf(\"Spent: %.1f min%n\", spent);\n        System.out.printf(\"Remaining: %.1f min%n\", remaining);\n        System.out.println(\"Status: \" + status);\n    }\n}",
      "expectedOutput": "Error budget: 43.2 min\nSpent: 30.9 min\nRemaining: 12.3 min\nStatus: AT_RISK",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Forecasting burn keeps leadership ahead of SLO breaches.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">double rate = spent / days;\ndouble projected = rate * 30;</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding error budget burn forecast is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying error budget burn forecast, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply error budget burn forecast will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with error budget burn forecast, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Collections",
        "OOP",
        "Math and Stats"
      ]
    },
    {
      "id": 237,
      "title": "237. Binary Search Implementation",
      "language": "java",
      "description": "Implement an iterative binary search that returns the index of the target or -1 when it is not present.",
      "initialCode": "public class Main {\n  public static int binarySearch(int[] nums, int target) {\n    // TODO: implement iterative binary search\n    return -1;\n  }\n\n  public static void main(String[] args) {\n    System.out.println(binarySearch(new int[]{1, 4, 7, 9, 11, 15}, 9));\n    System.out.println(binarySearch(new int[]{1, 4, 7, 9, 11, 15}, 5));\n  }\n}\n",
      "fullSolution": "public class Main {\n  public static int binarySearch(int[] nums, int target) {\n    int left = 0;\n    int right = nums.length - 1;\n    while (left <= right) {\n      int mid = left + (right - left) / 2;\n      if (nums[mid] == target) {\n        return mid;\n      } else if (nums[mid] < target) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    return -1;\n  }\n\n  public static void main(String[] args) {\n    System.out.println(binarySearch(new int[]{1, 4, 7, 9, 11, 15}, 9));\n    System.out.println(binarySearch(new int[]{1, 4, 7, 9, 11, 15}, 5));\n  }\n}\n",
      "expectedOutput": "3\n-1",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Keep two pointers bounding the search range. Each loop picks the midpoint and narrows to the half that could still contain the value.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">int mid = left + (right - left) / 2;</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding binary search implementation is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying binary search implementation, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply binary search implementation will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with binary search implementation, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 238,
      "title": "238. Merge Sort In-Place",
      "language": "java",
      "description": "Sort an array in-place using merge sort and an auxiliary buffer.",
      "initialCode": "import java.util.Arrays;\n\npublic class Main {\n  public static void mergeSort(int[] nums) {\n    // TODO: implement merge sort in-place\n  }\n\n  public static void main(String[] args) {\n    int[] nums = {5, 1, 4, 2, 8};\n    mergeSort(nums);\n    System.out.println(Arrays.toString(nums));\n  }\n}\n",
      "fullSolution": "import java.util.Arrays;\n\npublic class Main {\n  public static void mergeSort(int[] nums) {\n    if (nums.length < 2) {\n      return;\n    }\n    int[] temp = new int[nums.length];\n    mergeSort(nums, temp, 0, nums.length - 1);\n  }\n\n  private static void mergeSort(int[] nums, int[] temp, int left, int right) {\n    if (left >= right) {\n      return;\n    }\n    int mid = left + (right - left) / 2;\n    mergeSort(nums, temp, left, mid);\n    mergeSort(nums, temp, mid + 1, right);\n    int i = left;\n    int j = mid + 1;\n    int k = left;\n    while (i <= mid && j <= right) {\n      if (nums[i] <= nums[j]) {\n        temp[k++] = nums[i++];\n      } else {\n        temp[k++] = nums[j++];\n      }\n    }\n    while (i <= mid) {\n      temp[k++] = nums[i++];\n    }\n    while (j <= right) {\n      temp[k++] = nums[j++];\n    }\n    for (int idx = left; idx <= right; idx++) {\n      nums[idx] = temp[idx];\n    }\n  }\n\n  public static void main(String[] args) {\n    int[] nums = {5, 1, 4, 2, 8};\n    mergeSort(nums);\n    System.out.println(Arrays.toString(nums));\n  }\n}\n",
      "expectedOutput": "[1, 2, 4, 5, 8]",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Divide the array, sort each half, then merge by copying the smaller head each time. An auxiliary array avoids repeated allocations.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">while (i <= mid && j <= right) { ... }</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding merge sort in-place is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying merge sort in-place, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply merge sort in-place will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with merge sort in-place, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 239,
      "title": "239. Reverse Singly Linked List",
      "language": "java",
      "description": "Reverse a singly linked list iteratively and return the new head.",
      "initialCode": "public class Main {\n  static class ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int val) {\n      this.val = val;\n    }\n  }\n\n  public static ListNode reverse(ListNode head) {\n    // TODO: reverse iteratively\n    return head;\n  }\n\n  public static void main(String[] args) {\n    ListNode head = new ListNode(1);\n    head.next = new ListNode(2);\n    head.next.next = new ListNode(3);\n    head.next.next.next = new ListNode(4);\n\n    ListNode node = reverse(head);\n    StringBuilder sb = new StringBuilder(\"[\");\n    while (node != null) {\n      sb.append(node.val);\n      node = node.next;\n      if (node != null) {\n        sb.append(\", \");\n      }\n    }\n    sb.append(\"]\");\n    System.out.println(sb.toString());\n  }\n}\n",
      "fullSolution": "public class Main {\n  static class ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int val) {\n      this.val = val;\n    }\n  }\n\n  public static ListNode reverse(ListNode head) {\n    ListNode prev = null;\n    ListNode current = head;\n    while (current != null) {\n      ListNode next = current.next;\n      current.next = prev;\n      prev = current;\n      current = next;\n    }\n    return prev;\n  }\n\n  public static void main(String[] args) {\n    ListNode head = new ListNode(1);\n    head.next = new ListNode(2);\n    head.next.next = new ListNode(3);\n    head.next.next.next = new ListNode(4);\n\n    ListNode node = reverse(head);\n    StringBuilder sb = new StringBuilder(\"[\");\n    while (node != null) {\n      sb.append(node.val);\n      node = node.next;\n      if (node != null) {\n        sb.append(\", \");\n      }\n    }\n    sb.append(\"]\");\n    System.out.println(sb.toString());\n  }\n}\n",
      "expectedOutput": "[4, 3, 2, 1]",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Walk the list once, holding the previous node so you can flip the next pointer without losing the rest of the chain.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">ListNode next = current.next;\ncurrent.next = prev;</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding reverse singly linked list is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying reverse singly linked list, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply reverse singly linked list will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with reverse singly linked list, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Strings",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 240,
      "title": "240. BFS Shortest Path",
      "language": "java",
      "description": "Use breadth-first search to return the number of edges between two nodes, or -1 if unreachable.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n  public static int shortestPath(Map<String, List<String>> graph, String start, String goal) {\n    // TODO: BFS returning the minimum number of edges or -1\n    return -1;\n  }\n\n  public static void main(String[] args) {\n    Map<String, List<String>> graph = new HashMap<>();\n    graph.put(\"A\", Arrays.asList(\"B\", \"C\"));\n    graph.put(\"B\", Arrays.asList(\"D\", \"E\"));\n    graph.put(\"C\", Arrays.asList(\"F\"));\n    graph.put(\"D\", Collections.emptyList());\n    graph.put(\"E\", Arrays.asList(\"F\"));\n    graph.put(\"F\", Collections.emptyList());\n\n    System.out.println(shortestPath(graph, \"A\", \"F\"));\n    System.out.println(shortestPath(graph, \"B\", \"C\"));\n  }\n}\n",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n  public static int shortestPath(Map<String, List<String>> graph, String start, String goal) {\n    Queue<String> queue = new ArrayDeque<>();\n    Map<String, Integer> distance = new HashMap<>();\n    queue.add(start);\n    distance.put(start, 0);\n    while (!queue.isEmpty()) {\n      String node = queue.poll();\n      int depth = distance.get(node);\n      if (node.equals(goal)) {\n        return depth;\n      }\n      for (String neighbor : graph.getOrDefault(node, Collections.emptyList())) {\n        if (!distance.containsKey(neighbor)) {\n          distance.put(neighbor, depth + 1);\n          queue.add(neighbor);\n        }\n      }\n    }\n    return -1;\n  }\n\n  public static void main(String[] args) {\n    Map<String, List<String>> graph = new HashMap<>();\n    graph.put(\"A\", Arrays.asList(\"B\", \"C\"));\n    graph.put(\"B\", Arrays.asList(\"D\", \"E\"));\n    graph.put(\"C\", Arrays.asList(\"F\"));\n    graph.put(\"D\", Collections.emptyList());\n    graph.put(\"E\", Arrays.asList(\"F\"));\n    graph.put(\"F\", Collections.emptyList());\n\n    System.out.println(shortestPath(graph, \"A\", \"F\"));\n    System.out.println(shortestPath(graph, \"B\", \"C\"));\n  }\n}\n",
      "expectedOutput": "2\n-1",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Breadth-first search uses a queue so nodes are processed in increasing distance. The first time you reach the goal, you have the minimal hop count.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Snippet:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Queue<String> queue = new ArrayDeque<>();</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding bfs shortest path is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying bfs shortest path, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply bfs shortest path will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with bfs shortest path, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 241,
      "title": "241. Dijkstra Shortest Path Cost",
      "language": "java",
      "description": "Return the minimal traversal cost between two nodes using Dijkstra's algorithm.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n  static class Node {\n    final String name;\n    final int weight;\n\n    Node(String name, int weight) {\n      this.name = name;\n      this.weight = weight;\n    }\n  }\n\n  public static int dijkstra(Map<String, List<Node>> graph, String start, String goal) {\n    // TODO: compute minimal cost or Integer.MAX_VALUE if unreachable\n    return Integer.MAX_VALUE;\n  }\n\n  public static void main(String[] args) {\n    Map<String, List<Node>> graph = new HashMap<>();\n    graph.put(\"A\", Arrays.asList(new Node(\"B\", 1), new Node(\"C\", 4)));\n    graph.put(\"B\", Arrays.asList(new Node(\"C\", 2), new Node(\"D\", 5)));\n    graph.put(\"C\", Arrays.asList(new Node(\"D\", 1)));\n    graph.put(\"D\", Arrays.asList(new Node(\"E\", 3)));\n    graph.put(\"E\", Collections.emptyList());\n\n    System.out.println(dijkstra(graph, \"A\", \"E\"));\n  }\n}\n",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n  static class Node {\n    final String name;\n    final int weight;\n\n    Node(String name, int weight) {\n      this.name = name;\n      this.weight = weight;\n    }\n  }\n\n  static class State {\n    final String name;\n    final int cost;\n\n    State(String name, int cost) {\n      this.name = name;\n      this.cost = cost;\n    }\n  }\n\n  public static int dijkstra(Map<String, List<Node>> graph, String start, String goal) {\n    PriorityQueue<State> pq = new PriorityQueue<>(Comparator.comparingInt(s -> s.cost));\n    Map<String, Integer> dist = new HashMap<>();\n    pq.add(new State(start, 0));\n    dist.put(start, 0);\n    while (!pq.isEmpty()) {\n      State current = pq.poll();\n      if (current.cost > dist.getOrDefault(current.name, Integer.MAX_VALUE)) {\n        continue;\n      }\n      if (current.name.equals(goal)) {\n        return current.cost;\n      }\n      for (Node edge : graph.getOrDefault(current.name, Collections.emptyList())) {\n        int newCost = current.cost + edge.weight;\n        if (newCost < dist.getOrDefault(edge.name, Integer.MAX_VALUE)) {\n          dist.put(edge.name, newCost);\n          pq.add(new State(edge.name, newCost));\n        }\n      }\n    }\n    return Integer.MAX_VALUE;\n  }\n\n  public static void main(String[] args) {\n    Map<String, List<Node>> graph = new HashMap<>();\n    graph.put(\"A\", Arrays.asList(new Node(\"B\", 1), new Node(\"C\", 4)));\n    graph.put(\"B\", Arrays.asList(new Node(\"C\", 2), new Node(\"D\", 5)));\n    graph.put(\"C\", Arrays.asList(new Node(\"D\", 1)));\n    graph.put(\"D\", Arrays.asList(new Node(\"E\", 3)));\n    graph.put(\"E\", Collections.emptyList());\n\n    System.out.println(dijkstra(graph, \"A\", \"E\"));\n  }\n}\n",
      "expectedOutput": "7",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use a priority queue ordered by path cost. When you pop a state you have the best known distance; relaxing neighbors may push improved routes.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Snippet:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">PriorityQueue<State> pq = new PriorityQueue<>(Comparator.comparingInt(s -> s.cost));</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding dijkstra shortest path cost is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying dijkstra shortest path cost, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply dijkstra shortest path cost will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with dijkstra shortest path cost, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 242,
      "title": "242. LRU Cache with LinkedHashMap",
      "language": "java",
      "description": "Implement a fixed-size LRU cache by extending LinkedHashMap with access-order enabled.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n  static class LRUCache<K, V> extends LinkedHashMap<K, V> {\n    private final int capacity;\n\n    LRUCache(int capacity) {\n      super(capacity, 0.75f, true);\n      this.capacity = capacity;\n    }\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n      // TODO: evict when size exceeds capacity\n      return false;\n    }\n  }\n\n  public static void main(String[] args) {\n    LRUCache<String, String> cache = new LRUCache<>(2);\n    cache.put(\"user:1\", \"alice\");\n    cache.put(\"user:2\", \"bob\");\n    System.out.println(cache.getOrDefault(\"user:1\", \"-1\"));\n    cache.put(\"user:3\", \"charlie\");\n    System.out.println(cache.getOrDefault(\"user:2\", \"-1\"));\n    System.out.println(cache.getOrDefault(\"user:3\", \"-1\"));\n  }\n}\n",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n  static class LRUCache<K, V> extends LinkedHashMap<K, V> {\n    private final int capacity;\n\n    LRUCache(int capacity) {\n      super(capacity, 0.75f, true);\n      this.capacity = capacity;\n    }\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n      return size() > capacity;\n    }\n  }\n\n  public static void main(String[] args) {\n    LRUCache<String, String> cache = new LRUCache<>(2);\n    cache.put(\"user:1\", \"alice\");\n    cache.put(\"user:2\", \"bob\");\n    System.out.println(cache.getOrDefault(\"user:1\", \"-1\"));\n    cache.put(\"user:3\", \"charlie\");\n    System.out.println(cache.getOrDefault(\"user:2\", \"-1\"));\n    System.out.println(cache.getOrDefault(\"user:3\", \"-1\"));\n  }\n}\n",
      "expectedOutput": "alice\n-1\ncharlie",
      "tutorial": "<p class=\"mb-4 text-gray-300\">LinkedHashMap with accessOrder=true keeps entries ordered by recent use. Overriding removeEldestEntry provides constant-time eviction when the cache grows beyond capacity.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Snippet:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">protected boolean removeEldestEntry(...) {\n  return size() > capacity;\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding lru cache with linkedhashmap is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying lru cache with linkedhashmap, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply lru cache with linkedhashmap will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with lru cache with linkedhashmap, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "OOP",
        "Security"
      ]
    },
    {
      "id": 243,
      "title": "243. Dynamic Programming: Min Coins",
      "language": "java",
      "description": "Return the minimum number of coins required to make up a target amount, or -1 when impossible.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n  public static int minCoins(int amount, int[] coins) {\n    // TODO: bottom-up DP to compute the fewest coins\n    return -1;\n  }\n\n  public static void main(String[] args) {\n    System.out.println(minCoins(11, new int[]{1, 2, 5}));\n    System.out.println(minCoins(3, new int[]{2}));\n  }\n}\n",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n  public static int minCoins(int amount, int[] coins) {\n    int[] dp = new int[amount + 1];\n    Arrays.fill(dp, amount + 1);\n    dp[0] = 0;\n    for (int coin : coins) {\n      for (int value = coin; value <= amount; value++) {\n        dp[value] = Math.min(dp[value], dp[value - coin] + 1);\n      }\n    }\n    return dp[amount] > amount ? -1 : dp[amount];\n  }\n\n  public static void main(String[] args) {\n    System.out.println(minCoins(11, new int[]{1, 2, 5}));\n    System.out.println(minCoins(3, new int[]{2}));\n  }\n}\n",
      "expectedOutput": "3\n-1",
      "tutorial": "<p class=\"mb-4 text-gray-300\">dp[value] holds the minimum coins for that value. Each coin lets you improve later amounts based on an already-solved subproblem.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Snippet:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">dp[value] = Math.min(dp[value], dp[value - coin] + 1);</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding dynamic programming: min coins is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying dynamic programming: min coins, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply dynamic programming: min coins will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with dynamic programming: min coins, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 244,
      "title": "244. Dynamic Programming: LIS Length",
      "language": "java",
      "description": "Compute the length of the longest increasing subsequence in O(n log n) time.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n  public static int lisLength(int[] nums) {\n    // TODO: maintain tails and use binary search\n    return 0;\n  }\n\n  public static void main(String[] args) {\n    System.out.println(lisLength(new int[]{10, 9, 2, 5, 3, 7, 101, 18}));\n    System.out.println(lisLength(new int[]{7, 7, 7, 7, 7}));\n  }\n}\n",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n  public static int lisLength(int[] nums) {\n    List<Integer> tails = new ArrayList<>();\n    for (int num : nums) {\n      int idx = Collections.binarySearch(tails, num);\n      if (idx < 0) {\n        idx = -(idx + 1);\n      }\n      if (idx == tails.size()) {\n        tails.add(num);\n      } else {\n        tails.set(idx, num);\n      }\n    }\n    return tails.size();\n  }\n\n  public static void main(String[] args) {\n    System.out.println(lisLength(new int[]{10, 9, 2, 5, 3, 7, 101, 18}));\n    System.out.println(lisLength(new int[]{7, 7, 7, 7, 7}));\n  }\n}\n",
      "expectedOutput": "4\n1",
      "tutorial": "<p class=\"mb-4 text-gray-300\">The tails list stores the smallest possible tail for a subsequence of each length. Binary search finds where each number fits, replacing larger tails.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Snippet:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">int idx = Collections.binarySearch(tails, num);</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding dynamic programming: lis length is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying dynamic programming: lis length, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply dynamic programming: lis length will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with dynamic programming: lis length, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 245,
      "title": "245. System Design: Read-Heavy Scale Plan",
      "language": "java",
      "description": "Print the scale plan for a read-heavy service, covering data, cache, async pipelines, and observability.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Map<String, Object> plan = new LinkedHashMap<>();\n    plan.put(\"service\", \"ProductCatalog\");\n    plan.put(\"traffic\", \"120k req/s peak\");\n    plan.put(\"primary\", \"PostgreSQL with read replicas\");\n    plan.put(\"cache\", \"Redis cluster (sharded)\");\n    plan.put(\"async\", Arrays.asList(\"Kafka event bus\", \"Inventory projector\"));\n    plan.put(\"observability\", Arrays.asList(\"Red metrics dashboard\", \"Trace sampling 15%\"));\n\n    // TODO: print the plan in the exact format described below\n  }\n}\n",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Map<String, Object> plan = new LinkedHashMap<>();\n    plan.put(\"service\", \"ProductCatalog\");\n    plan.put(\"traffic\", \"120k req/s peak\");\n    plan.put(\"primary\", \"PostgreSQL with read replicas\");\n    plan.put(\"cache\", \"Redis cluster (sharded)\");\n    plan.put(\"async\", Arrays.asList(\"Kafka event bus\", \"Inventory projector\"));\n    plan.put(\"observability\", Arrays.asList(\"Red metrics dashboard\", \"Trace sampling 15%\"));\n\n    System.out.println(plan.get(\"service\") + \" Service Scale Plan\");\n    System.out.println(\"Peak load: \" + plan.get(\"traffic\"));\n    System.out.println(\"Primary store: \" + plan.get(\"primary\"));\n    System.out.println(\"Cache: \" + plan.get(\"cache\"));\n    System.out.println(\"Async pipelines:\");\n    for (String item : (List<String>) plan.get(\"async\")) {\n      System.out.println(\"- \" + item);\n    }\n    System.out.println(\"Observability:\");\n    for (String item : (List<String>) plan.get(\"observability\")) {\n      System.out.println(\"- \" + item);\n    }\n  }\n}\n",
      "expectedOutput": "ProductCatalog Service Scale Plan\nPeak load: 120k req/s peak\nPrimary store: PostgreSQL with read replicas\nCache: Redis cluster (sharded)\nAsync pipelines:\n- Kafka event bus\n- Inventory projector\nObservability:\n- Red metrics dashboard\n- Trace sampling 15%",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Executives want the architecture story grouped by capability. Lead with the service name, then cover load, persistence, cache, async workers, and observability.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Snippet:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"Async pipelines:\");</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding system design: read-heavy scale plan is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying system design: read-heavy scale plan, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply system design: read-heavy scale plan will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with system design: read-heavy scale plan, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Strings",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 246,
      "title": "246. Database Scaling Playbook",
      "language": "java",
      "description": "Print a stepwise database scaling playbook with observability guardrails.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    List<String> steps = Arrays.asList(\n        \"Add read replicas for reporting\",\n        \"Shard tenants by region\",\n        \"Introduce write-ahead queue for spikes\"\n    );\n    List<String> observability = Arrays.asList(\n        \"Slow query log sampled 1%\",\n        \"Replication lag alert at 30s\"\n    );\n\n    // TODO: print the playbook exactly as described\n  }\n}\n",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    List<String> steps = Arrays.asList(\n        \"Add read replicas for reporting\",\n        \"Shard tenants by region\",\n        \"Introduce write-ahead queue for spikes\"\n    );\n    List<String> observability = Arrays.asList(\n        \"Slow query log sampled 1%\",\n        \"Replication lag alert at 30s\"\n    );\n\n    System.out.println(\"Database Scaling Playbook\");\n    for (int i = 0; i < steps.size(); i++) {\n      System.out.println((i + 1) + \". \" + steps.get(i));\n    }\n    System.out.println(\"Observability:\");\n    for (String item : observability) {\n      System.out.println(\"- \" + item);\n    }\n  }\n}\n",
      "expectedOutput": "Database Scaling Playbook\n1. Add read replicas for reporting\n2. Shard tenants by region\n3. Introduce write-ahead queue for spikes\nObservability:\n- Slow query log sampled 1%\n- Replication lag alert at 30s",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Enumerate scaling moves in order and make the safety checks explicit so operations can verify readiness at each phase.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Snippet:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">for (int i = 0; i < steps.size(); i++) {\n  System.out.println((i + 1) + \". \" + steps.get(i));\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding database scaling playbook is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying database scaling playbook, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply database scaling playbook will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with database scaling playbook, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Databases"
      ]
    },
    {
      "id": 247,
      "title": "247. Security Threat Modeling Summary",
      "language": "java",
      "description": "Summarize the threat model for the payments API, covering entry points, threats, and mitigations.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    List<String> entryPoints = Arrays.asList(\"Public REST gateway\", \"Admin console\");\n    List<String> threats = Arrays.asList(\"Replay attacks\", \"Privilege escalation\", \"Secrets exfiltration\");\n    List<String> mitigations = Arrays.asList(\"Idempotency keys\", \"Fine-grained RBAC\", \"Vault auto-rotation\");\n\n    // TODO: print the summary in the exact format described\n  }\n}\n",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    List<String> entryPoints = Arrays.asList(\"Public REST gateway\", \"Admin console\");\n    List<String> threats = Arrays.asList(\"Replay attacks\", \"Privilege escalation\", \"Secrets exfiltration\");\n    List<String> mitigations = Arrays.asList(\"Idempotency keys\", \"Fine-grained RBAC\", \"Vault auto-rotation\");\n\n    System.out.println(\"Payments API Threat Model\");\n    System.out.println(\"Entry points:\");\n    for (String item : entryPoints) {\n      System.out.println(\"- \" + item);\n    }\n    System.out.println(\"Key threats:\");\n    for (String threat : threats) {\n      System.out.println(\"- \" + threat);\n    }\n    System.out.println(\"Mitigations:\");\n    for (String mitigation : mitigations) {\n      System.out.println(\"- \" + mitigation);\n    }\n  }\n}\n",
      "expectedOutput": "Payments API Threat Model\nEntry points:\n- Public REST gateway\n- Admin console\nKey threats:\n- Replay attacks\n- Privilege escalation\n- Secrets exfiltration\nMitigations:\n- Idempotency keys\n- Fine-grained RBAC\n- Vault auto-rotation",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Threat models communicate where attacks land and which controls stop them. Keep each section short so it is easy to review.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Snippet:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"Mitigations:\");</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding security threat modeling summary is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying security threat modeling summary, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply security threat modeling summary will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with security threat modeling summary, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Strings",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 248,
      "title": "248. Edge & CDN Strategy Snapshot",
      "language": "java",
      "description": "Print the key configuration choices for an edge delivery and CDN strategy.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    String provider = \"CloudFront multi-region\";\n    String ttl = \"120s default\";\n    String originShield = \"Enabled\";\n    List<String> regions = Arrays.asList(\"us-east-1\", \"eu-west-1\", \"ap-southeast-1\");\n    List<String> failover = Arrays.asList(\"Health check every 30s\", \"Multi-origin failover policy\");\n\n    // TODO: print the snapshot exactly as described\n  }\n}\n",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    String provider = \"CloudFront multi-region\";\n    String ttl = \"120s default\";\n    String originShield = \"Enabled\";\n    List<String> regions = Arrays.asList(\"us-east-1\", \"eu-west-1\", \"ap-southeast-1\");\n    List<String> failover = Arrays.asList(\"Health check every 30s\", \"Multi-origin failover policy\");\n\n    System.out.println(\"Edge Delivery Strategy\");\n    System.out.println(\"CDN provider: \" + provider);\n    System.out.println(\"Cache TTL: \" + ttl);\n    System.out.println(\"Origin shield: \" + originShield);\n    System.out.println(\"Regional edge cache:\");\n    for (String region : regions) {\n      System.out.println(\"- \" + region);\n    }\n    System.out.println(\"Failover:\");\n    for (String item : failover) {\n      System.out.println(\"- \" + item);\n    }\n  }\n}\n",
      "expectedOutput": "Edge Delivery Strategy\nCDN provider: CloudFront multi-region\nCache TTL: 120s default\nOrigin shield: Enabled\nRegional edge cache:\n- us-east-1\n- eu-west-1\n- ap-southeast-1\nFailover:\n- Health check every 30s\n- Multi-origin failover policy",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Edge configurations should spell out provider, TTLs, shielding, regional coverage, and failover so delivery teams can validate the setup.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Snippet:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"Regional edge cache:\");</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding edge & cdn strategy snapshot is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying edge & cdn strategy snapshot, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply edge & cdn strategy snapshot will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with edge & cdn strategy snapshot, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 249,
      "title": "249. Event Pipeline Case Study",
      "language": "java",
      "description": "Summarize the multi-region fanout architecture using the provided map.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Map<String, Object> scenario = new LinkedHashMap<>();\n    scenario.put(\"service\", \"SocialFeedFanout\");\n    scenario.put(\"regions\", Arrays.asList(\"us-east-1\", \"eu-west-1\"));\n    scenario.put(\"ingest_rate\", \"85k events/s avg\");\n    scenario.put(\"queue\", \"Kafka (24 partitions)\");\n    scenario.put(\"fanout\", \"Go workers push to Redis channels\");\n    scenario.put(\"persistence\", Arrays.asList(\"Aurora followers table\", \"S3 activity log\"));\n    scenario.put(\"observability\", Arrays.asList(\"Lag dashboard < 2s\", \"Fanout error budget 0.2%\"));\n\n    // TODO: print the summary exactly as:\n    // SocialFeedFanout Event Pipeline\n    // Ingest rate: 85k events/s avg\n    // Regions: us-east-1, eu-west-1\n    // Queue: Kafka (24 partitions)\n    // Fanout workers: Go workers push to Redis channels\n    // Persistence:\n    // - Aurora followers table\n    // - S3 activity log\n    // Observability:\n    // - Lag dashboard < 2s\n    // - Fanout error budget 0.2%\n  }\n}\n",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Map<String, Object> scenario = new LinkedHashMap<>();\n    scenario.put(\"service\", \"SocialFeedFanout\");\n    scenario.put(\"regions\", Arrays.asList(\"us-east-1\", \"eu-west-1\"));\n    scenario.put(\"ingest_rate\", \"85k events/s avg\");\n    scenario.put(\"queue\", \"Kafka (24 partitions)\");\n    scenario.put(\"fanout\", \"Go workers push to Redis channels\");\n    scenario.put(\"persistence\", Arrays.asList(\"Aurora followers table\", \"S3 activity log\"));\n    scenario.put(\"observability\", Arrays.asList(\"Lag dashboard < 2s\", \"Fanout error budget 0.2%\"));\n\n    System.out.println(scenario.get(\"service\") + \" Event Pipeline\");\n    System.out.println(\"Ingest rate: \" + scenario.get(\"ingest_rate\"));\n    System.out.println(\"Regions: \" + String.join(\", \", (List<String>) scenario.get(\"regions\")));\n    System.out.println(\"Queue: \" + scenario.get(\"queue\"));\n    System.out.println(\"Fanout workers: \" + scenario.get(\"fanout\"));\n    System.out.println(\"Persistence:\");\n    for (String item : (List<String>) scenario.get(\"persistence\")) {\n      System.out.println(\"- \" + item);\n    }\n    System.out.println(\"Observability:\");\n    for (String item : (List<String>) scenario.get(\"observability\")) {\n      System.out.println(\"- \" + item);\n    }\n  }\n}\n",
      "expectedOutput": "SocialFeedFanout Event Pipeline\nIngest rate: 85k events/s avg\nRegions: us-east-1, eu-west-1\nQueue: Kafka (24 partitions)\nFanout workers: Go workers push to Redis channels\nPersistence:\n- Aurora followers table\n- S3 activity log\nObservability:\n- Lag dashboard < 2s\n- Fanout error budget 0.2%",
      "tutorial": "<p class=\"mb-4 text-gray-300\">A concise Java printout can still communicate architecture fundamentals-surface throughput, regions, persistence, and telemetry in one go.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"Observability:\");</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding event pipeline case study is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying event pipeline case study, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply event pipeline case study will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with event pipeline case study, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Security"
      ]
    },
    {
      "id": 250,
      "title": "250. Capacity Planning Calculator",
      "language": "java",
      "description": "Compute the number of servers required for peak and average loads with redundancy.",
      "initialCode": "import java.lang.Math;\n\npublic class Main {\n  public static void main(String[] args) {\n    double requestsPeak = 180_000;\n    double requestsAvg = 90_000;\n    double tpsPerServer = 4_500;\n    double redundancyFactor = 1.25;\n\n    // TODO: compute Math.ceil((load / tpsPerServer) * redundancyFactor) for peak and average.\n    // Print exactly:\n    // Peak servers needed: 50\n    // Average servers needed: 25\n  }\n}\n",
      "fullSolution": "import java.lang.Math;\n\npublic class Main {\n  public static void main(String[] args) {\n    double requestsPeak = 180_000;\n    double requestsAvg = 90_000;\n    double tpsPerServer = 4_500;\n    double redundancyFactor = 1.25;\n\n    int peakServers = (int) Math.ceil((requestsPeak / tpsPerServer) * redundancyFactor);\n    int avgServers = (int) Math.ceil((requestsAvg / tpsPerServer) * redundancyFactor);\n\n    System.out.println(\"Peak servers needed: \" + peakServers);\n    System.out.println(\"Average servers needed: \" + avgServers);\n  }\n}\n",
      "expectedOutput": "Peak servers needed: 50\nAverage servers needed: 25",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Capacity math is language-agnostic-translate TPS into host counts, apply redundancy, and round up so failure domains stay healthy.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Formula:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">(int) Math.ceil((load / tpsPerServer) * redundancyFactor)</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding capacity planning calculator is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying capacity planning calculator, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply capacity planning calculator will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with capacity planning calculator, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "OOP",
        "Math and Stats",
        "Networking"
      ]
    },
    {
      "id": 251,
      "title": "251. Global Cache Strategy Brief",
      "language": "java",
      "description": "Print the cache architecture decision in the required format.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Map<String, Object> decision = new LinkedHashMap<>();\n    decision.put(\"mode\", \"Read-through cache with regional write-behind\");\n    decision.put(\"primaries\", Arrays.asList(\"us-east-1 primary\", \"ap-southeast-1 primary\"));\n    decision.put(\"consistency\", \"Multi-region eventual\");\n    decision.put(\"mitigations\", Arrays.asList(\"Versioned writes\", \"Conflict alarms 5/min\"));\n    decision.put(\"fallback\", \"Read from regional replica when cache miss > 150ms\");\n\n    // TODO: print exactly:\n    // Global Cache Strategy\n    // Mode: ...\n    // Primaries: us-east-1 primary, ap-southeast-1 primary\n    // Consistency: Multi-region eventual\n    // Mitigations:\n    // - Versioned writes\n    // - Conflict alarms 5/min\n    // Fallback: Read from regional replica when cache miss > 150ms\n  }\n}\n",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Map<String, Object> decision = new LinkedHashMap<>();\n    decision.put(\"mode\", \"Read-through cache with regional write-behind\");\n    decision.put(\"primaries\", Arrays.asList(\"us-east-1 primary\", \"ap-southeast-1 primary\"));\n    decision.put(\"consistency\", \"Multi-region eventual\");\n    decision.put(\"mitigations\", Arrays.asList(\"Versioned writes\", \"Conflict alarms 5/min\"));\n    decision.put(\"fallback\", \"Read from regional replica when cache miss > 150ms\");\n\n    System.out.println(\"Global Cache Strategy\");\n    System.out.println(\"Mode: \" + decision.get(\"mode\"));\n    System.out.println(\"Primaries: \" + String.join(\", \", (List<String>) decision.get(\"primaries\")));\n    System.out.println(\"Consistency: \" + decision.get(\"consistency\"));\n    System.out.println(\"Mitigations:\");\n    for (String item : (List<String>) decision.get(\"mitigations\")) {\n      System.out.println(\"- \" + item);\n    }\n    System.out.println(\"Fallback: \" + decision.get(\"fallback\"));\n  }\n}\n",
      "expectedOutput": "Global Cache Strategy\nMode: Read-through cache with regional write-behind\nPrimaries: us-east-1 primary, ap-southeast-1 primary\nConsistency: Multi-region eventual\nMitigations:\n- Versioned writes\n- Conflict alarms 5/min\nFallback: Read from regional replica when cache miss > 150ms",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Clarify cache patterns, ownership, and safety nets so partners understand how consistency is maintained across regions.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Reminder:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"Mitigations:\");</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding global cache strategy brief is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying global cache strategy brief, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply global cache strategy brief will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with global cache strategy brief, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Strings",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 252,
      "title": "252. JVM Profiling Runbook",
      "language": "java",
      "description": "Present the JVM profiling commands as an ordered checklist.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Map<String, Object> runbook = new LinkedHashMap<>();\n    runbook.put(\"heap\", \"jcmd 4123 GC.heap_info\");\n    runbook.put(\"async\", Arrays.asList(\n        \"async-profiler -e cpu -d 30 -f /tmp/profile.svg 4123\",\n        \"svgopen /tmp/profile.svg\"\n    ));\n    runbook.put(\"jfr\", \"jfr start name=prod settings=profile delay=5s duration=60s filename=profile.jfr\");\n    runbook.put(\"sampling\", \"jcmd 4123 Thread.print\");\n\n    // TODO: print exactly:\n    // JVM Performance Profiling\n    // Heap: jcmd 4123 GC.heap_info\n    // Async profiler:\n    // - async-profiler -e cpu -d 30 -f /tmp/profile.svg 4123\n    // - svgopen /tmp/profile.svg\n    // Flight Recorder: jfr start name=prod settings=profile delay=5s duration=60s filename=profile.jfr\n    // Sampling: jcmd 4123 Thread.print\n  }\n}\n",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Map<String, Object> runbook = new LinkedHashMap<>();\n    runbook.put(\"heap\", \"jcmd 4123 GC.heap_info\");\n    runbook.put(\"async\", Arrays.asList(\n        \"async-profiler -e cpu -d 30 -f /tmp/profile.svg 4123\",\n        \"svgopen /tmp/profile.svg\"\n    ));\n    runbook.put(\"jfr\", \"jfr start name=prod settings=profile delay=5s duration=60s filename=profile.jfr\");\n    runbook.put(\"sampling\", \"jcmd 4123 Thread.print\");\n\n    System.out.println(\"JVM Performance Profiling\");\n    System.out.println(\"Heap: \" + runbook.get(\"heap\"));\n    System.out.println(\"Async profiler:\");\n    for (String step : (List<String>) runbook.get(\"async\")) {\n      System.out.println(\"- \" + step);\n    }\n    System.out.println(\"Flight Recorder: \" + runbook.get(\"jfr\"));\n    System.out.println(\"Sampling: \" + runbook.get(\"sampling\"));\n  }\n}\n",
      "expectedOutput": "JVM Performance Profiling\nHeap: jcmd 4123 GC.heap_info\nAsync profiler:\n- async-profiler -e cpu -d 30 -f /tmp/profile.svg 4123\n- svgopen /tmp/profile.svg\nFlight Recorder: jfr start name=prod settings=profile delay=5s duration=60s filename=profile.jfr\nSampling: jcmd 4123 Thread.print",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Have heap stats, async-profiler, and JFR commands pre-baked so JVM incidents move straight to evidence gathering.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Snippet:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">for (String step : (List<String>) runbook.get(\"async\")) {\n  System.out.println(\"- \" + step);\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding jvm profiling runbook is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying jvm profiling runbook, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply jvm profiling runbook will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with jvm profiling runbook, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 253,
      "title": "253. Network Diagnostics Checklist",
      "language": "java",
      "description": "Print the network investigation commands in order.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Map<String, String> checks = new LinkedHashMap<>();\n    checks.put(\"Latency\", \"mtr --report 10 api.prod\");\n    checks.put(\"Packet capture\", \"sudo tcpdump -ni eth0 host 203.0.113.8\");\n    checks.put(\"DNS\", \"dig +trace api.prod\");\n    checks.put(\"HTTP timing\", \"curl -w '\\nconnect: %{time_connect}s total: %{time_total}s\\n' https://api.prod/health\");\n\n    // TODO: print exactly:\n    // Network Diagnostics Checklist\n    // Latency: mtr --report 10 api.prod\n    // Packet capture: sudo tcpdump -ni eth0 host 203.0.113.8\n    // DNS: dig +trace api.prod\n    // HTTP timing: curl -w '\nconnect: %{time_connect}s total: %{time_total}s\n' https://api.prod/health\n  }\n}\n",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Map<String, String> checks = new LinkedHashMap<>();\n    checks.put(\"Latency\", \"mtr --report 10 api.prod\");\n    checks.put(\"Packet capture\", \"sudo tcpdump -ni eth0 host 203.0.113.8\");\n    checks.put(\"DNS\", \"dig +trace api.prod\");\n    checks.put(\"HTTP timing\", \"curl -w '\\nconnect: %{time_connect}s total: %{time_total}s\\n' https://api.prod/health\");\n\n    System.out.println(\"Network Diagnostics Checklist\");\n    for (Map.Entry<String, String> entry : checks.entrySet()) {\n      System.out.println(entry.getKey() + \": \" + entry.getValue());\n    }\n  }\n}\n",
      "expectedOutput": "Network Diagnostics Checklist\nLatency: mtr --report 10 api.prod\nPacket capture: sudo tcpdump -ni eth0 host 203.0.113.8\nDNS: dig +trace api.prod\nHTTP timing: curl -w '\nconnect: %{time_connect}s total: %{time_total}s\n' https://api.prod/health",
      "tutorial": "<p class=\"mb-4 text-gray-300\">A predictable checklist keeps network triage focused-latency, captures, DNS, and HTTP timing cover the common failure angles.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">for (Map.Entry<String, String> entry : checks.entrySet()) {\n  System.out.println(entry.getKey() + \": \" + entry.getValue());\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding network diagnostics checklist is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying network diagnostics checklist, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply network diagnostics checklist will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with network diagnostics checklist, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Networking"
      ]
    },
    {
      "id": 254,
      "title": "254. Behavioral Story Outline: Incident Leadership",
      "language": "java",
      "description": "Turn the STAR components into a structured incident leadership story.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Map<String, Object> story = new LinkedHashMap<>();\n    story.put(\"situation\", \"Peak sale traffic saturated checkout service\");\n    story.put(\"task\", \"Restore cart checkout under 10 minutes\");\n    story.put(\"actions\", Arrays.asList(\n        \"Declared incident and spun up war room\",\n        \"Throttled recommendation calls at ingress\",\n        \"Coordinated rollback of faulty feature flag\"\n    ));\n    story.put(\"result\", \"Checkout error rate dropped from 35% to 1.2% in 7 minutes\");\n\n    // TODO: print exactly:\n    // STAR Incident Leadership Story\n    // Situation: Peak sale traffic saturated checkout service\n    // Task: Restore cart checkout under 10 minutes\n    // Actions:\n    // - Declared incident and spun up war room\n    // - Throttled recommendation calls at ingress\n    // - Coordinated rollback of faulty feature flag\n    // Result: Checkout error rate dropped from 35% to 1.2% in 7 minutes\n  }\n}\n",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Map<String, Object> story = new LinkedHashMap<>();\n    story.put(\"situation\", \"Peak sale traffic saturated checkout service\");\n    story.put(\"task\", \"Restore cart checkout under 10 minutes\");\n    story.put(\"actions\", Arrays.asList(\n        \"Declared incident and spun up war room\",\n        \"Throttled recommendation calls at ingress\",\n        \"Coordinated rollback of faulty feature flag\"\n    ));\n    story.put(\"result\", \"Checkout error rate dropped from 35% to 1.2% in 7 minutes\");\n\n    System.out.println(\"STAR Incident Leadership Story\");\n    System.out.println(\"Situation: \" + story.get(\"situation\"));\n    System.out.println(\"Task: \" + story.get(\"task\"));\n    System.out.println(\"Actions:\");\n    for (String action : (List<String>) story.get(\"actions\")) {\n      System.out.println(\"- \" + action);\n    }\n    System.out.println(\"Result: \" + story.get(\"result\"));\n  }\n}\n",
      "expectedOutput": "STAR Incident Leadership Story\nSituation: Peak sale traffic saturated checkout service\nTask: Restore cart checkout under 10 minutes\nActions:\n- Declared incident and spun up war room\n- Throttled recommendation calls at ingress\n- Coordinated rollback of faulty feature flag\nResult: Checkout error rate dropped from 35% to 1.2% in 7 minutes",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Executives listen for situational awareness, decisive action, and measurable impact-STAR keeps the story sharp.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Template:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"Actions:\");</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding behavioral story outline: incident leadership is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying behavioral story outline: incident leadership, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply behavioral story outline: incident leadership will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with behavioral story outline: incident leadership, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Web"
      ]
    },
    {
      "id": 255,
      "title": "255. SQL SELECT Builder: Active Customers",
      "description": "Build a SELECT statement string using the provided columns, table, predicate, and order clause.",
      "initialCode": "import java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> columns = List.of(\"id\", \"email\", \"tier\");\n        String table = \"customers\";\n        String predicate = \"status = 'ACTIVE'\";\n        String orderBy = \"last_login DESC\";\n\n        // TODO: build and print the SELECT statement shown in the instructions\n    }\n}\n",
      "fullSolution": "import java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> columns = List.of(\"id\", \"email\", \"tier\");\n        String table = \"customers\";\n        String predicate = \"status = 'ACTIVE'\";\n        String orderBy = \"last_login DESC\";\n\n        String select = String.join(\", \", columns);\n        String statement = \"SELECT \" + select + \" FROM \" + table\n                + \" WHERE \" + predicate + \" ORDER BY \" + orderBy + \";\";\n        System.out.println(statement);\n    }\n}\n",
      "expectedOutput": "SELECT id, email, tier FROM customers WHERE status = 'ACTIVE' ORDER BY last_login DESC;",
      "tutorial": "<p class=\"mb-4 text-gray-300\">A SELECT statement needs to spell out columns, the table, filters, and sort order. Commas separate selected columns, while clauses like WHERE and ORDER BY fine-tune results.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">SELECT id, email FROM customers WHERE status = 'ACTIVE' ORDER BY last_login DESC;</pre></div><p class=\"mt-4 text-gray-300\">Combine the provided values into one SQL statement and end it with a semicolon.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding sql select builder: active customers is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying sql select builder: active customers, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply sql select builder: active customers will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with sql select builder: active customers, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Advanced",
        "Control Flow",
        "Strings",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 256,
      "title": "256. SQL JOIN Builder: Orders + Payments",
      "description": "Format a multi-line SQL query that joins orders to customers and payments with the supplied segments.",
      "initialCode": "import java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> select = List.of(\"o.id\", \"o.total\", \"c.email\", \"p.status\");\n        String base = \"orders o\";\n        List<String> joins = List.of(\n                \"JOIN customers c ON c.id = o.customer_id\",\n                \"LEFT JOIN payments p ON p.order_id = o.id\"\n        );\n        List<String> filters = List.of(\"o.state = 'PAID'\", \"o.region = 'NA'\");\n\n        // TODO: print the formatted SQL join statement described in the instructions\n    }\n}\n",
      "fullSolution": "import java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> select = List.of(\"o.id\", \"o.total\", \"c.email\", \"p.status\");\n        String base = \"orders o\";\n        List<String> joins = List.of(\n                \"JOIN customers c ON c.id = o.customer_id\",\n                \"LEFT JOIN payments p ON p.order_id = o.id\"\n        );\n        List<String> filters = List.of(\"o.state = 'PAID'\", \"o.region = 'NA'\");\n\n        System.out.println(\"SELECT \" + String.join(\", \", select));\n        System.out.println(\"FROM \" + base);\n        for (String join : joins) {\n            System.out.println(join);\n        }\n        System.out.println(\"WHERE \" + String.join(\" AND \", filters) + \";\");\n    }\n}\n",
      "expectedOutput": "SELECT o.id, o.total, c.email, p.status\nFROM orders o\nJOIN customers c ON c.id = o.customer_id\nLEFT JOIN payments p ON p.order_id = o.id\nWHERE o.state = 'PAID' AND o.region = 'NA';",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Line breaks keep complex joins readable: list the SELECT columns, show the base table, then stack each JOIN and the final WHERE clause.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">SELECT o.id, o.total\nFROM orders o\nJOIN customers c ON c.id = o.customer_id;</pre></div><p class=\"mt-4 text-gray-300\">Print each segment on its own line and combine the filters with AND.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding sql join builder: orders + payments is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying sql join builder: orders + payments, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply sql join builder: orders + payments will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with sql join builder: orders + payments, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Advanced",
        "Control Flow",
        "Strings",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 257,
      "title": "257. Index Strategy Summary",
      "description": "Summarize the primary, covering, and partial indexes defined for the orders table.",
      "initialCode": "import java.util.List;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        String table = \"orders\";\n        Map<String, String> primary = Map.of(\"name\", \"orders_pkey\", \"columns\", \"id\");\n        List<Map<String, String>> covering = List.of(\n                Map.of(\"name\", \"idx_orders_state_status\", \"columns\", \"state, status\"),\n                Map.of(\"name\", \"idx_orders_customer_created\", \"columns\", \"customer_id, created_at DESC\")\n        );\n        Map<String, String> partial = Map.of(\"name\", \"idx_orders_ready\", \"definition\", \"WHERE status = 'READY_TO_SHIP'\");\n\n        // TODO: print the index strategy summary exactly as described\n    }\n}\n",
      "fullSolution": "import java.util.List;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        String table = \"orders\";\n        Map<String, String> primary = Map.of(\"name\", \"orders_pkey\", \"columns\", \"id\");\n        List<Map<String, String>> covering = List.of(\n                Map.of(\"name\", \"idx_orders_state_status\", \"columns\", \"state, status\"),\n                Map.of(\"name\", \"idx_orders_customer_created\", \"columns\", \"customer_id, created_at DESC\")\n        );\n        Map<String, String> partial = Map.of(\"name\", \"idx_orders_ready\", \"definition\", \"WHERE status = 'READY_TO_SHIP'\");\n\n        System.out.println(\"Index Strategy: \" + table);\n        System.out.println(\"Primary key: \" + primary.get(\"name\") + \" (\" + primary.get(\"columns\") + \")\");\n        System.out.println(\"Covering indexes:\");\n        for (Map<String, String> index : covering) {\n            System.out.println(\"- \" + index.get(\"name\") + \" on (\" + index.get(\"columns\") + \")\");\n        }\n        System.out.println(\"Partial index:\");\n        System.out.println(\"- \" + partial.get(\"name\") + \" \" + partial.get(\"definition\"));\n    }\n}\n",
      "expectedOutput": "Index Strategy: orders\nPrimary key: orders_pkey (id)\nCovering indexes:\n- idx_orders_state_status on (state, status)\n- idx_orders_customer_created on (customer_id, created_at DESC)\nPartial index:\n- idx_orders_ready WHERE status = 'READY_TO_SHIP'",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Senior engineers need to reason about which queries each index accelerates. Call out the primary key, covering indexes for critical filters, and any partial indexes that trim dead rows.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Primary key: orders_pkey (id)\n- idx_orders_state_status on (state, status)</pre></div><p class=\"mt-4 text-gray-300\">Format the summary with headings and bullet points so the intent of each index is obvious.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding index strategy summary is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying index strategy summary, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply index strategy summary will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with index strategy summary, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Advanced",
        "Control Flow",
        "Strings",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 258,
      "title": "258. JPA Entity Outline: Order",
      "description": "Use the provided field definitions to print a minimal JPA entity annotated for the orders table.",
      "initialCode": "import java.util.List;\n\npublic class Main {\n    record Field(String annotation, String type, String name) {}\n\n    public static void main(String[] args) {\n        List<Field> fields = List.of(\n                new Field(\"@Id\\n    @GeneratedValue\", \"Long\", \"id\"),\n                new Field(\"@Column(nullable = false)\", \"String\", \"status\"),\n                new Field(\"@Column(name = \\\"customer_id\\\")\", \"Long\", \"customerId\"),\n                new Field(\"@Column(name = \\\"total_cents\\\")\", \"Long\", \"totalCents\")\n        );\n\n        // TODO: print the JPA entity snippet exactly as described\n    }\n}\n",
      "fullSolution": "import java.util.List;\n\npublic class Main {\n    record Field(String annotation, String type, String name) {}\n\n    public static void main(String[] args) {\n        List<Field> fields = List.of(\n                new Field(\"@Id\\n    @GeneratedValue\", \"Long\", \"id\"),\n                new Field(\"@Column(nullable = false)\", \"String\", \"status\"),\n                new Field(\"@Column(name = \\\"customer_id\\\")\", \"Long\", \"customerId\"),\n                new Field(\"@Column(name = \\\"total_cents\\\")\", \"Long\", \"totalCents\")\n        );\n\n        System.out.println(\"@Entity\");\n        System.out.println(\"@Table(name = \\\"orders\\\")\");\n        System.out.println(\"public class Order {\");\n        for (int i = 0; i < fields.size(); i++) {\n            Field field = fields.get(i);\n            System.out.println(\"    \" + field.annotation());\n            System.out.println(\"    private \" + field.type() + \" \" + field.name() + \";\");\n            if (i < fields.size() - 1) {\n                System.out.println();\n            }\n        }\n        System.out.println(\"}\");\n    }\n}\n",
      "expectedOutput": "@Entity\n@Table(name = \"orders\")\npublic class Order {\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(nullable = false)\n    private String status;\n\n    @Column(name = \"customer_id\")\n    private Long customerId;\n\n    @Column(name = \"total_cents\")\n    private Long totalCents;\n}",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Annotating entities with @Entity and @Table makes the mapping explicit for ORMs. Keep each field's annotations aligned so constraints jump out during code review.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">@Entity\n@Table(name = \"orders\")\npublic class Order { ... }</pre></div><p class=\"mt-4 text-gray-300\">Use the supplied metadata to print the full snippet with proper indentation.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding jpa entity outline: order is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying jpa entity outline: order, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply jpa entity outline: order will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with jpa entity outline: order, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Web"
      ]
    },
    {
      "id": 259,
      "title": "259. Spring Data Repository Sketch",
      "description": "Print a repository interface with imports and query methods for the Order aggregate.",
      "initialCode": "import java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> imports = List.of(\n                \"import java.time.Instant;\",\n                \"import java.util.List;\",\n                \"import java.util.Optional;\",\n                \"import org.springframework.data.jpa.repository.JpaRepository;\",\n                \"import org.springframework.data.jpa.repository.Query;\",\n                \"import org.springframework.data.repository.query.Param;\",\n                \"import org.springframework.stereotype.Repository;\"\n        );\n        String header = \"@Repository\\npublic interface OrderRepository extends JpaRepository<Order, Long> {\";\n        List<String> methods = List.of(\n                \"    Optional<Order> findByExternalId(String externalId);\",\n                \"    List<Order> findAllByStatusIn(List<String> statuses);\",\n                \"    @Query(\\\"select o from Order o where o.createdAt < :cutoff and o.status = 'PENDING'\\\")\",\n                \"    List<Order> findStuckOrders(@Param(\\\"cutoff\\\") Instant cutoff);\"\n        );\n\n        // TODO: print imports, blank line, header, methods, then the closing brace\n    }\n}\n",
      "fullSolution": "import java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> imports = List.of(\n                \"import java.time.Instant;\",\n                \"import java.util.List;\",\n                \"import java.util.Optional;\",\n                \"import org.springframework.data.jpa.repository.JpaRepository;\",\n                \"import org.springframework.data.jpa.repository.Query;\",\n                \"import org.springframework.data.repository.query.Param;\",\n                \"import org.springframework.stereotype.Repository;\"\n        );\n        String header = \"@Repository\\npublic interface OrderRepository extends JpaRepository<Order, Long> {\";\n        List<String> methods = List.of(\n                \"    Optional<Order> findByExternalId(String externalId);\",\n                \"    List<Order> findAllByStatusIn(List<String> statuses);\",\n                \"    @Query(\\\"select o from Order o where o.createdAt < :cutoff and o.status = 'PENDING'\\\")\",\n                \"    List<Order> findStuckOrders(@Param(\\\"cutoff\\\") Instant cutoff);\"\n        );\n\n        for (String line : imports) {\n            System.out.println(line);\n        }\n        System.out.println();\n        System.out.println(header);\n        for (String method : methods) {\n            System.out.println(method);\n        }\n        System.out.println(\"}\");\n    }\n}\n",
      "expectedOutput": "import java.time.Instant;\nimport java.util.List;\nimport java.util.Optional;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic interface OrderRepository extends JpaRepository<Order, Long> {\n    Optional<Order> findByExternalId(String externalId);\n    List<Order> findAllByStatusIn(List<String> statuses);\n    @Query(\"select o from Order o where o.createdAt < :cutoff and o.status = 'PENDING'\")\n    List<Order> findStuckOrders(@Param(\"cutoff\") Instant cutoff);\n}",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Repository interfaces pull persistence operations into one place. List your imports first, then declare finder methods that match how the service layer reads data.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">public interface OrderRepository extends JpaRepository&lt;Order, Long&gt; { ... }</pre></div><p class=\"mt-4 text-gray-300\">Output the full interface including imports so the snippet is copy-paste ready.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding spring data repository sketch is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying spring data repository sketch, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply spring data repository sketch will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with spring data repository sketch, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Advanced",
        "Control Flow",
        "Functions",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 260,
      "title": "260. Transactional Service Flow",
      "description": "Lay out the ordered steps for a transactional order reservation use case.",
      "initialCode": "import java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> steps = List.of(\n                \"load order with FOR UPDATE\",\n                \"check inventory via InventoryGateway\",\n                \"reserve stock and update order status\",\n                \"publish OrderReserved event\"\n        );\n\n        // TODO: print the heading and numbered steps starting at 1\n    }\n}\n",
      "fullSolution": "import java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> steps = List.of(\n                \"load order with FOR UPDATE\",\n                \"check inventory via InventoryGateway\",\n                \"reserve stock and update order status\",\n                \"publish OrderReserved event\"\n        );\n\n        System.out.println(\"Transactional Order Flow\");\n        for (int i = 0; i < steps.size(); i++) {\n            System.out.println((i + 1) + \". \" + steps.get(i));\n        }\n    }\n}\n",
      "expectedOutput": "Transactional Order Flow\n1. load order with FOR UPDATE\n2. check inventory via InventoryGateway\n3. reserve stock and update order status\n4. publish OrderReserved event",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Mission-critical flows should spell out each transactional hop so you can reason about locking and side effects.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">1. load order with FOR UPDATE\n2. adjust state</pre></div><p class=\"mt-4 text-gray-300\">Print the numbered sequence to highlight the order of operations inside the transaction boundary.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding transactional service flow is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying transactional service flow, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply transactional service flow will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with transactional service flow, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Databases"
      ]
    },
    {
      "id": 261,
      "title": "261. Spring Security Filter Chain Plan",
      "description": "Summarize the key rules required to secure the order API.",
      "initialCode": "import java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> items = List.of(\n                \"disable CSRF for token API\",\n                \"add JWTAuthenticationFilter before UsernamePasswordAuthenticationFilter\",\n                \"require ROLE_ADMIN for POST /admin/**\",\n                \"permitAll for GET /status\"\n        );\n\n        // TODO: print the heading followed by each bullet prefixed with \"- \"\n    }\n}\n",
      "fullSolution": "import java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> items = List.of(\n                \"disable CSRF for token API\",\n                \"add JWTAuthenticationFilter before UsernamePasswordAuthenticationFilter\",\n                \"require ROLE_ADMIN for POST /admin/**\",\n                \"permitAll for GET /status\"\n        );\n\n        System.out.println(\"Security Filter Chain\");\n        for (String item : items) {\n            System.out.println(\"- \" + item);\n        }\n    }\n}\n",
      "expectedOutput": "Security Filter Chain\n- disable CSRF for token API\n- add JWTAuthenticationFilter before UsernamePasswordAuthenticationFilter\n- require ROLE_ADMIN for POST /admin/**\n- permitAll for GET /status",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Documenting the filter chain clarifies which requests are locked down versus publicly accessible.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">- require ROLE_ADMIN for POST /admin/**</pre></div><p class=\"mt-4 text-gray-300\">Keep the bullets terse so each rule is easy to scan.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding spring security filter chain plan is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying spring security filter chain plan, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply spring security filter chain plan will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with spring security filter chain plan, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Networking"
      ]
    },
    {
      "id": 262,
      "title": "262. Integration Test Checklist: Order API",
      "description": "List the container, migration, seeding, and verification steps for a full-stack test.",
      "initialCode": "import java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> tasks = List.of(\n                \"start PostgreSQL Testcontainer\",\n                \"apply schema migrations\",\n                \"seed reference products\",\n                \"call POST /orders\",\n                \"assert 201 status and location header\",\n                \"query database for saved order\"\n        );\n\n        // TODO: print the heading and each bullet prefixed with \"- \"\n    }\n}\n",
      "fullSolution": "import java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> tasks = List.of(\n                \"start PostgreSQL Testcontainer\",\n                \"apply schema migrations\",\n                \"seed reference products\",\n                \"call POST /orders\",\n                \"assert 201 status and location header\",\n                \"query database for saved order\"\n        );\n\n        System.out.println(\"Integration Test Checklist\");\n        for (String task : tasks) {\n            System.out.println(\"- \" + task);\n        }\n    }\n}\n",
      "expectedOutput": "Integration Test Checklist\n- start PostgreSQL Testcontainer\n- apply schema migrations\n- seed reference products\n- call POST /orders\n- assert 201 status and location header\n- query database for saved order",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Repeatable integration tests stand up real infrastructure, exercise the API, and verify persistence side effects.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">- start PostgreSQL Testcontainer\n- run migrations</pre></div><p class=\"mt-4 text-gray-300\">List each step so failures are easy to localize when tests go red.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding integration test checklist: order api is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying integration test checklist: order api, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply integration test checklist: order api will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with integration test checklist: order api, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Databases"
      ]
    },
    {
      "id": 263,
      "title": "263. Docker Compose Outline: Order Service",
      "description": "Summarize the docker-compose services, including builds, environment variables, and dependencies.",
      "initialCode": "import java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, List<String>> services = new LinkedHashMap<>();\n        services.put(\"app\", List.of(\"build ./\", \"env SPRING_PROFILES_ACTIVE=prod\", \"depends_on db\"));\n        services.put(\"db\", List.of(\"image postgres:16\", \"env POSTGRES_DB=orders\", \"volumes ./data:/var/lib/postgresql/data\"));\n\n        // TODO: print the docker-compose summary exactly as described\n    }\n}\n",
      "fullSolution": "import java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, List<String>> services = new LinkedHashMap<>();\n        services.put(\"app\", List.of(\"build ./\", \"env SPRING_PROFILES_ACTIVE=prod\", \"depends_on db\"));\n        services.put(\"db\", List.of(\"image postgres:16\", \"env POSTGRES_DB=orders\", \"volumes ./data:/var/lib/postgresql/data\"));\n\n        System.out.println(\"docker-compose.yml\");\n        System.out.println(\"services:\");\n        for (Map.Entry<String, List<String>> entry : services.entrySet()) {\n            System.out.println(\"- \" + entry.getKey() + \" -> \" + String.join(\", \", entry.getValue()));\n        }\n    }\n}\n",
      "expectedOutput": "docker-compose.yml\nservices:\n- app -> build ./, env SPRING_PROFILES_ACTIVE=prod, depends_on db\n- db -> image postgres:16, env POSTGRES_DB=orders, volumes ./data:/var/lib/postgresql/data",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Container orchestration plans should capture how services start, which images they use, and the configuration they need.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">- app -> build ./, env SPRING_PROFILES_ACTIVE=prod</pre></div><p class=\"mt-4 text-gray-300\">Iterate in insertion order so the summary mirrors a docker-compose file.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding docker compose outline: order service is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying docker compose outline: order service, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply docker compose outline: order service will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with docker compose outline: order service, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Advanced",
        "Control Flow",
        "Strings",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 264,
      "title": "264. CI Pipeline Stages: Order Service",
      "description": "List the continuous integration stages needed before shipping the service.",
      "initialCode": "import java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> stages = List.of(\n                \"checkout\",\n                \"setup JDK 21\",\n                \"cache ~/.m2\",\n                \"run ./mvnw verify\",\n                \"build docker image\",\n                \"push artifact to registry\"\n        );\n\n        // TODO: print the heading and numbered stages starting at 1\n    }\n}\n",
      "fullSolution": "import java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> stages = List.of(\n                \"checkout\",\n                \"setup JDK 21\",\n                \"cache ~/.m2\",\n                \"run ./mvnw verify\",\n                \"build docker image\",\n                \"push artifact to registry\"\n        );\n\n        System.out.println(\"CI Pipeline\");\n        for (int i = 0; i < stages.size(); i++) {\n            System.out.println((i + 1) + \". \" + stages.get(i));\n        }\n    }\n}\n",
      "expectedOutput": "CI Pipeline\n1. checkout\n2. setup JDK 21\n3. cache ~/.m2\n4. run ./mvnw verify\n5. build docker image\n6. push artifact to registry",
      "tutorial": "<p class=\"mb-4 text-gray-300\">High-signal pipelines make build, test, and packaging stages explicit so failures point to the right fix.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">1. checkout\n2. run tests</pre></div><p class=\"mt-4 text-gray-300\">Print each stage with its sequence number to show the promotion path toward production.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding ci pipeline stages: order service is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying ci pipeline stages: order service, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply ci pipeline stages: order service will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with ci pipeline stages: order service, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Advanced",
        "Tooling",
        "Control Flow",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 265,
      "title": "265. Kubernetes Deployment Snippet",
      "description": "Output the key manifest lines for running the service on Kubernetes.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String[] lines = {\n                \"apiVersion: apps/v1\",\n                \"kind: Deployment\",\n                \"metadata:\",\n                \"  name: orders-api\",\n                \"spec:\",\n                \"  replicas: 3\",\n                \"  template:\",\n                \"    spec:\",\n                \"      containers:\",\n                \"      - name: app\",\n                \"        image: ghcr.io/acme/orders:latest\",\n                \"        env:\",\n                \"        - name: SPRING_PROFILES_ACTIVE\",\n                \"          value: prod\"\n        };\n\n        // TODO: print each line in order\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String[] lines = {\n                \"apiVersion: apps/v1\",\n                \"kind: Deployment\",\n                \"metadata:\",\n                \"  name: orders-api\",\n                \"spec:\",\n                \"  replicas: 3\",\n                \"  template:\",\n                \"    spec:\",\n                \"      containers:\",\n                \"      - name: app\",\n                \"        image: ghcr.io/acme/orders:latest\",\n                \"        env:\",\n                \"        - name: SPRING_PROFILES_ACTIVE\",\n                \"          value: prod\"\n        };\n\n        for (String line : lines) {\n            System.out.println(line);\n        }\n    }\n}\n",
      "expectedOutput": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: orders-api\nspec:\n  replicas: 3\n  template:\n    spec:\n      containers:\n      - name: app\n        image: ghcr.io/acme/orders:latest\n        env:\n        - name: SPRING_PROFILES_ACTIVE\n          value: prod",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Kubernetes manifests depend on precise indentation. Capture the apiVersion, resource kind, metadata, and container spec.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">kind: Deployment\nmetadata:\n  name: orders-api</pre></div><p class=\"mt-4 text-gray-300\">Print the manifest lines exactly so they can be dropped into a deployment file.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding kubernetes deployment snippet is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying kubernetes deployment snippet, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply kubernetes deployment snippet will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with kubernetes deployment snippet, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Advanced",
        "Control Flow",
        "OOP",
        "Web",
        "Performance"
      ]
    },
    {
      "id": 266,
      "title": "266. AWS Reference Stack: Orders",
      "description": "Summarize the core AWS services powering the production deployment.",
      "initialCode": "import java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> components = List.of(\n                \"API Gateway -> Lambda webhook fanout\",\n                \"ECS service -> orders-api (Fargate, 3 tasks)\",\n                \"RDS cluster -> aurora-postgresql\",\n                \"SQS queue -> orders-events\",\n                \"CloudWatch alarms -> p95 latency > 500ms\"\n        );\n\n        // TODO: print the heading and bullet list\n    }\n}\n",
      "fullSolution": "import java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> components = List.of(\n                \"API Gateway -> Lambda webhook fanout\",\n                \"ECS service -> orders-api (Fargate, 3 tasks)\",\n                \"RDS cluster -> aurora-postgresql\",\n                \"SQS queue -> orders-events\",\n                \"CloudWatch alarms -> p95 latency > 500ms\"\n        );\n\n        System.out.println(\"AWS Reference Stack\");\n        for (String component : components) {\n            System.out.println(\"- \" + component);\n        }\n    }\n}\n",
      "expectedOutput": "AWS Reference Stack\n- API Gateway -> Lambda webhook fanout\n- ECS service -> orders-api (Fargate, 3 tasks)\n- RDS cluster -> aurora-postgresql\n- SQS queue -> orders-events\n- CloudWatch alarms -> p95 latency > 500ms",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Tie each AWS service to the responsibility it owns so stakeholders understand the deployment topology.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">- RDS cluster -> aurora-postgresql</pre></div><p class=\"mt-4 text-gray-300\">Keep the bullet list concise but descriptive enough to guide on-call responders.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding aws reference stack: orders is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying aws reference stack: orders, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply aws reference stack: orders will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with aws reference stack: orders, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Advanced",
        "Control Flow",
        "Functions",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 267,
      "title": "267. Observability Instrumentation Map",
      "description": "Describe the metrics, logs, and traces that give production insight into orders.",
      "initialCode": "import java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, List<String>> plan = new LinkedHashMap<>();\n        plan.put(\"Metrics\", List.of(\"order_submitted_total (counter)\", \"payment_latency_seconds (histogram)\"));\n        plan.put(\"Logs\", List.of(\"structured JSON with orderId, traceId, status\"));\n        plan.put(\"Traces\", List.of(\"name HTTP POST /orders\", \"inject traceparent header to downstream\"));\n\n        // TODO: print the heading followed by each category and its bullet items\n    }\n}\n",
      "fullSolution": "import java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, List<String>> plan = new LinkedHashMap<>();\n        plan.put(\"Metrics\", List.of(\"order_submitted_total (counter)\", \"payment_latency_seconds (histogram)\"));\n        plan.put(\"Logs\", List.of(\"structured JSON with orderId, traceId, status\"));\n        plan.put(\"Traces\", List.of(\"name HTTP POST /orders\", \"inject traceparent header to downstream\"));\n\n        System.out.println(\"Observability Plan\");\n        for (Map.Entry<String, List<String>> entry : plan.entrySet()) {\n            System.out.println(entry.getKey() + \":\");\n            for (String item : entry.getValue()) {\n                System.out.println(\"- \" + item);\n            }\n        }\n    }\n}\n",
      "expectedOutput": "Observability Plan\nMetrics:\n- order_submitted_total (counter)\n- payment_latency_seconds (histogram)\nLogs:\n- structured JSON with orderId, traceId, status\nTraces:\n- name HTTP POST /orders\n- inject traceparent header to downstream",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Great observability stories connect metrics, logs, and traces so incidents can be triaged quickly.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Metrics:\n- order_submitted_total (counter)</pre></div><p class=\"mt-4 text-gray-300\">Group instrumentation by signal type to highlight coverage gaps.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding observability instrumentation map is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying observability instrumentation map, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply observability instrumentation map will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with observability instrumentation map, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Serialization"
      ]
    },
    {
      "id": 268,
      "title": "268. Resume Bullet Transformer",
      "description": "Convert accomplishment data into a compelling resume bullet.",
      "initialCode": "import java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        String headline = \"Scaled Spring Boot order service to 120k req/min\";\n        List<String> actions = List.of(\"introducing Redis caching\", \"async fulfillment\");\n        String impact = \"cut p95 from 940ms to 210ms\";\n\n        // TODO: print the heading followed by the completed resume bullet\n    }\n}\n",
      "fullSolution": "import java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        String headline = \"Scaled Spring Boot order service to 120k req/min\";\n        List<String> actions = List.of(\"introducing Redis caching\", \"async fulfillment\");\n        String impact = \"cut p95 from 940ms to 210ms\";\n\n        String actionText = String.join(\" and \", actions);\n        System.out.println(\"Resume Bullet\");\n        System.out.println(headline + \" by \" + actionText + \"; \" + impact + \".\");\n    }\n}\n",
      "expectedOutput": "Resume Bullet\nScaled Spring Boot order service to 120k req/min by introducing Redis caching and async fulfillment; cut p95 from 940ms to 210ms.",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Elite resumes lead with scope, highlight the leverage you applied, and quantify the outcome.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Scaled platform X by doing Y; improved metric Z.</pre></div><p class=\"mt-4 text-gray-300\">Weave the provided fragments into one strong sentence.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding resume bullet transformer is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying resume bullet transformer, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply resume bullet transformer will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with resume bullet transformer, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Advanced",
        "Strings",
        "Collections",
        "OOP",
        "Web"
      ]
    },
    {
      "id": 269,
      "title": "269. Senior Interview Prep Sprint",
      "description": "Draft a five-day prep plan covering system design, coding, behavioral, architecture, and negotiation drills.",
      "initialCode": "import java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, String> plan = new LinkedHashMap<>();\n        plan.put(\"Day 1\", \"system design -> design global rate limiter\");\n        plan.put(\"Day 2\", \"coding -> implement LRU cache in 30 min\");\n        plan.put(\"Day 3\", \"behavioral -> lead incident retrospective story\");\n        plan.put(\"Day 4\", \"architecture -> review microservice observability\");\n        plan.put(\"Day 5\", \"negotiation -> target base + equity bands\");\n\n        // TODO: print the heading then each day entry on its own line\n    }\n}\n",
      "fullSolution": "import java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, String> plan = new LinkedHashMap<>();\n        plan.put(\"Day 1\", \"system design -> design global rate limiter\");\n        plan.put(\"Day 2\", \"coding -> implement LRU cache in 30 min\");\n        plan.put(\"Day 3\", \"behavioral -> lead incident retrospective story\");\n        plan.put(\"Day 4\", \"architecture -> review microservice observability\");\n        plan.put(\"Day 5\", \"negotiation -> target base + equity bands\");\n\n        System.out.println(\"Interview Prep Sprint\");\n        for (Map.Entry<String, String> entry : plan.entrySet()) {\n            System.out.println(entry.getKey() + \": \" + entry.getValue());\n        }\n    }\n}\n",
      "expectedOutput": "Interview Prep Sprint\nDay 1: system design -> design global rate limiter\nDay 2: coding -> implement LRU cache in 30 min\nDay 3: behavioral -> lead incident retrospective story\nDay 4: architecture -> review microservice observability\nDay 5: negotiation -> target base + equity bands",
      "tutorial": "<p class=\"mb-4 text-gray-300\">A deliberate prep sprint keeps you sharp across all interview formats while preventing last-minute panic.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Day 1: system design -> practice high-scale feeds</pre></div><p class=\"mt-4 text-gray-300\">Print the plan in order so it doubles as a checklist during your prep week.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding senior interview prep sprint is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying senior interview prep sprint, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply senior interview prep sprint will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with senior interview prep sprint, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Web"
      ]
    },
    {
      "id": 270,
      "title": "270. Error Budget Dashboard Row",
      "language": "java",
      "description": "Given counts and budget limits, calculate the current error rate and remaining budget, then print the production status lines.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String service = \"auth-api\";\n        int totalRequests = 100000;\n        double allowedErrorBudgetPct = 2.0;\n        int observedErrors = 420;\n\n        // TODO: compute errorRate and budgetRemaining, then print the summary lines\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String service = \"auth-api\";\n        int totalRequests = 100000;\n        double allowedErrorBudgetPct = 2.0;\n        int observedErrors = 420;\n\n        double errorRate = (observedErrors / (double) totalRequests) * 100;\n        double budgetRemaining = allowedErrorBudgetPct - errorRate;\n\n        System.out.printf(\"Service: %s%n\", service);\n        System.out.printf(\"Requests: %d%n\", totalRequests);\n        System.out.printf(\"Errors: %d%n\", observedErrors);\n        System.out.printf(\"Error Rate: %.2f%%%n\", errorRate);\n        System.out.printf(\"Budget Remaining: %.2f%%%n\", budgetRemaining);\n    }\n}\n",
      "expectedOutput": "Service: auth-api\nRequests: 100000\nErrors: 420\nError Rate: 0.42%\nBudget Remaining: 1.58%",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Site reliability dashboards need a quick readout of burn rate. Divide errors by total requests to get the percent burn, then subtract from your budget.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">double errorRate = (failures / (double) requests) * 100;\nSystem.out.printf(\"Error Rate: %.2f%%%n\", errorRate);</pre></div><p class=\"mt-4 text-gray-300\">Use <code>%.2f</code> to lock to two decimals so the report looks consistent across teams.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding error budget dashboard row is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying error budget dashboard row, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply error budget dashboard row will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with error budget dashboard row, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "OOP",
        "Networking",
        "Concurrency"
      ]
    },
    {
      "id": 271,
      "title": "271. Incident Timeline Reporter",
      "language": "java",
      "description": "Loop through the incident events and print a well-formatted timeline for the postmortem.",
      "initialCode": "import java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String[]> events = List.of(\n            new String[]{\"07:05\", \"PagerDuty triggered for elevated 5xx\"},\n            new String[]{\"07:09\", \"Incident commander assigned\"},\n            new String[]{\"07:14\", \"Rolled back payment service\"},\n            new String[]{\"07:21\", \"Error rates normalized\"}\n        );\n\n        // TODO: print a heading, then each timestamp and note separated by \" - \"\n    }\n}\n",
      "fullSolution": "import java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String[]> events = List.of(\n            new String[]{\"07:05\", \"PagerDuty triggered for elevated 5xx\"},\n            new String[]{\"07:09\", \"Incident commander assigned\"},\n            new String[]{\"07:14\", \"Rolled back payment service\"},\n            new String[]{\"07:21\", \"Error rates normalized\"}\n        );\n\n        System.out.println(\"Incident Timeline\");\n        for (String[] event : events) {\n            System.out.printf(\"%s - %s%n\", event[0], event[1]);\n        }\n    }\n}\n",
      "expectedOutput": "Incident Timeline\n07:05 - PagerDuty triggered for elevated 5xx\n07:09 - Incident commander assigned\n07:14 - Rolled back payment service\n07:21 - Error rates normalized",
      "tutorial": "<p class=\"mb-4 text-gray-300\">After every outage you publish a crisp minute-by-minute log. Store each entry as a two-item array so you can unpack it in a for-each loop.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">for (String[] event : events) {\n    System.out.printf(\"%s - %s%n\", event[0], event[1]);\n}</pre></div><p class=\"mt-4 text-gray-300\">The heading makes the block paste-ready for your incident doc.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding incident timeline reporter is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying incident timeline reporter, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply incident timeline reporter will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with incident timeline reporter, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Concurrency"
      ]
    },
    {
      "id": 272,
      "title": "272. Canary Analysis Summary",
      "language": "java",
      "description": "Compare baseline and canary signals and print the difference so release managers can decide to promote.",
      "initialCode": "import java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, double[]> metrics = new LinkedHashMap<>();\n        metrics.put(\"latency_p95_ms\", new double[]{340, 360});\n        metrics.put(\"error_rate_pct\", new double[]{0.7, 0.9});\n        metrics.put(\"cpu_pct\", new double[]{52, 49});\n\n        // TODO: print the heading and each metric with baseline, canary, and a signed delta\n    }\n\n    private static String formatValue(double value) {\n        // TODO: return a whole number string when possible, otherwise two decimal places\n        return \"\";\n    }\n}\n",
      "fullSolution": "import java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, double[]> metrics = new LinkedHashMap<>();\n        metrics.put(\"latency_p95_ms\", new double[]{340, 360});\n        metrics.put(\"error_rate_pct\", new double[]{0.7, 0.9});\n        metrics.put(\"cpu_pct\", new double[]{52, 49});\n\n        System.out.println(\"Canary Analysis\");\n        for (Map.Entry<String, double[]> entry : metrics.entrySet()) {\n            double baseline = entry.getValue()[0];\n            double canary = entry.getValue()[1];\n            double delta = canary - baseline;\n            System.out.printf(\n                \"%s: baseline=%s, canary=%s, delta=%+.2f%n\",\n                entry.getKey(),\n                formatValue(baseline),\n                formatValue(canary),\n                delta\n            );\n        }\n    }\n\n    private static String formatValue(double value) {\n        if (Math.abs(value - Math.rint(value)) < 0.0001) {\n            return String.format(\"%.0f\", value);\n        }\n        return String.format(\"%.2f\", value);\n    }\n}\n",
      "expectedOutput": "Canary Analysis\nlatency_p95_ms: baseline=340, canary=360, delta=+20.00\nerror_rate_pct: baseline=0.70, canary=0.90, delta=+0.20\ncpu_pct: baseline=52, canary=49, delta=-3.00",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Canary comparisons reveal regressions before a full rollout. Keep the output structured so the release manager can skim each signal.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">double delta = values[1] - values[0];\nSystem.out.printf(\"delta=%+.2f%n\", delta);</pre></div><p class=\"mt-4 text-gray-300\">Formatting whole numbers without decimals keeps the table tidy, while the <code>%+</code> flag shows direction.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding canary analysis summary is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying canary analysis summary, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply canary analysis summary will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with canary analysis summary, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Strings",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 273,
      "title": "273. Feature Flag Rollout Planner",
      "language": "java",
      "description": "Turn the staged rollout data into a checklist operations can follow without ambiguity.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String flagName = \"checkout_redesign\";\n        int[] percentages = {5, 25, 50, 100};\n        String[] notes = {\n            \"internal users only\",\n            \"beta cohort rollout\",\n            \"enable for all EU traffic\",\n            \"global enablement\"\n        };\n\n        // TODO: print the plan header, the flag name, then each stage with its note\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String flagName = \"checkout_redesign\";\n        int[] percentages = {5, 25, 50, 100};\n        String[] notes = {\n            \"internal users only\",\n            \"beta cohort rollout\",\n            \"enable for all EU traffic\",\n            \"global enablement\"\n        };\n\n        System.out.println(\"Feature Flag Plan\");\n        System.out.printf(\"Flag: %s%n\", flagName);\n        for (int i = 0; i < notes.length; i++) {\n            System.out.printf(\"Stage %d: %d%% - %s%n\", i + 1, percentages[i], notes[i]);\n        }\n    }\n}\n",
      "expectedOutput": "Feature Flag Plan\nFlag: checkout_redesign\nStage 1: 5% - internal users only\nStage 2: 25% - beta cohort rollout\nStage 3: 50% - enable for all EU traffic\nStage 4: 100% - global enablement",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Successful launches follow a staged plan. Loop by index so you can pull the matching percentage and note for each milestone.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">for (int i = 0; i < notes.length; i++) {\n    System.out.printf(\"Stage %d: %d%%%n\", i + 1, percentages[i]);\n}</pre></div><p class=\"mt-4 text-gray-300\">Printing the flag name up front makes the output self-contained in chat threads.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding feature flag rollout planner is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying feature flag rollout planner, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply feature flag rollout planner will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with feature flag rollout planner, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "OOP",
        "Concurrency"
      ]
    },
    {
      "id": 274,
      "title": "274. Capacity Forecast Table",
      "language": "java",
      "description": "Project the expected requests per second for the next three quarters by compounding growth.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        int currentRps = 1800;\n        double[] growthRates = {0.15, 0.22, 0.18};\n        String[] planningHorizon = {\"Q1\", \"Q2\", \"Q3\"};\n\n        // TODO: print a heading then iterate through each quarter, compounding the load forecast\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        int currentRps = 1800;\n        double[] growthRates = {0.15, 0.22, 0.18};\n        String[] planningHorizon = {\"Q1\", \"Q2\", \"Q3\"};\n\n        System.out.println(\"Capacity Forecast\");\n        double projected = currentRps;\n        for (int i = 0; i < planningHorizon.length; i++) {\n            projected *= 1 + growthRates[i];\n            System.out.printf(\"%s: %d rps%n\", planningHorizon[i], Math.round(projected));\n        }\n    }\n}\n",
      "expectedOutput": "Capacity Forecast\nQ1: 2070 rps\nQ2: 2525 rps\nQ3: 2980 rps",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Capacity reviews rely on compounding growth so finance can model hardware spend. Multiply the running total by each rate in turn.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">projected *= 1 + growthRates[i];\nSystem.out.printf(\"%d rps%n\", Math.round(projected));</pre></div><p class=\"mt-4 text-gray-300\">Pair each percentage with its quarter label to keep the forecast legible.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding capacity forecast table is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying capacity forecast table, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply capacity forecast table will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with capacity forecast table, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "OOP",
        "Networking",
        "Web"
      ]
    },
    {
      "id": 275,
      "title": "275. Service Dependency Matrix",
      "language": "java",
      "description": "Summarize each platform service with its owning team and downstream dependencies.",
      "initialCode": "import java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, List<String>> services = new LinkedHashMap<>();\n        services.put(\"checkout\", List.of(\"payments\", \"inventory\", \"notifications\"));\n        services.put(\"payments\", List.of(\"risk\", \"ledger\"));\n        services.put(\"search\", List.of());\n\n        Map<String, String> owners = Map.of(\n            \"checkout\", \"Growth\",\n            \"payments\", \"Core Banking\",\n            \"search\", \"Discovery\"\n        );\n\n        // TODO: print the heading then each service with its team and dependencies (use \"none\" when empty)\n    }\n}\n",
      "fullSolution": "import java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, List<String>> services = new LinkedHashMap<>();\n        services.put(\"checkout\", List.of(\"payments\", \"inventory\", \"notifications\"));\n        services.put(\"payments\", List.of(\"risk\", \"ledger\"));\n        services.put(\"search\", List.of());\n\n        Map<String, String> owners = Map.of(\n            \"checkout\", \"Growth\",\n            \"payments\", \"Core Banking\",\n            \"search\", \"Discovery\"\n        );\n\n        System.out.println(\"Service Dependencies\");\n        for (Map.Entry<String, List<String>> entry : services.entrySet()) {\n            String service = entry.getKey();\n            List<String> deps = entry.getValue();\n            String dependencyList = deps.isEmpty() ? \"none\" : String.join(\", \", deps);\n            String team = owners.get(service);\n            System.out.printf(\"%s (team: %s) -> %s%n\", service, team, dependencyList);\n        }\n    }\n}\n",
      "expectedOutput": "Service Dependencies\ncheckout (team: Growth) -> payments, inventory, notifications\npayments (team: Core Banking) -> risk, ledger\nsearch (team: Discovery) -> none",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Platform diagrams pair each service with its owning team and the downstream systems it calls. A LinkedHashMap keeps the ordering stable so you can print the analysis exactly as documented.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">for (Map.Entry<String, List<String>> entry : services.entrySet()) {\n    System.out.println(entry.getKey());\n}</pre></div>\n<p class=\"mt-4 text-gray-300\">Use String.join(...) to flatten the dependency list, and fall back to \"none\" when a service has no downstream calls.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding service dependency matrix is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying service dependency matrix, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply service dependency matrix will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with service dependency matrix, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Strings",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 276,
      "title": "276. Incident Action Agenda",
      "language": "java",
      "description": "Turn the post-incident actions into a one-glance checklist with owners and due dates.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String[][] actions = {\n            {\"Add circuit breaker to retries\", \"SRE\", \"2024-08-01\"},\n            {\"Publish synthetic monitor runbook\", \"Platform\", \"2024-08-05\"},\n            {\"Schedule chaos drill follow up\", \"Incident Lead\", \"2024-08-12\"}\n        };\n\n        // TODO: print the heading then each action as \"- Owner to Item (due Date)\"\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String[][] actions = {\n            {\"Add circuit breaker to retries\", \"SRE\", \"2024-08-01\"},\n            {\"Publish synthetic monitor runbook\", \"Platform\", \"2024-08-05\"},\n            {\"Schedule chaos drill follow up\", \"Incident Lead\", \"2024-08-12\"}\n        };\n\n        System.out.println(\"Incident Action Items\");\n        for (String[] action : actions) {\n            String work = action[0];\n            String owner = action[1];\n            String due = action[2];\n            System.out.printf(\"- %s to %s (due %s)%n\", owner, work, due);\n        }\n    }\n}\n",
      "expectedOutput": "Incident Action Items\n- SRE to Add circuit breaker to retries (due 2024-08-01)\n- Platform to Publish synthetic monitor runbook (due 2024-08-05)\n- Incident Lead to Schedule chaos drill follow up (due 2024-08-12)",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Incident follow-ups stick when every task has an owner and a date. Loop through the 2D array and unpack each slot so the printout reads like a runbook checklist.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">for (String[] action : actions) {\n    System.out.println(action[1] + \" -> \" + action[0]);\n}</pre></div>\n<p class=\"mt-4 text-gray-300\">Formatting with System.out.printf keeps the bullets consistent when you paste them into the team's tracker.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding incident action agenda is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying incident action agenda, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply incident action agenda will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with incident action agenda, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Async"
      ]
    },
    {
      "id": 277,
      "title": "277. Architecture Trade-off Matrix",
      "language": "java",
      "description": "Compare architecture options on speed, delivery effort, and operational load for review with staff engineers.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String[][] options = {\n            {\"Monolith\", \"140\", \"4\", \"low\"},\n            {\"Services\", \"95\", \"10\", \"high\"},\n            {\"Event Hub\", \"120\", \"7\", \"medium\"}\n        };\n\n        // TODO: print \"Architecture Trade-offs\" then each option as\n        // Name - latency: Xms, build: Y weeks, ops: Z\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String[][] options = {\n            {\"Monolith\", \"140\", \"4\", \"low\"},\n            {\"Services\", \"95\", \"10\", \"high\"},\n            {\"Event Hub\", \"120\", \"7\", \"medium\"}\n        };\n\n        System.out.println(\"Architecture Trade-offs\");\n        for (String[] option : options) {\n            System.out.printf(\n                \"%s - latency: %sms, build: %s weeks, ops: %s%n\",\n                option[0], option[1], option[2], option[3]\n            );\n        }\n    }\n}\n",
      "expectedOutput": "Architecture Trade-offs\nMonolith - latency: 140ms, build: 4 weeks, ops: low\nServices - latency: 95ms, build: 10 weeks, ops: high\nEvent Hub - latency: 120ms, build: 7 weeks, ops: medium",
      "tutorial": "      <p class=\"mb-4 text-gray-300\">Staff-level discussions start with data. Loop through the matrix and print each row with <code>printf</code> so the comparison reads naturally.</p>\n      <h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n      <div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">for (String[] option : options) {\n    System.out.println(option[0]);\n}</pre></div>\n      <p class=\"mt-4 text-gray-300\">Consistent formatting helps the team reason about which design wins.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding architecture trade-off matrix is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying architecture trade-off matrix, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply architecture trade-off matrix will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with architecture trade-off matrix, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "OOP",
        "Web"
      ]
    },
    {
      "id": 278,
      "title": "278. Reliability Risk Register",
      "language": "java",
      "description": "Score platform risks by multiplying impact and likelihood before presenting to incident commanders.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String[] components = {\"Checkout API\", \"Worker Queue\", \"Search Index\"};\n        int[] impacts = {5, 4, 3};\n        int[] likelihoods = {3, 2, 4};\n\n        // TODO: print the heading then each component with impact, likelihood, severity (impact * likelihood)\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String[] components = {\"Checkout API\", \"Worker Queue\", \"Search Index\"};\n        int[] impacts = {5, 4, 3};\n        int[] likelihoods = {3, 2, 4};\n\n        System.out.println(\"Reliability Risk Register\");\n        for (int i = 0; i < components.length; i++) {\n            int severity = impacts[i] * likelihoods[i];\n            System.out.printf(\n                \"%s - impact: %d, likelihood: %d, severity: %d%n\",\n                components[i], impacts[i], likelihoods[i], severity\n            );\n        }\n    }\n}\n",
      "expectedOutput": "Reliability Risk Register\nCheckout API - impact: 5, likelihood: 3, severity: 15\nWorker Queue - impact: 4, likelihood: 2, severity: 8\nSearch Index - impact: 3, likelihood: 4, severity: 12",
      "tutorial": "      <p class=\"mb-4 text-gray-300\">Translate qualitative risk talk into numbers leaders can act on. Multiply matching indices to compute severity.</p>\n      <h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n      <div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">int severity = impact * likelihood;\nSystem.out.println(severity);</pre></div>\n      <p class=\"mt-4 text-gray-300\">This table lets you argue for the mitigations that matter.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding reliability risk register is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying reliability risk register, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply reliability risk register will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with reliability risk register, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 279,
      "title": "279. Migration Cutover Timeline",
      "language": "java",
      "description": "Sequence migration activities with owners so the war room has a single source of truth.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String[][] steps = {\n            {\"T-24h\", \"Platform\", \"freeze writes\"},\n            {\"T-6h\", \"DBA\", \"back up primary database\"},\n            {\"T-0\", \"SRE\", \"switch traffic to new cluster\"},\n            {\"T+1h\", \"QA\", \"run smoke tests\"}\n        };\n\n        // TODO: print the heading then each step as Time: Owner -> Task\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String[][] steps = {\n            {\"T-24h\", \"Platform\", \"freeze writes\"},\n            {\"T-6h\", \"DBA\", \"back up primary database\"},\n            {\"T-0\", \"SRE\", \"switch traffic to new cluster\"},\n            {\"T+1h\", \"QA\", \"run smoke tests\"}\n        };\n\n        System.out.println(\"Migration Cutover Timeline\");\n        for (String[] step : steps) {\n            System.out.printf(\"%s: %s -> %s%n\", step[0], step[1], step[2]);\n        }\n    }\n}\n",
      "expectedOutput": "Migration Cutover Timeline\nT-24h: Platform -> freeze writes\nT-6h: DBA -> back up primary database\nT-0: SRE -> switch traffic to new cluster\nT+1h: QA -> run smoke tests",
      "tutorial": "      <p class=\"mb-4 text-gray-300\">Cutover calls move fast. Loop through the table so everyone sees time, owner, and action in one line.</p>\n      <h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n      <div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">for (String[] step : steps) {\n    System.out.println(step[0]);\n}</pre></div>\n      <p class=\"mt-4 text-gray-300\">Clear sequencing avoids duplicated work and missed checkpoints.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding migration cutover timeline is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying migration cutover timeline, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply migration cutover timeline will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with migration cutover timeline, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "OOP",
        "Databases",
        "Parsing"
      ]
    },
    {
      "id": 280,
      "title": "280. Security Control Coverage",
      "language": "java",
      "description": "Group controls by security domain before meeting with compliance and risk teams.",
      "initialCode": "import java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, List<String>> domains = new LinkedHashMap<>();\n        domains.put(\"Authentication\", List.of(\"MFA enforcement\", \"Session timeout review\"));\n        domains.put(\"Data Protection\", List.of(\"Rotate KMS keys\", \"Encrypt S3 buckets\"));\n        domains.put(\"Observability\", List.of(\"Audit log retention\", \"Alert on IAM anomalies\"));\n\n        // TODO: print the heading then each domain followed by its controls prefixed with \"- \"\n    }\n}\n",
      "fullSolution": "import java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, List<String>> domains = new LinkedHashMap<>();\n        domains.put(\"Authentication\", List.of(\"MFA enforcement\", \"Session timeout review\"));\n        domains.put(\"Data Protection\", List.of(\"Rotate KMS keys\", \"Encrypt S3 buckets\"));\n        domains.put(\"Observability\", List.of(\"Audit log retention\", \"Alert on IAM anomalies\"));\n\n        System.out.println(\"Security Control Coverage\");\n        for (Map.Entry<String, List<String>> entry : domains.entrySet()) {\n            System.out.println(entry.getKey() + \":\");\n            for (String control : entry.getValue()) {\n                System.out.println(\"- \" + control);\n            }\n        }\n    }\n}\n",
      "expectedOutput": "Security Control Coverage\nAuthentication:\n- MFA enforcement\n- Session timeout review\nData Protection:\n- Rotate KMS keys\n- Encrypt S3 buckets\nObservability:\n- Audit log retention\n- Alert on IAM anomalies",
      "tutorial": "      <p class=\"mb-4 text-gray-300\">Organize controls by domain so audits run smoothly. A nested loop keeps each heading grouped with its actions.</p>\n      <h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n      <div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">for (String control : domains.get(\"Authentication\")) {\n    System.out.println(control);\n}</pre></div>\n      <p class=\"mt-4 text-gray-300\">Readable summaries help security and engineering stay aligned.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding security control coverage is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying security control coverage, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply security control coverage will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with security control coverage, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Web"
      ]
    },
    {
      "id": 281,
      "title": "281. Cost Efficiency Report",
      "language": "java",
      "description": "Show spend deltas and percentage change so finance trusts the engineering savings narrative.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String[] services = {\"api-gateway\", \"batch-jobs\", \"stream-processor\"};\n        int[] baseline = {3200, 4100, 2900};\n        int[] current = {2800, 4800, 2550};\n\n        // TODO: print the heading then each service with baseline, current, signed dollar delta, and signed percent change (1 decimal)\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String[] services = {\"api-gateway\", \"batch-jobs\", \"stream-processor\"};\n        int[] baseline = {3200, 4100, 2900};\n        int[] current = {2800, 4800, 2550};\n\n        System.out.println(\"Cost Efficiency Report\");\n        for (int i = 0; i < services.length; i++) {\n            int delta = current[i] - baseline[i];\n            double change = (double) delta / baseline[i] * 100;\n            System.out.printf(\n                \"%s: baseline=$%d, current=$%d, delta=$%+d, change=%+.1f%%%n\",\n                services[i], baseline[i], current[i], delta, change\n            );\n        }\n    }\n}\n",
      "expectedOutput": "Cost Efficiency Report\napi-gateway: baseline=$3200, current=$2800, delta=$-400, change=-12.5%\nbatch-jobs: baseline=$4100, current=$4800, delta=$+700, change=+17.1%\nstream-processor: baseline=$2900, current=$2550, delta=$-350, change=-12.1%",
      "tutorial": "      <p class=\"mb-4 text-gray-300\">Partner teams want signed numbers. Use <code>%+d</code> and <code>%+.1f</code> so the reader sees direction immediately.</p>\n      <h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n      <div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.printf(\"delta=%+d\", delta);\nSystem.out.printf(\"change=%+.1f%%\", change);</pre></div>\n      <p class=\"mt-4 text-gray-300\">That visibility makes budget reviews smoother.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding cost efficiency report is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying cost efficiency report, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply cost efficiency report will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with cost efficiency report, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "OOP",
        "Math and Stats",
        "I/O"
      ]
    },
    {
      "id": 282,
      "title": "282. Mentorship Pairing Planner",
      "language": "java",
      "description": "List mentor pairings and focus areas to reinforce talent development across squads.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String[][] pairings = {\n            {\"Alice\", \"Ravi\", \"modernize reporting ETL\"},\n            {\"Morgan\", \"Chen\", \"k8s deployment playbook\"},\n            {\"Jamie\", \"Inez\", \"observability dashboards\"}\n        };\n\n        // TODO: print the heading then each pairing as Mentor -> Mentee: focus area\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String[][] pairings = {\n            {\"Alice\", \"Ravi\", \"modernize reporting ETL\"},\n            {\"Morgan\", \"Chen\", \"k8s deployment playbook\"},\n            {\"Jamie\", \"Inez\", \"observability dashboards\"}\n        };\n\n        System.out.println(\"Mentorship Pairings\");\n        for (String[] pairing : pairings) {\n            System.out.printf(\"%s -> %s: %s%n\", pairing[0], pairing[1], pairing[2]);\n        }\n    }\n}\n",
      "expectedOutput": "Mentorship Pairings\nAlice -> Ravi: modernize reporting ETL\nMorgan -> Chen: k8s deployment playbook\nJamie -> Inez: observability dashboards",
      "tutorial": "      <p class=\"mb-4 text-gray-300\">Mentorship plans show leadership maturity. Print each tuple in a single line so managers can copy the plan straight into trackers.</p>\n      <h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n      <div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">for (String[] pairing : pairings) {\n    System.out.println(pairing[0]);\n}</pre></div>\n      <p class=\"mt-4 text-gray-300\">Concise formatting keeps the focus on the growth goals.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding mentorship pairing planner is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying mentorship pairing planner, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply mentorship pairing planner will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with mentorship pairing planner, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 283,
      "title": "283. Roadmap Pillar Summary",
      "language": "java",
      "description": "Group initiatives by pillar so cross-functional leaders can review strategy quickly.",
      "initialCode": "import java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, List<String>> pillars = new LinkedHashMap<>();\n        pillars.put(\"Reliability\", List.of(\"Implement region failover\", \"Drop MTTR below 20m\"));\n        pillars.put(\"Product\", List.of(\"Adaptive pricing\", \"Cross-store search\"));\n        pillars.put(\"Platform\", List.of(\"Unified CI/CD pipeline\"));\n\n        // TODO: print \"Roadmap Pillars\" then each pillar with its initiatives prefixed by \"- \"\n    }\n}\n",
      "fullSolution": "import java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, List<String>> pillars = new LinkedHashMap<>();\n        pillars.put(\"Reliability\", List.of(\"Implement region failover\", \"Drop MTTR below 20m\"));\n        pillars.put(\"Product\", List.of(\"Adaptive pricing\", \"Cross-store search\"));\n        pillars.put(\"Platform\", List.of(\"Unified CI/CD pipeline\"));\n\n        System.out.println(\"Roadmap Pillars\");\n        for (Map.Entry<String, List<String>> entry : pillars.entrySet()) {\n            System.out.println(entry.getKey() + \":\");\n            for (String initiative : entry.getValue()) {\n                System.out.println(\"- \" + initiative);\n            }\n        }\n    }\n}\n",
      "expectedOutput": "Roadmap Pillars\nReliability:\n- Implement region failover\n- Drop MTTR below 20m\nProduct:\n- Adaptive pricing\n- Cross-store search\nPlatform:\n- Unified CI/CD pipeline",
      "tutorial": "      <p class=\"mb-4 text-gray-300\">Strategic storytelling is a senior skill. Use a nested loop to keep initiatives grouped with their pillar.</p>\n      <h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n      <div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"Platform:\");\nSystem.out.println(\"- Unified CI/CD pipeline\");</pre></div>\n      <p class=\"mt-4 text-gray-300\">Readable summaries help execs process the plan quickly.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding roadmap pillar summary is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying roadmap pillar summary, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply roadmap pillar summary will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with roadmap pillar summary, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 284,
      "title": "284. Experiment Result Synthesizer",
      "language": "java",
      "description": "Report experiment deltas and percentage lift so launch decisions stay data-driven.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String[] names = {\"Checkout copy\", \"Recommendation ranking\"};\n        String[] metrics = {\"conversion\", \"session revenue\"};\n        double[] control = {0.342, 7.80};\n        double[] treatment = {0.361, 8.05};\n\n        // TODO: print the heading then each experiment with signed delta (3 decimals) and lift percentage (2 decimals)\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String[] names = {\"Checkout copy\", \"Recommendation ranking\"};\n        String[] metrics = {\"conversion\", \"session revenue\"};\n        double[] control = {0.342, 7.80};\n        double[] treatment = {0.361, 8.05};\n\n        System.out.println(\"Experiment Results\");\n        for (int i = 0; i < names.length; i++) {\n            double delta = treatment[i] - control[i];\n            double lift = control[i] == 0 ? 0.0 : (delta / control[i]) * 100;\n            System.out.printf(\n                \"%s (%s): delta=%+.3f, lift=%+.2f%%%n\",\n                names[i], metrics[i], delta, lift\n            );\n        }\n    }\n}\n",
      "expectedOutput": "Experiment Results\nCheckout copy (conversion): delta=+0.019, lift=+5.56%\nRecommendation ranking (session revenue): delta=+0.250, lift=+3.21%",
      "tutorial": "      <p class=\"mb-4 text-gray-300\">Launch reviews need both absolute and relative movement. Use <code>%+.3f</code> for signed deltas and <code>%+.2f</code> for lift so decisions stay grounded.</p>\n      <h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n      <div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">double delta = treatment - control;\nSystem.out.printf(\"%+.3f\", delta);</pre></div>\n      <p class=\"mt-4 text-gray-300\">Consistent formatting means no one has to recompute the numbers mid-meeting.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding experiment result synthesizer is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying experiment result synthesizer, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply experiment result synthesizer will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with experiment result synthesizer, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "OOP",
        "Web"
      ]
    },
    {
      "id": 285,
      "title": "285. StampedLock optimistic read",
      "language": "java",
      "description": "Write 42 under a StampedLock and read it back with an optimistic read fallback.",
      "initialCode": "import java.util.concurrent.locks.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        StampedLock lock = new StampedLock();\n        int[] value = {0};\n\n        // TODO: write 42 with the write lock, then read it using tryOptimisticRead with a read-lock fallback and print it\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.locks.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        StampedLock lock = new StampedLock();\n        int[] value = {0};\n\n        long writeStamp = lock.writeLock();\n        try {\n            value[0] = 42;\n        } finally {\n            lock.unlockWrite(writeStamp);\n        }\n\n        long stamp = lock.tryOptimisticRead();\n        int result = value[0];\n        if (!lock.validate(stamp)) {\n            stamp = lock.readLock();\n            try {\n                result = value[0];\n            } finally {\n                lock.unlockRead(stamp);\n            }\n        }\n\n        System.out.println(result);\n    }\n}\n",
      "expectedOutput": "42",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>StampedLock</code> supports optimistic reads: grab a stamp with <code>tryOptimisticRead()</code> and fall back to a read lock if another writer intervened.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">StampedLock lock = new StampedLock();\nlong stamp = lock.tryOptimisticRead();\nif (!lock.validate(stamp)) {\n    stamp = lock.readLock();\n    lock.unlockRead(stamp);\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding stampedlock optimistic read is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying stampedlock optimistic read, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply stampedlock optimistic read will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with stampedlock optimistic read, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "OOP",
        "I/O",
        "Concurrency"
      ]
    },
    {
      "id": 286,
      "title": "286. Phaser phase coordination",
      "language": "java",
      "description": "Coordinate two workers through a two-phase barrier and print progress from the main thread.",
      "initialCode": "import java.util.concurrent.Phaser;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Phaser phaser = new Phaser(3); // 2 workers + main\n\n        Runnable worker = () -> {\n            // TODO: wait for phase 0 to advance, simulate work, then signal phase 1 complete\n        };\n\n        Thread a = new Thread(worker, \"A\");\n        Thread b = new Thread(worker, \"B\");\n        a.start();\n        b.start();\n\n        // TODO: release phase 0, wait for workers to finish, then print the status lines and join threads\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.Phaser;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Phaser phaser = new Phaser(3); // 2 workers + main\n\n        Runnable worker = () -> {\n            phaser.arriveAndAwaitAdvance();\n            try {\n                Thread.sleep(50);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n            phaser.arriveAndAwaitAdvance();\n            phaser.arriveAndDeregister();\n        };\n\n        Thread a = new Thread(worker, \"A\");\n        Thread b = new Thread(worker, \"B\");\n        a.start();\n        b.start();\n\n        System.out.println(\"Phase 0 ready\");\n        phaser.arriveAndAwaitAdvance();\n        System.out.println(\"Phase 1 complete\");\n        phaser.arriveAndAwaitAdvance();\n        System.out.println(\"done\");\n\n        a.join();\n        b.join();\n        phaser.arriveAndDeregister();\n    }\n}\n",
      "expectedOutput": "Phase 0 ready\nPhase 1 complete\ndone",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>Phaser</code> lets you synchronize dynamic parties over multiple phases. Each <code>arriveAndAwaitAdvance()</code> blocks until all registered parties reach the same phase.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Phaser ph = new Phaser(3);\nph.arriveAndAwaitAdvance(); // release workers\nph.arriveAndAwaitAdvance(); // wait for completion</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding phaser phase coordination is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying phaser phase coordination, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply phaser phase coordination will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with phaser phase coordination, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Strings",
        "OOP",
        "Concurrency"
      ]
    },
    {
      "id": 287,
      "title": "287. LinkedBlockingQueue producer/consumer",
      "language": "java",
      "description": "Use a LinkedBlockingQueue to sum produced values and print the total once both threads finish.",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        int[] total = {0};\n\n        Thread producer = new Thread(() -> {\n            // TODO: put numbers 1..5 on the queue then a sentinel 0\n        });\n\n        Thread consumer = new Thread(() -> {\n            // TODO: take values until the sentinel and accumulate the sum into total[0]\n        });\n\n        // TODO: start both threads, wait for them to finish, then print total[0]\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        int[] total = {0};\n\n        Thread producer = new Thread(() -> {\n            try {\n                for (int i = 1; i <= 5; i++) {\n                    queue.put(i);\n                }\n                queue.put(0); // sentinel\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        });\n\n        Thread consumer = new Thread(() -> {\n            int sum = 0;\n            try {\n                while (true) {\n                    int value = queue.take();\n                    if (value == 0) {\n                        break;\n                    }\n                    sum += value;\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n            total[0] = sum;\n        });\n\n        producer.start();\n        consumer.start();\n        producer.join();\n        consumer.join();\n        System.out.println(total[0]);\n    }\n}\n",
      "expectedOutput": "15",
      "tutorial": "<p class=\"mb-4 text-gray-300\">A <code>BlockingQueue</code> coordinates producer and consumer threads without busy waiting. Use a sentinel to signal completion.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">BlockingQueue<Integer> q = new LinkedBlockingQueue<>();\nq.put(1);\nint v = q.take();</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding linkedblockingqueue producer/consumer is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying linkedblockingqueue producer/consumer, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply linkedblockingqueue producer/consumer will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with linkedblockingqueue producer/consumer, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Strings",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 288,
      "title": "288. CompletableFuture.handle",
      "language": "java",
      "description": "Recover from a failed async computation with handle and print a fallback value.",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // TODO: start from a failed future, recover with handle, and print \"fallback\"\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        CompletableFuture<String> failed = CompletableFuture.failedFuture(new RuntimeException(\"boom\"));\n        CompletableFuture<String> recovered = failed.handle((value, error) -> error == null ? value : \"fallback\");\n        System.out.println(recovered.join());\n    }\n}\n",
      "expectedOutput": "fallback",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>handle</code> sees both the value and the exception. Combine it with <code>failedFuture</code> to model failure and supply a fallback without branching helpers.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">CompletableFuture.failedFuture(new RuntimeException())\n    .handle((v, ex) -> ex == null ? v : \"fallback\");</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding completablefuture.handle is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying completablefuture.handle, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply completablefuture.handle will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with completablefuture.handle, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Strings",
        "OOP",
        "Concurrency",
        "Async"
      ]
    },
    {
      "id": 289,
      "title": "289. CyclicBarrier rendezvous",
      "language": "java",
      "description": "Use a CyclicBarrier to pause two worker threads until the main thread reaches the barrier, then print release and done.",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        CyclicBarrier barrier = new CyclicBarrier(3, () -> System.out.println(\"release\"));\n\n        Runnable worker = () -> {\n            try {\n                barrier.await();\n            } catch (InterruptedException | BrokenBarrierException e) {\n                throw new RuntimeException(e);\n            }\n        };\n\n        Thread a = new Thread(worker, \"A\");\n        Thread b = new Thread(worker, \"B\");\n        a.start();\n        b.start();\n\n        // TODO: print \"ready\", wait on the barrier, then print \"done\" after it trips\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        CyclicBarrier barrier = new CyclicBarrier(3, () -> System.out.println(\"release\"));\n\n        Runnable worker = () -> {\n            try {\n                barrier.await();\n            } catch (InterruptedException | BrokenBarrierException e) {\n                throw new RuntimeException(e);\n            }\n        };\n\n        Thread a = new Thread(worker, \"A\");\n        Thread b = new Thread(worker, \"B\");\n        a.start();\n        b.start();\n\n        System.out.println(\"ready\");\n        barrier.await();\n        System.out.println(\"done\");\n\n        a.join();\n        b.join();\n    }\n}\n",
      "expectedOutput": "ready\nrelease\ndone",
      "tutorial": "<p class=\"mb-4 text-gray-300\">A <code>CyclicBarrier</code> lets multiple threads rendezvous at the same point before proceeding. The optional barrier action runs once when the last party arrives.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">CyclicBarrier barrier = new CyclicBarrier(3, () -> System.out.println(\"trip\"));\nbarrier.await();</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding cyclicbarrier rendezvous is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying cyclicbarrier rendezvous, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply cyclicbarrier rendezvous will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with cyclicbarrier rendezvous, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Strings",
        "OOP",
        "Concurrency",
        "Async"
      ]
    },
    {
      "id": 290,
      "title": "290. ExecutorCompletionService gather",
      "language": "java",
      "description": "Collect tasks as they finish using ExecutorCompletionService and print results in completion order.",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        ExecutorService pool = Executors.newFixedThreadPool(2);\n        try {\n            CompletionService<String> service = new ExecutorCompletionService<>(pool);\n            service.submit(() -> { Thread.sleep(30); return \"slow\"; });\n            service.submit(() -> \"fast\");\n\n            // TODO: take completed futures and print their results as they finish\n        } finally {\n            pool.shutdown();\n        }\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        ExecutorService pool = Executors.newFixedThreadPool(2);\n        try {\n            CompletionService<String> service = new ExecutorCompletionService<>(pool);\n            service.submit(() -> { Thread.sleep(30); return \"slow\"; });\n            service.submit(() -> \"fast\");\n\n            for (int i = 0; i < 2; i++) {\n                System.out.println(service.take().get());\n            }\n        } finally {\n            pool.shutdown();\n        }\n    }\n}\n",
      "expectedOutput": "fast\nslow",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>ExecutorCompletionService</code> wraps a pool and yields completed tasks as they finish, so you can react in completion order without polling.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">CompletionService<String> cs = new ExecutorCompletionService<>(pool);\ncs.submit(callable);\nFuture<String> done = cs.take();</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding executorcompletionservice gather is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying executorcompletionservice gather, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply executorcompletionservice gather will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with executorcompletionservice gather, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Functions",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 291,
      "title": "291. ConcurrentLinkedQueue audit",
      "language": "java",
      "description": "Add and remove items from a ConcurrentLinkedQueue and print the values observed.",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        ConcurrentLinkedQueue<String> queue = new ConcurrentLinkedQueue<>();\n        // TODO: offer \"alpha\" and \"beta\", poll one, peek at the next, then print the size\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        ConcurrentLinkedQueue<String> queue = new ConcurrentLinkedQueue<>();\n        queue.offer(\"alpha\");\n        queue.offer(\"beta\");\n        System.out.println(queue.poll());\n        System.out.println(queue.peek());\n        System.out.println(queue.size());\n    }\n}\n",
      "expectedOutput": "alpha\nbeta\n1",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use <code>ConcurrentLinkedQueue</code> for lock-free, thread-safe queues suited to producer/consumer patterns.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">ConcurrentLinkedQueue<String> q = new ConcurrentLinkedQueue<>();\nq.offer(\"event\");\nString item = q.poll();</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding concurrentlinkedqueue audit is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying concurrentlinkedqueue audit, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply concurrentlinkedqueue audit will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with concurrentlinkedqueue audit, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Concurrency"
      ]
    },
    {
      "id": 292,
      "title": "292. DelayQueue ordering",
      "language": "java",
      "description": "Use a DelayQueue to delay two tasks and show that take() returns them in readiness order.",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n    static class Task implements Delayed {\n        final String name;\n        final long readyAt;\n\n        Task(String name, long delayMillis) {\n            this.name = name;\n            this.readyAt = System.currentTimeMillis() + delayMillis;\n        }\n\n        @Override\n        public long getDelay(TimeUnit unit) {\n            long remaining = readyAt - System.currentTimeMillis();\n            return unit.convert(remaining, TimeUnit.MILLISECONDS);\n        }\n\n        @Override\n        public int compareTo(Delayed other) {\n            Task o = (Task) other;\n            return Long.compare(this.readyAt, o.readyAt);\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        DelayQueue<Task> queue = new DelayQueue<>();\n        // TODO: add Task(\"fast\", 10) and Task(\"slow\", 30), then take twice and print each name\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n    static class Task implements Delayed {\n        final String name;\n        final long readyAt;\n\n        Task(String name, long delayMillis) {\n            this.name = name;\n            this.readyAt = System.currentTimeMillis() + delayMillis;\n        }\n\n        @Override\n        public long getDelay(TimeUnit unit) {\n            long remaining = readyAt - System.currentTimeMillis();\n            return unit.convert(remaining, TimeUnit.MILLISECONDS);\n        }\n\n        @Override\n        public int compareTo(Delayed other) {\n            Task o = (Task) other;\n            return Long.compare(this.readyAt, o.readyAt);\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        DelayQueue<Task> queue = new DelayQueue<>();\n        queue.add(new Task(\"fast\", 10));\n        queue.add(new Task(\"slow\", 30));\n        System.out.println(queue.take().name);\n        System.out.println(queue.take().name);\n    }\n}\n",
      "expectedOutput": "fast\nslow",
      "tutorial": "<p class=\"mb-4 text-gray-300\">A <code>DelayQueue</code> releases elements only after their delay expires. Implement <code>Delayed</code> and use <code>take()</code> to block until the head is ready.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">DelayQueue<MyTask> q = new DelayQueue<>();\nq.put(new MyTask(100));\nSystem.out.println(q.take());</pre></div>\n<p class=\"mt-4 text-gray-300\">Even if you enqueue slower tasks first, the queue orders by remaining delay.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding delayqueue ordering is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying delayqueue ordering, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply delayqueue ordering will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with delayqueue ordering, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Concurrency"
      ]
    },
    {
      "id": 293,
      "title": "293. CompletableFuture applyToEither",
      "language": "java",
      "description": "Race two futures with applyToEither and print the winning result with a suffix.",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        CompletableFuture<String> primary = CompletableFuture.supplyAsync(() -> {\n            sleep(40);\n            return \"primary\";\n        });\n        CompletableFuture<String> backup = CompletableFuture.supplyAsync(() -> \"backup\");\n\n        // TODO: use applyToEither to print the first result followed by \" winner\"\n    }\n\n    private static void sleep(long millis) {\n        try {\n            Thread.sleep(millis);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        CompletableFuture<String> primary = CompletableFuture.supplyAsync(() -> {\n            sleep(40);\n            return \"primary\";\n        });\n        CompletableFuture<String> backup = CompletableFuture.supplyAsync(() -> \"backup\");\n\n        primary.applyToEither(backup, winner -> winner + \" winner\")\n               .thenAccept(System.out::println)\n               .join();\n    }\n\n    private static void sleep(long millis) {\n        try {\n            Thread.sleep(millis);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n",
      "expectedOutput": "backup winner",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use <code>applyToEither</code> to react to whichever future completes first. The slower branch is still allowed to finish, but you can ignore or cancel it if desired.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">primary.applyToEither(backup, x -> x + \" ok\")\n       .thenAccept(System.out::println);\n</pre></div>\n<p class=\"mt-4 text-gray-300\">This is perfect for primary/backup calls where you just need the fastest healthy response.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding completablefuture applytoeither is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying completablefuture applytoeither, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply completablefuture applytoeither will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with completablefuture applytoeither, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Strings",
        "OOP",
        "Networking"
      ]
    },
    {
      "id": 294,
      "title": "294. Exchanger handoff",
      "language": "java",
      "description": "Swap messages between two threads with Exchanger and print the one received by main.",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Exchanger<String> exchanger = new Exchanger<>();\n\n        Thread worker = new Thread(() -> {\n            try {\n                exchanger.exchange(\"ping\");\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n\n        worker.start();\n\n        // TODO: exchange \"pong\" on the main thread, print the received value, then join worker\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Exchanger<String> exchanger = new Exchanger<>();\n\n        Thread worker = new Thread(() -> {\n            try {\n                exchanger.exchange(\"ping\");\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n\n        worker.start();\n\n        String received = exchanger.exchange(\"pong\");\n        System.out.println(received);\n        worker.join();\n    }\n}\n",
      "expectedOutput": "ping",
      "tutorial": "<p class=\"mb-4 text-gray-300\">An <code>Exchanger</code> is a rendezvous point where two threads swap objects. Each <code>exchange</code> call blocks until a partner arrives.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">String fromPeer = exchanger.exchange(\"data\");\n</pre></div>\n<p class=\"mt-4 text-gray-300\">Use it to hand buffers back and forth between producer and consumer phases without extra queues.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding exchanger handoff is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying exchanger handoff, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply exchanger handoff will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with exchanger handoff, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Strings",
        "OOP",
        "Concurrency",
        "Error Handling"
      ]
    },
    {
      "id": 295,
      "title": "295. SynchronousQueue rendezvous",
      "language": "java",
      "description": "Coordinate a handoff with SynchronousQueue so the consumer prints the produced value.",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        SynchronousQueue<String> queue = new SynchronousQueue<>();\n\n        Thread producer = new Thread(() -> {\n            try {\n                queue.put(\"data\");\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n\n        producer.start();\n\n        // TODO: take from the queue, print it, then join the producer\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        SynchronousQueue<String> queue = new SynchronousQueue<>();\n\n        Thread producer = new Thread(() -> {\n            try {\n                queue.put(\"data\");\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n\n        producer.start();\n\n        System.out.println(queue.take());\n        producer.join();\n    }\n}\n",
      "expectedOutput": "data",
      "tutorial": "<p class=\"mb-4 text-gray-300\">A <code>SynchronousQueue</code> has no capacity: producers block until a consumer takes, and vice versa. It's ideal for direct handoffs.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">SynchronousQueue<String> q = new SynchronousQueue<>();\nnew Thread(() -> q.put(\"ready\")).start();\nSystem.out.println(q.take());\n</pre></div>\n<p class=\"mt-4 text-gray-300\">This pattern keeps pressure low when you only need to transfer ownership of a single item at a time.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding synchronousqueue rendezvous is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying synchronousqueue rendezvous, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply synchronousqueue rendezvous will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with synchronousqueue rendezvous, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Strings",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 296,
      "title": "296. LongAccumulator max",
      "language": "java",
      "description": "Use a LongAccumulator with a max function to track the highest value submitted from multiple tasks and print 42.",
      "initialCode": "import java.util.concurrent.*;\nimport java.util.concurrent.atomic.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        LongAccumulator max = new LongAccumulator(Long::max, Long.MIN_VALUE);\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        long[] values = {7, 42, 13};\n\n        // TODO: submit accumulation tasks for each value, wait for completion, then print the maximum\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.*;\nimport java.util.concurrent.atomic.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        LongAccumulator max = new LongAccumulator(Long::max, Long.MIN_VALUE);\n        ExecutorService pool = Executors.newFixedThreadPool(3);\n        long[] values = {7, 42, 13};\n\n        for (long value : values) {\n            pool.submit(() -> max.accumulate(value));\n        }\n\n        pool.shutdown();\n        pool.awaitTermination(1, TimeUnit.SECONDS);\n        System.out.println(max.get());\n    }\n}\n",
      "expectedOutput": "42",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use <code>LongAccumulator</code> to combine values across threads without explicit locking. Supply a function (max, sum, etc.) and an identity seed.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">LongAccumulator max = new LongAccumulator(Long::max, Long.MIN_VALUE);\nmax.accumulate(10);\nmax.accumulate(42);\nSystem.out.println(max.get()); // 42</pre></div>\n<p class=\"mt-4 text-gray-300\">Accumulators scale under contention better than synchronized counters.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding longaccumulator max is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying longaccumulator max, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply longaccumulator max will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with longaccumulator max, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Functions",
        "OOP",
        "Algorithms"
      ]
    },
    {
      "id": 297,
      "title": "297. CompletableFuture.orTimeout fail fast",
      "language": "java",
      "description": "Trigger a timeout on a slow CompletableFuture using orTimeout and recover to print \"timeout\".",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        CompletableFuture<String> slow = CompletableFuture.supplyAsync(() -> {\n            try {\n                Thread.sleep(50);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            return \"slow\";\n        });\n\n        // TODO: apply orTimeout with 10 milliseconds, recover with exceptionally, and print \"timeout\"\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        CompletableFuture<String> slow = CompletableFuture.supplyAsync(() -> {\n            try {\n                Thread.sleep(50);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            return \"slow\";\n        });\n\n        String result = slow\n            .orTimeout(10, TimeUnit.MILLISECONDS)\n            .exceptionally(ex -> \"timeout\")\n            .join();\n        System.out.println(result);\n    }\n}\n",
      "expectedOutput": "timeout",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use <code>orTimeout</code> to automatically fail a slow stage instead of waiting indefinitely.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">CompletableFuture<String> slow = ...;\nslow.orTimeout(100, TimeUnit.MILLISECONDS)\n    .exceptionally(ex -> \"fallback\")\n    .join();</pre></div>\n<p class=\"mt-4 text-gray-300\">Timeouts keep latency budgets enforced without custom scheduling code.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding completablefuture.ortimeout fail fast is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying completablefuture.ortimeout fail fast, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply completablefuture.ortimeout fail fast will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with completablefuture.ortimeout fail fast, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Strings",
        "OOP",
        "Concurrency",
        "Async"
      ]
    },
    {
      "id": 298,
      "title": "298. Stream.mapMulti flatten groups",
      "language": "java",
      "description": "Flatten nested lists with mapMulti and print \"1 2 3 4\".",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<List<Integer>> groups = List.of(\n            List.of(1, 2),\n            List.of(3, 4)\n        );\n\n        // TODO: use mapMulti to flatten groups into a single stream and print \"1 2 3 4\"\n    }\n}\n",
      "fullSolution": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<List<Integer>> groups = List.of(\n            List.of(1, 2),\n            List.of(3, 4)\n        );\n\n        String flattened = groups.stream()\n            .mapMulti((list, downstream) -> {\n                for (Integer value : list) {\n                    downstream.accept(value);\n                }\n            })\n            .map(String::valueOf)\n            .collect(Collectors.joining(\" \"));\n        System.out.println(flattened);\n    }\n}\n",
      "expectedOutput": "1 2 3 4",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>mapMulti</code> lets you push zero, one, or many elements downstream without creating intermediate streams.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">stream.mapMulti((list, downstream) -> {\n    for (var item : list) {\n        downstream.accept(item);\n    }\n});</pre></div>\n<p class=\"mt-4 text-gray-300\">It avoids allocation compared to <code>flatMap</code> when you already have iterable data.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding stream.mapmulti flatten groups is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying stream.mapmulti flatten groups, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply stream.mapmulti flatten groups will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with stream.mapmulti flatten groups, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Functional"
      ]
    },
    {
      "id": 299,
      "title": "299. Collectors.teeing min/max summary",
      "language": "java",
      "description": "Use Collectors.teeing to compute min and max from numbers and print \"min=2 max=11\".",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> numbers = List.of(7, 3, 11, 2, 9);\n\n        // TODO: collect with Collectors.teeing to produce \"min=2 max=11\" and print it\n    }\n}\n",
      "fullSolution": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> numbers = List.of(7, 3, 11, 2, 9);\n\n        String summary = numbers.stream()\n            .collect(Collectors.teeing(\n                Collectors.minBy(Integer::compareTo),\n                Collectors.maxBy(Integer::compareTo),\n                (min, max) -> \"min=\" + min.orElseThrow() + \" max=\" + max.orElseThrow()\n            ));\n        System.out.println(summary);\n    }\n}\n",
      "expectedOutput": "min=2 max=11",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Combine two collectors in one pass with <code>Collectors.teeing</code> for efficient summaries.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">var summary = numbers.stream()\n    .collect(Collectors.teeing(\n        Collectors.counting(),\n        Collectors.averagingDouble(x -> x),\n        (count, avg) -> count + \"/\" + avg\n    ));</pre></div>\n<p class=\"mt-4 text-gray-300\">Great for stats that previously needed multiple passes or mutable holders.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding collectors.teeing min/max summary is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying collectors.teeing min/max summary, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply collectors.teeing min/max summary will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with collectors.teeing min/max summary, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Functional"
      ]
    },
    {
      "id": 300,
      "title": "300. PriorityBlockingQueue ordering",
      "language": "java",
      "description": "Insert numbers into a PriorityBlockingQueue and poll them to print 1, 2, 3 each on a new line.",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        PriorityBlockingQueue<Integer> queue = new PriorityBlockingQueue<>();\n\n        // TODO: add 3, 1, 2 into the queue, then take and print them in priority order\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        PriorityBlockingQueue<Integer> queue = new PriorityBlockingQueue<>();\n\n        queue.put(3);\n        queue.put(1);\n        queue.put(2);\n\n        for (int i = 0; i < 3; i++) {\n            System.out.println(queue.take());\n        }\n    }\n}\n",
      "expectedOutput": "1\n2\n3",
      "tutorial": "<p class=\"mb-4 text-gray-300\">A <code>PriorityBlockingQueue</code> orders elements by priority while supporting blocking producers/consumers.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">PriorityBlockingQueue<Integer> q = new PriorityBlockingQueue<>();\nq.put(5);\nq.put(2);\nSystem.out.println(q.take()); // 2</pre></div>\n<p class=\"mt-4 text-gray-300\">Use it for work queues where higher-priority tasks must run first.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding priorityblockingqueue ordering is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying priorityblockingqueue ordering, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply priorityblockingqueue ordering will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with priorityblockingqueue ordering, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Concurrency"
      ]
    },
    {
      "id": 301,
      "title": "301. Module Descriptor Summary",
      "language": "java",
      "description": "Summarize the key sections of a JPMS module descriptor in prose form.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Map<String, Object> module = new LinkedHashMap<>();\n    module.put(\"name\", \"com.example.inventory\");\n    module.put(\"requires\", List.of(\"java.sql\", \"com.fasterxml.jackson\"));\n    module.put(\"exports\", List.of(\"com.example.inventory.api\", \"com.example.inventory.domain\"));\n    module.put(\"opens\", List.of(\"com.example.inventory.config\"));\n    module.put(\"provides\", Map.of(\n        \"com.example.spi.InventoryProvider\",\n        \"com.example.inventory.internal.DbInventoryProvider\"\n    ));\n\n    // TODO: print exactly:\n    // Module Descriptor\n    // Name: com.example.inventory\n    // Requires: java.sql, com.fasterxml.jackson\n    // Exports:\n    // - com.example.inventory.api\n    // - com.example.inventory.domain\n    // Opens:\n    // - com.example.inventory.config\n    // Provides:\n    // - com.example.spi.InventoryProvider -> com.example.inventory.internal.DbInventoryProvider\n  }\n}\n",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Map<String, Object> module = new LinkedHashMap<>();\n    module.put(\"name\", \"com.example.inventory\");\n    module.put(\"requires\", List.of(\"java.sql\", \"com.fasterxml.jackson\"));\n    module.put(\"exports\", List.of(\"com.example.inventory.api\", \"com.example.inventory.domain\"));\n    module.put(\"opens\", List.of(\"com.example.inventory.config\"));\n    module.put(\"provides\", Map.of(\n        \"com.example.spi.InventoryProvider\",\n        \"com.example.inventory.internal.DbInventoryProvider\"\n    ));\n\n    System.out.println(\"Module Descriptor\");\n    System.out.println(\"Name: \" + module.get(\"name\"));\n    System.out.println(\"Requires: \" + String.join(\", \", (List<String>) module.get(\"requires\")));\n    System.out.println(\"Exports:\");\n    for (String pkg : (List<String>) module.get(\"exports\")) {\n      System.out.println(\"- \" + pkg);\n    }\n    System.out.println(\"Opens:\");\n    for (String pkg : (List<String>) module.get(\"opens\")) {\n      System.out.println(\"- \" + pkg);\n    }\n    System.out.println(\"Provides:\");\n    Map<String, String> provides = (Map<String, String>) module.get(\"provides\");\n    for (Map.Entry<String, String> entry : provides.entrySet()) {\n      System.out.println(\"- \" + entry.getKey() + \" -> \" + entry.getValue());\n    }\n  }\n}\n",
      "expectedOutput": "Module Descriptor\nName: com.example.inventory\nRequires: java.sql, com.fasterxml.jackson\nExports:\n- com.example.inventory.api\n- com.example.inventory.domain\nOpens:\n- com.example.inventory.config\nProvides:\n- com.example.spi.InventoryProvider -> com.example.inventory.internal.DbInventoryProvider",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Listing exports, opens, and provides together gives reviewers quick confidence that the module boundary is intentional.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Reminder:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"Provides:\");</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding module descriptor summary is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying module descriptor summary, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply module descriptor summary will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with module descriptor summary, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Strings",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 302,
      "title": "302. Service Loader Wiring",
      "language": "java",
      "description": "Outline how a service interface maps to provider implementations and the configuration file that binds them.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Map<String, Object> wiring = new LinkedHashMap<>();\n    wiring.put(\"service\", \"com.example.spi.InventoryProvider\");\n    wiring.put(\"providers\", List.of(\n        \"com.example.inventory.DbProvider\",\n        \"com.example.inventory.CacheProvider\"\n    ));\n    wiring.put(\"moduleHint\", \"module com.example.inventory { provides com.example.spi.InventoryProvider with com.example.inventory.DbProvider, com.example.inventory.CacheProvider; }\");\n    wiring.put(\"configFile\", \"META-INF/services/com.example.spi.InventoryProvider\");\n\n    // TODO: print exactly:\n    // Service Loader Wiring\n    // Service: com.example.spi.InventoryProvider\n    // Providers:\n    // - com.example.inventory.DbProvider\n    // - com.example.inventory.CacheProvider\n    // Module hint: module ...\n    // Config file: META-INF/services/com.example.spi.InventoryProvider\n  }\n}\n",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Map<String, Object> wiring = new LinkedHashMap<>();\n    wiring.put(\"service\", \"com.example.spi.InventoryProvider\");\n    wiring.put(\"providers\", List.of(\n        \"com.example.inventory.DbProvider\",\n        \"com.example.inventory.CacheProvider\"\n    ));\n    wiring.put(\"moduleHint\", \"module com.example.inventory { provides com.example.spi.InventoryProvider with com.example.inventory.DbProvider, com.example.inventory.CacheProvider; }\");\n    wiring.put(\"configFile\", \"META-INF/services/com.example.spi.InventoryProvider\");\n\n    System.out.println(\"Service Loader Wiring\");\n    System.out.println(\"Service: \" + wiring.get(\"service\"));\n    System.out.println(\"Providers:\");\n    for (String provider : (List<String>) wiring.get(\"providers\")) {\n      System.out.println(\"- \" + provider);\n    }\n    System.out.println(\"Module hint: \" + wiring.get(\"moduleHint\"));\n    System.out.println(\"Config file: \" + wiring.get(\"configFile\"));\n  }\n}\n",
      "expectedOutput": "Service Loader Wiring\nService: com.example.spi.InventoryProvider\nProviders:\n- com.example.inventory.DbProvider\n- com.example.inventory.CacheProvider\nModule hint: module com.example.inventory { provides com.example.spi.InventoryProvider with com.example.inventory.DbProvider, com.example.inventory.CacheProvider; }\nConfig file: META-INF/services/com.example.spi.InventoryProvider",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Spell out both the module declaration and META-INF services file so runtime discovery never depends on tribal knowledge.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"Providers:\");</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding service loader wiring is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying service loader wiring, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply service loader wiring will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with service loader wiring, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Security"
      ]
    },
    {
      "id": 303,
      "title": "303. Text Block HTML Template",
      "language": "java",
      "description": "Use a Java text block to hold a small HTML template and print it verbatim.",
      "initialCode": "public class Main {\n  public static void main(String[] args) {\n    // TODO: define a text block assigned to html that renders the status page and print it\n  }\n}\n",
      "fullSolution": "public class Main {\n  public static void main(String[] args) {\n    String html = \"\"\"\n<!DOCTYPE html>\n<html lang=\\\"en\\\">\n<head><title>Status</title></head>\n<body>\n  <h1>OK</h1>\n</body>\n</html>\n\"\"\";\n    System.out.println(html);\n  }\n}\n",
      "expectedOutput": "<!DOCTYPE html>\n<html lang=\"en\">\n<head><title>Status</title></head>\n<body>\n  <h1>OK</h1>\n</body>\n</html>",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Text blocks preserve indentation and quotes, making embedded templates far easier to read.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">String html = \"\"\"...\"\"\";</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding text block html template is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying text block html template, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply text block html template will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with text block html template, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "OOP",
        "Web",
        "Concurrency"
      ]
    },
    {
      "id": 304,
      "title": "304. Switch Expression Routing",
      "language": "java",
      "description": "Route an environment name to a base URL using a switch expression and print the result.",
      "initialCode": "public class Main {\n  public static void main(String[] args) {\n    String env = \"staging\";\n\n    // TODO: use a switch expression to map env to the correct URL and print it\n    // local -> http://localhost:8080\n    // staging -> https://staging.example.com\n    // prod -> https://example.com\n  }\n}\n",
      "fullSolution": "public class Main {\n  public static void main(String[] args) {\n    String env = \"staging\";\n\n    String url = switch (env) {\n      case \"local\" -> \"http://localhost:8080\";\n      case \"staging\" -> \"https://staging.example.com\";\n      case \"prod\" -> \"https://example.com\";\n      default -> throw new IllegalArgumentException(\"Unknown environment: \" + env);\n    };\n\n    System.out.println(url);\n  }\n}\n",
      "expectedOutput": "https://staging.example.com",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Switch expressions remove fallthrough bugs and make routing tables readable.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Reminder:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">String url = switch (env) { ... };</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding switch expression routing is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying switch expression routing, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply switch expression routing will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with switch expression routing, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Networking"
      ]
    },
    {
      "id": 305,
      "title": "305. Virtual Thread Launch Plan",
      "language": "java",
      "description": "Capture the rollout steps for adopting virtual threads in a service.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String[] steps = {\n            \"Enable --enable-preview in staging\",\n            \"Switch ExecutorService to newVirtualThreadPerTaskExecutor\",\n            \"Load test with 10x concurrency\",\n            \"Roll forward to production\",\n        };\n\n        // TODO: print exactly:\n        // Virtual Thread Launch Plan\n        // 1. Enable --enable-preview in staging\n        // 2. Switch ExecutorService to newVirtualThreadPerTaskExecutor\n        // 3. Load test with 10x concurrency\n        // 4. Roll forward to production\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String[] steps = {\n            \"Enable --enable-preview in staging\",\n            \"Switch ExecutorService to newVirtualThreadPerTaskExecutor\",\n            \"Load test with 10x concurrency\",\n            \"Roll forward to production\",\n        };\n\n        System.out.println(\"Virtual Thread Launch Plan\");\n        for (int i = 0; i < steps.length; i++) {\n            System.out.println((i + 1) + \". \" + steps[i]);\n        }\n    }\n}\n",
      "expectedOutput": "Virtual Thread Launch Plan\n1. Enable --enable-preview in staging\n2. Switch ExecutorService to newVirtualThreadPerTaskExecutor\n3. Load test with 10x concurrency\n4. Roll forward to production",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Document the preview flag and load-testing expectations so migrations stay controlled.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">for (int i = 0; i < steps.length; i++)</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding virtual thread launch plan is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying virtual thread launch plan, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply virtual thread launch plan will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with virtual thread launch plan, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "OOP",
        "Algorithms",
        "Web"
      ]
    },
    {
      "id": 306,
      "title": "306. jlink Image Checklist",
      "language": "java",
      "description": "Lay out the commands required to produce a trimmed runtime image with jlink.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String[][] checklist = {\n            {\"Prepare\", \"jdeps --multi-release 21 --print-module-deps --ignore-missing-deps app.jar\"},\n            {\"Assemble\", \"jlink --add-modules com.example.inventory,java.sql --output build/image\"},\n            {\"Verify\", \"build/image/bin/java -m com.example.inventory\"},\n        };\n\n        // TODO: print exactly:\n        // jlink Image Checklist\n        // 1. Prepare: jdeps --multi-release 21 --print-module-deps --ignore-missing-deps app.jar\n        // 2. Assemble: jlink --add-modules com.example.inventory,java.sql --output build/image\n        // 3. Verify: build/image/bin/java -m com.example.inventory\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String[][] checklist = {\n            {\"Prepare\", \"jdeps --multi-release 21 --print-module-deps --ignore-missing-deps app.jar\"},\n            {\"Assemble\", \"jlink --add-modules com.example.inventory,java.sql --output build/image\"},\n            {\"Verify\", \"build/image/bin/java -m com.example.inventory\"},\n        };\n\n        System.out.println(\"jlink Image Checklist\");\n        for (int i = 0; i < checklist.length; i++) {\n            System.out.println((i + 1) + \". \" + checklist[i][0] + \": \" + checklist[i][1]);\n        }\n    }\n}\n",
      "expectedOutput": "jlink Image Checklist\n1. Prepare: jdeps --multi-release 21 --print-module-deps --ignore-missing-deps app.jar\n2. Assemble: jlink --add-modules com.example.inventory,java.sql --output build/image\n3. Verify: build/image/bin/java -m com.example.inventory",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Pair jdeps with jlink so runtime trimming stays reproducible from CI to prod.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Reminder:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">System.out.println(\"jlink Image Checklist\");</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding jlink image checklist is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying jlink image checklist, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply jlink image checklist will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with jlink image checklist, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "OOP",
        "Databases"
      ]
    },
    {
      "id": 307,
      "title": "307. ArrayDeque descendingIterator",
      "language": "java",
      "description": "Use ArrayDeque.descendingIterator() to report steps from newest to oldest.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Deque<String> steps = new ArrayDeque<>();\n        steps.addLast(\"init\");\n        steps.addLast(\"seed\");\n        steps.addLast(\"deploy\");\n\n        // TODO: walk steps in reverse order using descendingIterator and print \"deploy,seed,init\"\n    }\n}\n",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Deque<String> steps = new ArrayDeque<>();\n        steps.addLast(\"init\");\n        steps.addLast(\"seed\");\n        steps.addLast(\"deploy\");\n\n        Iterator<String> descending = steps.descendingIterator();\n        List<String> order = new ArrayList<>();\n        while (descending.hasNext()) {\n            order.add(descending.next());\n        }\n        System.out.println(String.join(\",\", order));\n    }\n}\n",
      "expectedOutput": "deploy,seed,init",
      "tutorial": "<p class=\"mb-4 text-gray-300\">ArrayDeque keeps insertion order and exposes <code>descendingIterator()</code> so you can walk the tail-first view without copying.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Iterator<String> it = deque.descendingIterator();</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding arraydeque descendingiterator is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying arraydeque descendingiterator, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply arraydeque descendingiterator will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with arraydeque descendingiterator, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Strings",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 308,
      "title": "308. RandomGeneratorFactory Seeded Rollup",
      "language": "java",
      "description": "Create a deterministic L64X128MixRandom sequence and print the sum of three draws.",
      "initialCode": "import java.util.random.RandomGenerator;\nimport java.util.random.RandomGeneratorFactory;\n\npublic class Main {\n    public static void main(String[] args) {\n        // TODO: create an L64X128MixRandom with seed 42, draw three ints in [0,10), sum them, and print the total\n    }\n}\n",
      "fullSolution": "import java.util.random.RandomGenerator;\nimport java.util.random.RandomGeneratorFactory;\n\npublic class Main {\n    public static void main(String[] args) {\n        RandomGeneratorFactory<? extends RandomGenerator> factory = RandomGeneratorFactory.of(\"L64X128MixRandom\");\n        RandomGenerator rng = factory.create(42L);\n        int total = rng.nextInt(10) + rng.nextInt(10) + rng.nextInt(10);\n        System.out.println(total);\n    }\n}\n",
      "expectedOutput": "9",
      "tutorial": "<p class=\"mb-4 text-gray-300\">RandomGeneratorFactory lets you pick modern algorithms with explicit seeding for reproducible tests.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">var rng = RandomGeneratorFactory.of(\"L64X128MixRandom\").create(123);</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding randomgeneratorfactory seeded rollup is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying randomgeneratorfactory seeded rollup, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply randomgeneratorfactory seeded rollup will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with randomgeneratorfactory seeded rollup, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "OOP",
        "Algorithms",
        "Generators"
      ]
    },
    {
      "id": 309,
      "title": "309. CompletableFuture.delayedExecutor",
      "language": "java",
      "description": "Complete a CompletableFuture via delayedExecutor and print the result.",
      "initialCode": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        CompletableFuture<String> status = new CompletableFuture<>();\n\n        // TODO: complete status using a delayed executor (25 milliseconds) with the value \"ready\"\n        // then print status.join()\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        CompletableFuture<String> status = new CompletableFuture<>();\n        Executor executor = CompletableFuture.delayedExecutor(25, TimeUnit.MILLISECONDS);\n        executor.execute(() -> status.complete(\"ready\"));\n        System.out.println(status.join());\n    }\n}\n",
      "expectedOutput": "ready",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use delayedExecutor to inject latency without managing your own scheduler; it runs on ForkJoinPool.commonPool() by default.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">CompletableFuture.delayedExecutor(50, TimeUnit.MILLISECONDS)</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding completablefuture.delayedexecutor is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying completablefuture.delayedexecutor, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply completablefuture.delayedexecutor will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with completablefuture.delayedexecutor, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Strings",
        "OOP",
        "Concurrency",
        "Async"
      ]
    },
    {
      "id": 310,
      "title": "310. ServerSocket echo",
      "language": "java",
      "description": "Start a local ServerSocket, uppercase the incoming message, and print the response from a client connection.",
      "initialCode": "import java.io.*;\nimport java.net.*;\nimport java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        try (ServerSocket server = new ServerSocket(0)) {\n            int port = server.getLocalPort();\n            ExecutorService pool = Executors.newSingleThreadExecutor();\n            pool.submit(() -> {\n                try (Socket socket = server.accept();\n                     BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                     BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()))) {\n                    String line = reader.readLine();\n                    // TODO: write the uppercase response, flush, and close the socket\n                } catch (IOException ex) {\n                    throw new UncheckedIOException(ex);\n                }\n            });\n\n            try (Socket client = new Socket(\"127.0.0.1\", port);\n                 BufferedWriter out = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));\n                 BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()))) {\n                out.write(\"devboot\");\n                out.newLine();\n                out.flush();\n                System.out.println(in.readLine());\n            }\n            pool.shutdownNow();\n        }\n    }\n}\n",
      "fullSolution": "import java.io.*;\nimport java.net.*;\nimport java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        try (ServerSocket server = new ServerSocket(0)) {\n            int port = server.getLocalPort();\n            ExecutorService pool = Executors.newSingleThreadExecutor();\n            pool.submit(() -> {\n                try (Socket socket = server.accept();\n                     BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                     BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()))) {\n                    String line = reader.readLine();\n                    writer.write(line.toUpperCase());\n                    writer.newLine();\n                    writer.flush();\n                } catch (IOException ex) {\n                    throw new UncheckedIOException(ex);\n                }\n            });\n\n            try (Socket client = new Socket(\"127.0.0.1\", port);\n                 BufferedWriter out = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));\n                 BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()))) {\n                out.write(\"devboot\");\n                out.newLine();\n                out.flush();\n                System.out.println(in.readLine());\n            }\n            pool.shutdownNow();\n        }\n    }\n}\n",
      "expectedOutput": "DEVBOOT",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Pair <code>ServerSocket</code> with a background task so you can exercise request/response logic entirely in-process.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">try (ServerSocket server = new ServerSocket(0)) {\n    int port = server.getLocalPort();\n    Executors.newSingleThreadExecutor().submit(server::accept);\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding serversocket echo is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying serversocket echo, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply serversocket echo will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with serversocket echo, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Strings",
        "OOP",
        "I/O",
        "Networking"
      ]
    },
    {
      "id": 311,
      "title": "311. Properties load config",
      "language": "java",
      "description": "Load a configuration string with Properties and echo two keys.",
      "initialCode": "import java.io.StringReader;\nimport java.util.Properties;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        String text = \"service.debug=false\\nservice.workers=3\\n\";\n\n        // TODO: load the properties and print workers:<value> then debug:<value>\n    }\n}\n",
      "fullSolution": "import java.io.StringReader;\nimport java.util.Properties;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        String text = \"service.debug=false\\nservice.workers=3\\n\";\n\n        Properties props = new Properties();\n        props.load(new StringReader(text));\n        System.out.println(\"workers:\" + props.getProperty(\"service.workers\"));\n        System.out.println(\"debug:\" + props.getProperty(\"service.debug\"));\n    }\n}\n",
      "expectedOutput": "workers:3\ndebug:false",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>Properties</code> can parse configuration text straight from a string or Reader, making it easy to test configuration defaults.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Properties props = new Properties();\nprops.load(new StringReader(keyValues));</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding properties load config is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying properties load config, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply properties load config will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with properties load config, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "OOP",
        "I/O",
        "Debugging",
        "Parsing"
      ]
    },
    {
      "id": 312,
      "title": "312. ZipOutputStream in-memory",
      "language": "java",
      "description": "Create a zip archive in memory, reopen it, and list the entries.",
      "initialCode": "import java.io.*;\nimport java.util.*;\nimport java.util.zip.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        try (ZipOutputStream zip = new ZipOutputStream(buffer)) {\n            for (String name : List.of(\"a.txt\", \"b.txt\")) {\n                byte[] data = name.substring(0, 1).getBytes();\n                ZipEntry entry = new ZipEntry(name);\n                // TODO: put the entry into the archive and write the bytes\n            }\n        }\n\n        byte[] payload = buffer.toByteArray();\n        // TODO: reopen the zip, collect the entry names, and print them joined by commas\n    }\n}\n",
      "fullSolution": "import java.io.*;\nimport java.util.*;\nimport java.util.zip.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        try (ZipOutputStream zip = new ZipOutputStream(buffer)) {\n            for (String name : List.of(\"a.txt\", \"b.txt\")) {\n                byte[] data = name.substring(0, 1).getBytes();\n                ZipEntry entry = new ZipEntry(name);\n                zip.putNextEntry(entry);\n                zip.write(data);\n                zip.closeEntry();\n            }\n        }\n\n        byte[] payload = buffer.toByteArray();\n        List<String> names = new ArrayList<>();\n        try (ZipInputStream zin = new ZipInputStream(new ByteArrayInputStream(payload))) {\n            ZipEntry entry;\n            while ((entry = zin.getNextEntry()) != null) {\n                names.add(entry.getName());\n            }\n        }\n        Collections.sort(names);\n        System.out.println(String.join(\",\", names));\n    }\n}\n",
      "expectedOutput": "a.txt,b.txt",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Wrap a <code>ZipOutputStream</code> around a <code>ByteArrayOutputStream</code> when you need to stage release artifacts without touching disk. Reopen the bytes with <code>ZipInputStream</code> to inspect the contents.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Snippet:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">try (ZipOutputStream zip = new ZipOutputStream(buffer)) {\n    zip.putNextEntry(new ZipEntry(name));\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding zipoutputstream in-memory is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying zipoutputstream in-memory, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply zipoutputstream in-memory will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with zipoutputstream in-memory, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Strings",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 313,
      "title": "313. ObjectOutputStream round-trip",
      "language": "java",
      "description": "Serialize and deserialize a record to verify nested data survives the round-trip.",
      "initialCode": "import java.io.*;\nimport java.util.List;\n\npublic class Main {\n    record Profile(String name, List<String> skills) implements Serializable {}\n\n    public static void main(String[] args) throws Exception {\n        Profile profile = new Profile(\"Ada\", List.of(\"logic\", \"math\"));\n\n        // TODO: serialize profile to a byte array, deserialize it, then print the second skill\n    }\n}\n",
      "fullSolution": "import java.io.*;\nimport java.util.List;\n\npublic class Main {\n    record Profile(String name, List<String> skills) implements Serializable {}\n\n    public static void main(String[] args) throws Exception {\n        Profile profile = new Profile(\"Ada\", List.of(\"logic\", \"math\"));\n\n        byte[] payload;\n        try (ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n             ObjectOutputStream out = new ObjectOutputStream(buffer)) {\n            out.writeObject(profile);\n            payload = buffer.toByteArray();\n        }\n\n        try (ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(payload))) {\n            Profile restored = (Profile) in.readObject();\n            System.out.println(restored.skills().get(1));\n        }\n    }\n}\n",
      "expectedOutput": "math",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Java serialization is handy for quick state snapshots. Use <code>ByteArrayOutputStream</code> to keep tests self-contained, then deserialize with <code>ObjectInputStream</code>.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">out.writeObject(profile);\nProfile restored = (Profile) in.readObject();</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding objectoutputstream round-trip is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying objectoutputstream round-trip, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply objectoutputstream round-trip will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with objectoutputstream round-trip, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Math and Stats"
      ]
    },
    {
      "id": 314,
      "title": "314. ClassLoader resource read",
      "language": "java",
      "description": "Create a classpath resource on the fly, load it with a URLClassLoader, and print its contents.",
      "initialCode": "import java.io.*;\nimport java.net.*;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Path root = Files.createTempDirectory(\"assets\");\n        Path pkg = root.resolve(\"assets\");\n        Files.createDirectories(pkg);\n        Files.writeString(pkg.resolve(\"banner.txt\"), \"Launch Ready\\n\", StandardCharsets.UTF_8);\n\n        // TODO: load banner.txt via a URLClassLoader and print the stripped text\n    }\n}\n",
      "fullSolution": "import java.io.*;\nimport java.net.*;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Path root = Files.createTempDirectory(\"assets\");\n        Path pkg = root.resolve(\"assets\");\n        Files.createDirectories(pkg);\n        Files.writeString(pkg.resolve(\"banner.txt\"), \"Launch Ready\\n\", StandardCharsets.UTF_8);\n\n        try (URLClassLoader loader = new URLClassLoader(new URL[] { root.toUri().toURL() })) {\n            try (InputStream in = loader.getResourceAsStream(\"assets/banner.txt\")) {\n                if (in == null) {\n                    throw new IllegalStateException(\"Resource missing\");\n                }\n                String text = new String(in.readAllBytes(), StandardCharsets.UTF_8).strip();\n                System.out.println(text);\n            }\n        }\n    }\n}\n",
      "expectedOutput": "Launch Ready",
      "tutorial": "<p class=\"mb-4 text-gray-300\">A throwaway <code>URLClassLoader</code> lets you simulate classpath resources in tests. Write the assets to a temp directory, load them, then tear everything down.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">try (URLClassLoader loader = new URLClassLoader(new URL[] { dir.toUri().toURL() })) {\n    loader.getResourceAsStream(\"assets/banner.txt\");\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding classloader resource read is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying classloader resource read, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply classloader resource read will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with classloader resource read, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Strings",
        "OOP",
        "I/O"
      ]
    },
    {
      "id": 315,
      "title": "315. Map overrides merge",
      "language": "java",
      "description": "Merge overrides into defaults and print the resulting configuration values.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, String> defaults = new LinkedHashMap<>();\n        defaults.put(\"timeout\", \"30\");\n        defaults.put(\"region\", \"us-east-1\");\n\n        Map<String, String> overrides = Map.of(\"timeout\", \"10\");\n\n        // TODO: merge overrides on top of defaults, then print timeout and region on separate lines\n    }\n}\n",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, String> defaults = new LinkedHashMap<>();\n        defaults.put(\"timeout\", \"30\");\n        defaults.put(\"region\", \"us-east-1\");\n\n        Map<String, String> overrides = Map.of(\"timeout\", \"10\");\n\n        Map<String, String> merged = new LinkedHashMap<>(defaults);\n        merged.putAll(overrides);\n        System.out.println(merged.get(\"timeout\"));\n        System.out.println(merged.get(\"region\"));\n    }\n}\n",
      "expectedOutput": "10\nus-east-1",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Combine defaults with environment-specific overrides by copying the base map and applying changes. The final map preserves insertion order for predictable diagnostics.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Map<String, String> merged = new LinkedHashMap<>(defaults);\nmerged.putAll(overrides);</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding map overrides merge is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying map overrides merge, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply map overrides merge will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with map overrides merge, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Collections",
        "OOP",
        "Security"
      ]
    },
    {
      "id": 316,
      "title": "316. Percentile (inclusive quartiles)",
      "language": "java",
      "description": "Compute the first and third quartiles using the inclusive method and print them.",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        double[] data = {5, 2, 8, 4, 9, 1};\n        Arrays.sort(data);\n\n        // TODO: compute inclusive quartiles (Q1 and Q3) and print them as \"2.5,7.25\"\n    }\n}\n",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        double[] data = {5, 2, 8, 4, 9, 1};\n        Arrays.sort(data);\n\n        double q1 = inclusiveQuantile(data, 0.25);\n        double q3 = inclusiveQuantile(data, 0.75);\n        System.out.println(q1 + \",\" + q3);\n    }\n\n    private static double inclusiveQuantile(double[] data, double p) {\n        int n = data.length;\n        double h = (n - 1) * p + 1;\n        int lowerIndex = (int) Math.floor(h) - 1;\n        double fraction = h - Math.floor(h);\n        if (lowerIndex < 0) {\n            return data[0];\n        }\n        if (lowerIndex >= n - 1) {\n            return data[n - 1];\n        }\n        double lower = data[lowerIndex];\n        double upper = data[lowerIndex + 1];\n        return lower + fraction * (upper - lower);\n    }\n}\n",
      "expectedOutput": "2.5,7.25",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Inclusive quartiles match the behavior of spreadsheets and Python's statistics module: interpolate between neighbors with <code>h = (n - 1) * p + 1</code>.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Snippet:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">double h = (n - 1) * p + 1;\nint lower = (int) Math.floor(h) - 1;</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding percentile (inclusive quartiles) is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying percentile (inclusive quartiles), you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply percentile (inclusive quartiles) will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with percentile (inclusive quartiles), explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "Functions",
        "OOP",
        "Math and Stats"
      ]
    },
    {
      "id": 317,
      "title": "317. HttpClient JSON Request",
      "language": "java",
      "description": "Build a Java 11+ HttpClient request with query parameters and JSON headers.",
      "initialCode": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.time.Duration;\n\npublic class Main {\n    public static void main(String[] args) {\n        HttpClient client = HttpClient.newBuilder()\n                .connectTimeout(Duration.ofSeconds(5))\n                .build();\n\n        // TODO: build a GET request to https://status.example/api/health\n        // Append query parameters region=eu-west and verbose=true\n        // Include header Accept: application/json and a 2 second request timeout\n        // Print the request URI, method, and Accept header value on separate lines\n    }\n}\n",
      "fullSolution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.time.Duration;\n\npublic class Main {\n    public static void main(String[] args) {\n        HttpClient client = HttpClient.newBuilder()\n                .connectTimeout(Duration.ofSeconds(5))\n                .build();\n\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(\"https://status.example/api/health?region=eu-west&verbose=true\"))\n                .timeout(Duration.ofSeconds(2))\n                .header(\"Accept\", \"application/json\")\n                .GET()\n                .build();\n\n        System.out.println(request.uri());\n        System.out.println(request.method());\n        System.out.println(request.headers().firstValue(\"Accept\").orElse(\"missing\"));\n    }\n}\n",
      "expectedOutput": "https://status.example/api/health?region=eu-west&verbose=true\nGET\napplication/json",
      "tutorial": "<p class=\"mb-4 text-gray-300\">HttpRequest.newBuilder lets you compose the URI, timeout, and headers fluently before calling build(). The client can reuse the request instance.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">HttpRequest.newBuilder()\n    .uri(URI.create(url))\n    .header(\"Accept\", \"application/json\")\n    .timeout(Duration.ofSeconds(2))\n    .GET()\n    .build();</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding httpclient json request is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying httpclient json request, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply httpclient json request will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with httpclient json request, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Functions",
        "OOP",
        "Serialization",
        "Networking"
      ]
    },
    {
      "id": 318,
      "title": "318. Pattern Matching Auth Records",
      "language": "java",
      "description": "Use instanceof pattern variables with a sealed hierarchy to classify authentication events.",
      "initialCode": "sealed interface AuthEvent permits Success, Failure, Retry {}\nrecord Success(String user) implements AuthEvent {}\nrecord Failure(int code) implements AuthEvent {}\nrecord Retry(int attempt, Throwable lastError) implements AuthEvent {}\n\npublic class Main {\n    public static void main(String[] args) {\n        AuthEvent event = new Retry(3, new IllegalStateException(\"timeout\"));\n        // TODO: use instanceof pattern matching to determine the message:\n        // Success -> \"Authenticated <user>\"\n        // Failure with code >= 500 -> \"Permanent failure (<code>)\"\n        // Failure otherwise -> \"Temporary failure (<code>)\"\n        // Retry -> \"Retry attempt <attempt>: <message>\"\n        // Print the computed message.\n    }\n}\n",
      "fullSolution": "sealed interface AuthEvent permits Success, Failure, Retry {}\nrecord Success(String user) implements AuthEvent {}\nrecord Failure(int code) implements AuthEvent {}\nrecord Retry(int attempt, Throwable lastError) implements AuthEvent {}\n\npublic class Main {\n    public static void main(String[] args) {\n        AuthEvent event = new Retry(3, new IllegalStateException(\"timeout\"));\n\n        String message;\n        if (event instanceof Success success) {\n            message = \"Authenticated \" + success.user();\n        } else if (event instanceof Failure failure) {\n            if (failure.code() >= 500) {\n                message = \"Permanent failure (\" + failure.code() + \")\";\n            } else {\n                message = \"Temporary failure (\" + failure.code() + \")\";\n            }\n        } else if (event instanceof Retry retry) {\n            message = \"Retry attempt \" + retry.attempt() + \": \" + retry.lastError().getMessage();\n        } else {\n            throw new IllegalStateException(\"Unknown event: \" + event);\n        }\n\n        System.out.println(message);\n    }\n}\n",
      "expectedOutput": "Retry attempt 3: timeout",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Pattern matching for instanceof lets you bind the record components directly after the check, avoiding explicit casts.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Example:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">if (event instanceof Failure failure) {\n    if (failure.code() >= 500) {\n        return \"Permanent failure\";\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding pattern matching auth records is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying pattern matching auth records, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply pattern matching auth records will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with pattern matching auth records, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Control Flow",
        "OOP",
        "Type System"
      ]
    },
    {
      "id": 319,
      "title": "319. MessageDigest SHA-256 Fingerprint",
      "language": "java",
      "description": "Compute a SHA-256 digest and emit both the full hash and a short fingerprint.",
      "initialCode": "import java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.HexFormat;\n\npublic class Main {\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        String payload = \"artifact:v2:2025-09-17\";\n\n        // TODO: compute the SHA-256 digest, print the lowercase hex string,\n        // then print the first 8 characters as a short fingerprint.\n    }\n}\n",
      "fullSolution": "import java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.HexFormat;\n\npublic class Main {\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        String payload = \"artifact:v2:2025-09-17\";\n        MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n        byte[] hash = digest.digest(payload.getBytes(StandardCharsets.UTF_8));\n        String hex = HexFormat.of().formatHex(hash);\n        System.out.println(hex);\n        System.out.println(hex.substring(0, 8));\n    }\n}\n",
      "expectedOutput": "70c4fb708a68e1c337a1a05a8e4bb2b9b298d3c4289490303a9f29172f2a988f\n70c4fb70",
      "tutorial": "<p class=\"mb-4 text-gray-300\">MessageDigest provides streaming hashes. Use HexFormat.of().formatHex to avoid manual byte-to-hex loops.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\nString hex = HexFormat.of().formatHex(md.digest(bytes));</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding messagedigest sha-256 fingerprint is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying messagedigest sha-256 fingerprint, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply messagedigest sha-256 fingerprint will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with messagedigest sha-256 fingerprint, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Strings",
        "OOP",
        "Algorithms",
        "I/O"
      ]
    },
    {
      "id": 320,
      "title": "320. invokeAny first success",
      "language": "java",
      "description": "Use ExecutorService.invokeAny to race primary and replica probes, printing whichever responds first.",
      "initialCode": "import java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class Main {\n    public static void main(String[] args) throws InterruptedException, ExecutionException {\n        // TODO: race primary vs replica with invokeAny and print the winning response\n    }\n\n    static String probe(String name, long delayMillis) throws InterruptedException {\n        Thread.sleep(delayMillis);\n        return name + \" ready\";\n    }\n}\n",
      "fullSolution": "import java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class Main {\n    public static void main(String[] args) throws InterruptedException, ExecutionException {\n        Callable<String> primary = () -> probe(\"primary\", 50);\n        Callable<String> replica = () -> probe(\"replica\", 10);\n\n        ExecutorService executor = Executors.newFixedThreadPool(2);\n        try {\n            String winner = executor.invokeAny(List.of(primary, replica));\n            System.out.println(winner);\n        } finally {\n            executor.shutdownNow();\n        }\n    }\n\n    static String probe(String name, long delayMillis) throws InterruptedException {\n        Thread.sleep(delayMillis);\n        return name + \" ready\";\n    }\n}\n",
      "expectedOutput": "replica ready",
      "tutorial": "<p class=\"mb-4 text-gray-300\">invokeAny submits a batch of tasks and returns as soon as one completes successfully, cancelling the rest. It is a handy way to race redundant backends.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">ExecutorService exec = Executors.newFixedThreadPool(n);\ntry {\n    return exec.invokeAny(tasks);\n} finally {\n    exec.shutdownNow();\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding invokeany first success is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying invokeany first success, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply invokeany first success will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with invokeany first success, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrency",
        "Control Flow",
        "OOP"
      ]
    },
    {
      "id": 321,
      "title": "321. ThreadLocal request context",
      "language": "java",
      "description": "Propagate a request id into tasks by setting and clearing a ThreadLocal inside each Callable.",
      "initialCode": "import java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\n\npublic class Main {\n    static final ThreadLocal<String> REQUEST_ID = new ThreadLocal<>();\n\n    public static void main(String[] args) throws InterruptedException, ExecutionException {\n        // TODO: submit inventory and pricing tasks that bind REQUEST_ID to \"req-007\" and print their outputs\n    }\n\n    static String serviceLine(String service) {\n        return service + \" -> \" + REQUEST_ID.get();\n    }\n}\n",
      "fullSolution": "import java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\n\npublic class Main {\n    static final ThreadLocal<String> REQUEST_ID = new ThreadLocal<>();\n\n    public static void main(String[] args) throws InterruptedException, ExecutionException {\n        Callable<String> inventory = wrapWithRequest(\"req-007\", () -> serviceLine(\"inventory\"));\n        Callable<String> pricing = wrapWithRequest(\"req-007\", () -> serviceLine(\"pricing\"));\n\n        ExecutorService executor = Executors.newFixedThreadPool(2);\n        try {\n            List<Future<String>> futures = executor.invokeAll(List.of(inventory, pricing));\n            for (Future<String> future : futures) {\n                System.out.println(future.get());\n            }\n        } finally {\n            executor.shutdown();\n        }\n    }\n\n    static Callable<String> wrapWithRequest(String requestId, Callable<String> task) {\n        return () -> {\n            REQUEST_ID.set(requestId);\n            try {\n                return task.call();\n            } finally {\n                REQUEST_ID.remove();\n            }\n        };\n    }\n\n    static String serviceLine(String service) {\n        return service + \" -> \" + REQUEST_ID.get();\n    }\n}\n",
      "expectedOutput": "inventory -> req-007\npricing -> req-007",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Without ScopedValue or structured concurrency, you can still pass context by wrapping tasks that set a ThreadLocal before running and clear it afterward. This pattern keeps worker threads from leaking stale request data.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Callable<String> wrapped = () -> {\n    context.set(id);\n    try {\n        return task.call();\n    } finally {\n        context.remove();\n    }\n};</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding threadlocal request context is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying threadlocal request context, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply threadlocal request context will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with threadlocal request context, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrency",
        "Control Flow",
        "OOP"
      ]
    },
    {
      "id": 322,
      "title": "322. ExecutorCompletionService first success",
      "language": "java",
      "description": "Race primary and replica callables using ExecutorCompletionService and print the first response.",
      "initialCode": "import java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorCompletionService;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class Main {\n    static String probe(String name, long delayMillis) throws InterruptedException {\n        Thread.sleep(delayMillis);\n        return name + \" ready\";\n    }\n\n    public static void main(String[] args) throws InterruptedException, ExecutionException {\n        List<Callable<String>> tasks = List.of(\n                () -> probe(\"primary\", 50),\n                () -> probe(\"replica\", 10)\n        );\n\n        // TODO: create an ExecutorCompletionService backed by a fixed thread pool\n        // submit both tasks, take the first completed future, print its result,\n        // then shut down the executor.\n    }\n}\n",
      "fullSolution": "import java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorCompletionService;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\n\npublic class Main {\n    static String probe(String name, long delayMillis) throws InterruptedException {\n        Thread.sleep(delayMillis);\n        return name + \" ready\";\n    }\n\n    public static void main(String[] args) throws InterruptedException, ExecutionException {\n        List<Callable<String>> tasks = List.of(\n                () -> probe(\"primary\", 50),\n                () -> probe(\"replica\", 10)\n        );\n\n        ExecutorService executor = Executors.newFixedThreadPool(tasks.size());\n        ExecutorCompletionService<String> completion = new ExecutorCompletionService<>(executor);\n        try {\n            for (Callable<String> task : tasks) {\n                completion.submit(task);\n            }\n            Future<String> winner = completion.take();\n            System.out.println(winner.get());\n        } finally {\n            executor.shutdownNow();\n        }\n    }\n}\n",
      "expectedOutput": "replica ready",
      "tutorial": "<p class=\"mb-4 text-gray-300\">ExecutorCompletionService wraps an ExecutorService and hands you completed futures\n in finishing order. Submit work with submit() and pull the earliest outcome with take().</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">ExecutorCompletionService<T> ecs = new ExecutorCompletionService<>(executor);\necs.submit(task);\nFuture<T> winner = ecs.take();</pre></div><p class=\"mt-4 text-gray-300\">Use this when you need first-completer semantics but also want direct access to the returned Future.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding executorcompletionservice first success is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying executorcompletionservice first success, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply executorcompletionservice first success will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with executorcompletionservice first success, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrency",
        "Control Flow",
        "OOP"
      ]
    },
    {
      "id": 323,
      "title": "323. CompletableFuture failure guard",
      "language": "java",
      "description": "Run inventory and analytics via CompletableFuture.allOf, printing a failure message when any task errors.",
      "initialCode": "import java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionException;\n\npublic class Main {\n    static String fetch(String name, long delayMillis) {\n        try {\n            Thread.sleep(delayMillis);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(e);\n        }\n        if (\"analytics\".equals(name)) {\n            throw new IllegalStateException(\"analytics offline\");\n        }\n        return name + \" ready\";\n    }\n\n    public static void main(String[] args) {\n        CompletableFuture<String> inventory = CompletableFuture.supplyAsync(() -> fetch(\"inventory\", 40));\n        CompletableFuture<String> analytics = CompletableFuture.supplyAsync(() -> fetch(\"analytics\", 20));\n        // TODO: wait for both futures.\n        // If either fails, catch the CompletionException and print \"FAIL: <message>\".\n        // Otherwise print the inventory result, then the analytics result.\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionException;\n\npublic class Main {\n    static String fetch(String name, long delayMillis) {\n        try {\n            Thread.sleep(delayMillis);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(e);\n        }\n        if (\"analytics\".equals(name)) {\n            throw new IllegalStateException(\"analytics offline\");\n        }\n        return name + \" ready\";\n    }\n\n    public static void main(String[] args) {\n        CompletableFuture<String> inventory = CompletableFuture.supplyAsync(() -> fetch(\"inventory\", 40));\n        CompletableFuture<String> analytics = CompletableFuture.supplyAsync(() -> fetch(\"analytics\", 20));\n\n        try {\n            CompletableFuture.allOf(inventory, analytics).join();\n            System.out.println(inventory.join());\n            System.out.println(analytics.join());\n        } catch (CompletionException ex) {\n            Throwable cause = ex.getCause();\n            String message = cause != null ? cause.getMessage() : ex.getMessage();\n            System.out.println(\"FAIL: \" + message);\n        }\n    }\n}\n",
      "expectedOutput": "FAIL: analytics offline",
      "tutorial": "<p class=\"mb-4 text-gray-300\">CompletableFuture.allOf propagates the first failure by wrapping it in a CompletionException. Surround the join with a try/catch to surface the underlying cause.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">try {\n    CompletableFuture.allOf(futures...).join();\n} catch (CompletionException ex) {\n    handle(ex.getCause());\n}</pre></div><p class=\"mt-4 text-gray-300\">After the join succeeds you can safely call join() on each individual future without re-checking for errors.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding completablefuture failure guard is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying completablefuture failure guard, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply completablefuture failure guard will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with completablefuture failure guard, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrency",
        "Async",
        "Control Flow"
      ]
    },
    {
      "id": 324,
      "title": "324. CompletableFuture winner",
      "language": "java",
      "description": "Race two CompletableFutures and cancel the loser after retrieving the first result.",
      "initialCode": "import java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\n\npublic class Main {\n    static String slow(String name, long delayMillis) {\n        try {\n            Thread.sleep(delayMillis);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(e);\n        }\n        return name + \" ready\";\n    }\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        CompletableFuture<String> primary = CompletableFuture.supplyAsync(() -> slow(\"primary\", 80));\n        CompletableFuture<String> backup = CompletableFuture.supplyAsync(() -> slow(\"backup\", 20));\n        // TODO: wait for whichever future completes first and print the result\n        // Then cancel the other future to free resources.\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\n\npublic class Main {\n    static String slow(String name, long delayMillis) {\n        try {\n            Thread.sleep(delayMillis);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(e);\n        }\n        return name + \" ready\";\n    }\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        CompletableFuture<String> primary = CompletableFuture.supplyAsync(() -> slow(\"primary\", 80));\n        CompletableFuture<String> backup = CompletableFuture.supplyAsync(() -> slow(\"backup\", 20));\n        CompletableFuture<Object> winner = CompletableFuture.anyOf(primary, backup);\n        String result = (String) winner.get();\n        System.out.println(result);\n        primary.cancel(true);\n        backup.cancel(true);\n    }\n}\n",
      "expectedOutput": "backup ready",
      "tutorial": "<p class=\"mb-4 text-gray-300\">anyOf returns the first completed future without waiting for the rest, making it ideal for fallback strategies. Cast the Object back to the expected type when your futures share the same result type.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">CompletableFuture<Object> winner = CompletableFuture.anyOf(primary, replica);\nT value = (T) winner.get();\nloser.cancel(true);</pre></div><p class=\"mt-4 text-gray-300\">Remember to cancel losers so thread pools or upstream calls can short-circuit.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding completablefuture winner is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying completablefuture winner, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply completablefuture winner will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with completablefuture winner, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrency",
        "Async",
        "Control Flow"
      ]
    },
    {
      "id": 325,
      "title": "325. Work-stealing invokeAll batch",
      "language": "java",
      "description": "Run blocking service calls on a work-stealing pool and print their results in submission order.",
      "initialCode": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\n\npublic class Main {\n    public static void main(String[] args) throws InterruptedException, ExecutionException {\n        List<String> services = List.of(\"inventory\", \"pricing\", \"shipping\");\n        // TODO: build a work-stealing pool, create callables that sleep 20ms and return \"<service> done\",\n        // invokeAll the tasks, print each result in the original order, then shut down the pool.\n    }\n}\n",
      "fullSolution": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\n\npublic class Main {\n    public static void main(String[] args) throws InterruptedException, ExecutionException {\n        List<String> services = List.of(\"inventory\", \"pricing\", \"shipping\");\n        ExecutorService executor = Executors.newWorkStealingPool();\n        try {\n            List<Callable<String>> tasks = new ArrayList<>();\n            for (String service : services) {\n                tasks.add(() -> {\n                    TimeUnit.MILLISECONDS.sleep(20);\n                    return service + \" done\";\n                });\n            }\n            List<Future<String>> futures = executor.invokeAll(tasks);\n            for (Future<String> future : futures) {\n                System.out.println(future.get());\n            }\n        } finally {\n            executor.shutdown();\n        }\n    }\n}\n",
      "expectedOutput": "inventory done\npricing done\nshipping done",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Executors.newWorkStealingPool() creates a ForkJoinPool that dynamically balances blocking tasks across threads. invokeAll retains submission order even though work may hop between workers.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">ExecutorService pool = Executors.newWorkStealingPool();\ntry {\n    List<Future<T>> futures = pool.invokeAll(tasks);\n    for (Future<T> future : futures) {\n        use(future.get());\n    }\n} finally {\n    pool.shutdown();\n}</pre></div><p class=\"mt-4 text-gray-300\">Work-stealing keeps CPUs busy without manually sizing thread pools for mixed workloads.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding work-stealing invokeall batch is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying work-stealing invokeall batch, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply work-stealing invokeall batch will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with work-stealing invokeall batch, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrency",
        "Control Flow",
        "OOP"
      ]
    },
    {
      "id": 326,
      "title": "326. CompletableFuture timeout fallback",
      "language": "java",
      "description": "Apply orTimeout to a supplyAsync task and provide a fallback when the operation takes too long.",
      "initialCode": "import java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\n\npublic class Main {\n    static String fetch(String name, long delayMillis) {\n        try {\n            Thread.sleep(delayMillis);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(e);\n        }\n        return name + \" ready\";\n    }\n\n    public static void main(String[] args) {\n        // TODO: run fetch(\"report\", 80) via supplyAsync\n        // Add orTimeout with 40 milliseconds and map timeouts to \"fallback\"\n        // Print the resulting value\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\n\npublic class Main {\n    static String fetch(String name, long delayMillis) {\n        try {\n            Thread.sleep(delayMillis);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(e);\n        }\n        return name + \" ready\";\n    }\n\n    public static void main(String[] args) {\n        CompletableFuture<String> result = CompletableFuture\n                .supplyAsync(() -> fetch(\"report\", 80))\n                .orTimeout(40, TimeUnit.MILLISECONDS)\n                .exceptionally(ex -> \"fallback\");\n\n        System.out.println(result.join());\n    }\n}\n",
      "expectedOutput": "fallback",
      "tutorial": "<p class=\"mb-4 text-gray-300\">orTimeout injects a deadline into a CompletableFuture, completing it exceptionally with TimeoutException if it runs too long. Chain <code>exceptionally</code> to turn that failure into a clean fallback value.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">CompletableFuture<T> guarded = work\n    .orTimeout(limit, unit)\n    .exceptionally(ex -> fallback);</pre></div><p class=\"mt-4 text-gray-300\">Pair this with retry loops or cached responses to keep latency predictable.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding completablefuture timeout fallback is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying completablefuture timeout fallback, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply completablefuture timeout fallback will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with completablefuture timeout fallback, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrency",
        "Async",
        "Control Flow"
      ]
    },
    {
      "id": 327,
      "title": "327. CountDownLatch service rendezvous",
      "language": "java",
      "description": "Wait for several services to signal readiness with CountDownLatch before announcing that all are primed.",
      "initialCode": "import java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        List<String> services = List.of(\"inventory\", \"pricing\", \"shipping\");\n        CountDownLatch latch = new CountDownLatch(services.size());\n        Map<String, String> ready = new ConcurrentHashMap<>();\n        ExecutorService executor = Executors.newFixedThreadPool(services.size());\n\n        // TODO: submit a worker per service that sleeps service.length()*10 ms,\n        // stores \"<service> primed\" in the map, and counts down the latch\n        // Wait on the latch, print the messages in list order, then print \"all services go\"\n        // Finally, shut down the executor\n    }\n}\n",
      "fullSolution": "import java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        List<String> services = List.of(\"inventory\", \"pricing\", \"shipping\");\n        CountDownLatch latch = new CountDownLatch(services.size());\n        Map<String, String> ready = new ConcurrentHashMap<>();\n        ExecutorService executor = Executors.newFixedThreadPool(services.size());\n\n        try {\n            for (String service : services) {\n                executor.submit(() -> {\n                    try {\n                        TimeUnit.MILLISECONDS.sleep(service.length() * 10L);\n                        ready.put(service, service + \" primed\");\n                    } catch (InterruptedException e) {\n                        Thread.currentThread().interrupt();\n                    } finally {\n                        latch.countDown();\n                    }\n                });\n            }\n\n            latch.await();\n            for (String service : services) {\n                System.out.println(ready.get(service));\n            }\n            System.out.println(\"all services go\");\n        } finally {\n            executor.shutdownNow();\n        }\n    }\n}\n",
      "expectedOutput": "inventory primed\npricing primed\nshipping primed\nall services go",
      "tutorial": "<p class=\"mb-4 text-gray-300\">CountDownLatch lets you wait until a fixed number of signals arrive. Each worker decrements the latch, and the main thread blocks in <code>await()</code> until everyone checks in.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">CountDownLatch latch = new CountDownLatch(n);\nexecutor.submit(() -> {\n    work();\n    latch.countDown();\n});\nlatch.await();</pre></div><p class=\"mt-4 text-gray-300\">Use this for startup barriers or coordinated shutdown sequences.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding countdownlatch service rendezvous is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying countdownlatch service rendezvous, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply countdownlatch service rendezvous will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with countdownlatch service rendezvous, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrency",
        "Control Flow",
        "OOP"
      ]
    },
    {
      "id": 328,
      "title": "328. Semaphore concurrency gate",
      "language": "java",
      "description": "Cap parallel tasks with a Semaphore while gathering results in submission order.",
      "initialCode": "import java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\n\npublic class Main {\n    public static void main(String[] args) throws InterruptedException, ExecutionException {\n        List<String> jobs = List.of(\"alpha\", \"beta\", \"gamma\");\n        Semaphore limiter = new Semaphore(2);\n        ExecutorService executor = Executors.newFixedThreadPool(jobs.size());\n\n        // TODO: create a Callable per job that acquires the semaphore, sleeps based on the job name,\n        // returns \"<job> done\", and releases the permit in a finally block\n        // invokeAll the callables and print each result in submission order\n        // shut down the executor afterward\n    }\n}\n",
      "fullSolution": "import java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\n\npublic class Main {\n    public static void main(String[] args) throws InterruptedException, ExecutionException {\n        List<String> jobs = List.of(\"alpha\", \"beta\", \"gamma\");\n        Semaphore limiter = new Semaphore(2);\n        ExecutorService executor = Executors.newFixedThreadPool(jobs.size());\n\n        try {\n            List<Callable<String>> tasks = jobs.stream()\n                    .<Callable<String>>map(job -> () -> {\n                        limiter.acquire();\n                        try {\n                            long delay = switch (job) {\n                                case \"alpha\" -> 50L;\n                                case \"beta\" -> 80L;\n                                default -> 20L;\n                            };\n                            TimeUnit.MILLISECONDS.sleep(delay);\n                            return job + \" done\";\n                        } finally {\n                            limiter.release();\n                        }\n                    })\n                    .toList();\n\n            List<Future<String>> results = executor.invokeAll(tasks);\n            for (Future<String> future : results) {\n                System.out.println(future.get());\n            }\n        } finally {\n            executor.shutdown();\n        }\n    }\n}\n",
      "expectedOutput": "alpha done\nbeta done\ngamma done",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Semaphores bound the number of concurrent entrants to a critical section. Acquire before starting work, release in a finally block, and everyone else waits their turn.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">limiter.acquire();\ntry {\n    doWork();\n} finally {\n    limiter.release();\n}</pre></div><p class=\"mt-4 text-gray-300\">Combine with invokeAll to preserve submission order while still limiting resource pressure.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding semaphore concurrency gate is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying semaphore concurrency gate, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply semaphore concurrency gate will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with semaphore concurrency gate, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrency",
        "Control Flow",
        "OOP"
      ]
    },
    {
      "id": 329,
      "title": "329. CompletableFuture handle outcome",
      "language": "java",
      "description": "Use CompletableFuture.handle to turn either a successful value or an exception into a status string.",
      "initialCode": "import java.util.concurrent.CompletableFuture;\n\npublic class Main {\n    static String fetch(boolean fail) {\n        if (fail) {\n            throw new IllegalStateException(\"analytics offline\");\n        }\n        return \"analytics ok\";\n    }\n\n    public static void main(String[] args) {\n        // TODO: run fetch(true) asynchronously and use handle to map:\n        // success -> \"OK: <value>\"\n        // failure -> \"FAIL: <message>\"\n        // Print the mapped result.\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.CompletableFuture;\n\npublic class Main {\n    static String fetch(boolean fail) {\n        if (fail) {\n            throw new IllegalStateException(\"analytics offline\");\n        }\n        return \"analytics ok\";\n    }\n\n    public static void main(String[] args) {\n        String status = CompletableFuture\n                .supplyAsync(() -> fetch(true))\n                .handle((value, ex) -> {\n                    if (ex == null) {\n                        return \"OK: \" + value;\n                    }\n                    Throwable cause = ex instanceof java.util.concurrent.CompletionException ce ? ce.getCause() : ex;\n                    return \"FAIL: \" + cause.getMessage();\n                })\n                .join();\n        System.out.println(status);\n    }\n}\n",
      "expectedOutput": "FAIL: analytics offline",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>handle</code> receives both the value and the exception (if any) from the upstream stage, letting you fold everything into a single continuation.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">future.handle((value, ex) -> ex == null ? success(value) : recover(ex))</pre></div><p class=\"mt-4 text-gray-300\">Remember to unwrap <code>CompletionException</code> when mapping failures from asynchronous stages.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding completablefuture handle outcome is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying completablefuture handle outcome, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply completablefuture handle outcome will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with completablefuture handle outcome, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrency",
        "Async",
        "Control Flow"
      ]
    },
    {
      "id": 330,
      "title": "330. Phaser barrier release",
      "language": "java",
      "description": "Coordinate multiple services through Phaser so they all wait for a gate to open before proceeding.",
      "initialCode": "import java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Phaser;\nimport java.util.concurrent.TimeUnit;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        List<String> services = List.of(\"inventory\", \"pricing\", \"shipping\");\n        Phaser phaser = new Phaser(1); // main thread\n        ExecutorService executor = Executors.newFixedThreadPool(services.size());\n\n        // TODO: register each service with the phaser, print \"<service> prepped\" before arriveAndAwaitAdvance,\n        // then after the barrier print \"<service> go\".\n        // Once all workers are registered, arrive and await in main, print \"gate open\", then deregister.\n        // Finally, shut down the executor.\n    }\n}\n",
      "fullSolution": "import java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Phaser;\nimport java.util.concurrent.TimeUnit;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        List<String> services = List.of(\"inventory\", \"pricing\", \"shipping\");\n        Phaser phaser = new Phaser(1); // register main\n        ExecutorService executor = Executors.newFixedThreadPool(services.size());\n\n        try {\n            for (String service : services) {\n                phaser.register();\n                executor.submit(() -> {\n                    try {\n                        TimeUnit.MILLISECONDS.sleep(service.length() * 5L);\n                        System.out.println(service + \" prepped\");\n                        phaser.arriveAndAwaitAdvance();\n                        TimeUnit.MILLISECONDS.sleep(service.length() * 2L);\n                        System.out.println(service + \" go\");\n                    } catch (InterruptedException e) {\n                        Thread.currentThread().interrupt();\n                    } finally {\n                        phaser.arriveAndDeregister();\n                    }\n                });\n            }\n\n            phaser.arriveAndAwaitAdvance();\n            System.out.println(\"gate open\");\n        } finally {\n            phaser.arriveAndDeregister();\n            executor.shutdown();\n        }\n    }\n}\n",
      "expectedOutput": "pricing prepped\nshipping prepped\ninventory prepped\ngate open\npricing go\nshipping go\ninventory go",
      "tutorial": "<p class=\\\"mb-4 text-gray-300\\\">Phaser coordinates batches of parties across phases. Register each participant, let them \"arrive\" when they finish pre-work, and wait for the phase to advance before continuing.</p><h4 class=\\\"font-semibold text-gray-200 mb-2\\\">Pattern:</h4><div class=\\\"code-block-wrapper\\\"><pre class=\\\"tutorial-code-block\\\">phaser.register();\n// prep work\nphaser.arriveAndAwaitAdvance();\n// synchronized release\nphaser.arriveAndDeregister();</pre></div><p class=\\\"mt-4 text-gray-300\\\">Choose delays or additional coordination if you need deterministic post-barrier ordering for demonstrations.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding phaser barrier release is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying phaser barrier release, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply phaser barrier release will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with phaser barrier release, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrency",
        "Control Flow",
        "OOP"
      ]
    },
    {
      "id": 331,
      "title": "331. ReentrantReadWriteLock snapshot",
      "language": "java",
      "description": "Guard configuration updates with a ReentrantReadWriteLock so readers see the latest snapshot once the writer commits.",
      "initialCode": "import java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\npublic class Main {\n    public static void main(String[] args) throws InterruptedException, ExecutionException {\n        Map<String, String> config = new HashMap<>();\n        ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n        CountDownLatch writerHolding = new CountDownLatch(1);\n        ExecutorService executor = Executors.newFixedThreadPool(3);\n\n        // TODO: submit a writer that acquires the write lock, signals writerHolding, sleeps 20 ms, writes feature=enabled, then unlocks.\n        // After waiting for writerHolding, submit two readers that acquire the read lock after small delays and return messages about feature.\n        // Print each reader's message once futures complete, then shut down the executor.\n    }\n}\n",
      "fullSolution": "import java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\npublic class Main {\n    public static void main(String[] args) throws InterruptedException, ExecutionException {\n        Map<String, String> config = new HashMap<>();\n        ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n        CountDownLatch writerHolding = new CountDownLatch(1);\n        ExecutorService executor = Executors.newFixedThreadPool(3);\n\n        try {\n            Future<?> writer = executor.submit(() -> {\n                lock.writeLock().lock();\n                try {\n                    writerHolding.countDown();\n                    TimeUnit.MILLISECONDS.sleep(20);\n                    config.put(\"feature\", \"enabled\");\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                } finally {\n                    lock.writeLock().unlock();\n                }\n            });\n\n            writerHolding.await();\n\n            List<Future<String>> readers = List.of(\n                executor.submit(() -> {\n                    TimeUnit.MILLISECONDS.sleep(5);\n                    lock.readLock().lock();\n                    try {\n                        return \"alpha reads \" + config.getOrDefault(\"feature\", \"missing\");\n                    } finally {\n                        lock.readLock().unlock();\n                    }\n                }),\n                executor.submit(() -> {\n                    TimeUnit.MILLISECONDS.sleep(10);\n                    lock.readLock().lock();\n                    try {\n                        return \"beta reads \" + config.getOrDefault(\"feature\", \"missing\");\n                    } finally {\n                        lock.readLock().unlock();\n                    }\n                })\n            );\n\n            writer.get();\n            for (Future<String> reader : readers) {\n                System.out.println(reader.get());\n            }\n        } finally {\n            executor.shutdown();\n        }\n    }\n}\n",
      "expectedOutput": "alpha reads enabled\nbeta reads enabled",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Writers take the exclusive lock while readers share the read lock. By waiting for the writer to hold the lock before launching readers, you ensure they block until the update is committed and then observe the fresh snapshot.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">lock.writeLock().lock();\ntry {\n    update();\n} finally {\n    lock.writeLock().unlock();\n}\n\nlock.readLock().lock();\ntry {\n    use();\n} finally {\n    lock.readLock().unlock();\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding reentrantreadwritelock snapshot is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying reentrantreadwritelock snapshot, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply reentrantreadwritelock snapshot will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with reentrantreadwritelock snapshot, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrency",
        "Control Flow",
        "OOP"
      ]
    },
    {
      "id": 332,
      "title": "332. CompletableFuture thenCompose chain",
      "language": "java",
      "description": "Compose two asynchronous stages so the second depends on the result of the first.",
      "initialCode": "import java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\n\npublic class Main {\n    static CompletableFuture<String> fetchUser() {\n        return CompletableFuture.supplyAsync(() -> {\n            sleep(20);\n            return \"alice\";\n        });\n    }\n\n    static CompletableFuture<String> loadProfile(String user) {\n        return CompletableFuture.supplyAsync(() -> {\n            sleep(20);\n            return user + \" profile\";\n        });\n    }\n\n    static void sleep(long millis) {\n        try {\n            TimeUnit.MILLISECONDS.sleep(millis);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static void main(String[] args) {\n        // TODO: chain fetchUser() into loadProfile(...) with thenCompose and print the profile string\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\n\npublic class Main {\n    static CompletableFuture<String> fetchUser() {\n        return CompletableFuture.supplyAsync(() -> {\n            sleep(20);\n            return \"alice\";\n        });\n    }\n\n    static CompletableFuture<String> loadProfile(String user) {\n        return CompletableFuture.supplyAsync(() -> {\n            sleep(20);\n            return user + \" profile\";\n        });\n    }\n\n    static void sleep(long millis) {\n        try {\n            TimeUnit.MILLISECONDS.sleep(millis);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static void main(String[] args) {\n        String profile = fetchUser()\n                .thenCompose(Main::loadProfile)\n                .join();\n        System.out.println(profile);\n    }\n}\n",
      "expectedOutput": "alice profile",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use <code>thenCompose</code> when a stage returns another <code>CompletableFuture</code>. It flattens the futures so you can treat the downstream result as a single asynchronous pipeline.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">future.thenCompose(this::nextAsync)</pre></div><p class=\"mt-4 text-gray-300\">Compare with <code>thenApply</code>, which would leave you with a nested completion stage.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding completablefuture thencompose chain is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying completablefuture thencompose chain, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply completablefuture thencompose chain will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with completablefuture thencompose chain, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrency",
        "Async",
        "Control Flow"
      ]
    },
    {
      "id": 333,
      "title": "333. ScheduledExecutor fixed rate",
      "language": "java",
      "description": "Schedule a repeating heartbeat with ScheduledExecutorService.scheduleAtFixedRate and stop after three ticks.",
      "initialCode": "import java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();\n        AtomicInteger count = new AtomicInteger();\n\n        // TODO: schedule a heartbeat that prints \"tick <n>\" every 40 ms\n        // After the third tick, shut down the scheduler\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();\n        AtomicInteger count = new AtomicInteger();\n\n        Runnable task = () -> {\n            int value = count.incrementAndGet();\n            System.out.println(\"tick \" + value);\n            if (value >= 3) {\n                scheduler.shutdown();\n            }\n        };\n\n        scheduler.scheduleAtFixedRate(task, 0, 40, TimeUnit.MILLISECONDS);\n        scheduler.awaitTermination(500, TimeUnit.MILLISECONDS);\n    }\n}\n",
      "expectedOutput": "tick 1\ntick 2\ntick 3",
      "tutorial": "<p class=\"mb-4 text-gray-300\">scheduleAtFixedRate launches tasks with a fixed period between start times. Use an AtomicInteger to count iterations and call <code>shutdown()</code> when done.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">scheduler.scheduleAtFixedRate(task, initialDelay, period, unit);</pre></div><p class=\"mt-4 text-gray-300\">Always shut down the scheduler to release the thread.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding scheduledexecutor fixed rate is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying scheduledexecutor fixed rate, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply scheduledexecutor fixed rate will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with scheduledexecutor fixed rate, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrency",
        "Control Flow",
        "Workflow"
      ]
    },
    {
      "id": 334,
      "title": "334. StampedLock optimistic read",
      "language": "java",
      "description": "Use StampedLock to take an optimistic read snapshot and fall back to the read lock if contention occurs.",
      "initialCode": "import java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.StampedLock;\n\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        StampedLock lock = new StampedLock();\n        int[] counter = {0};\n\n        Thread writer = new Thread(() -> {\n            long stamp = lock.writeLock();\n            try {\n                sleep(30);\n                counter[0] = 42;\n            } finally {\n                lock.unlockWrite(stamp);\n            }\n        });\n\n        writer.start();\n        sleep(5);\n\n        // TODO: read counter[0] using tryOptimisticRead, validating the stamp\n        // If validation fails, acquire a readLock to get a consistent value, then print it\n\n        writer.join();\n    }\n\n    static void sleep(long millis) {\n        try {\n            TimeUnit.MILLISECONDS.sleep(millis);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(e);\n        }\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.StampedLock;\n\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        StampedLock lock = new StampedLock();\n        int[] counter = {0};\n\n        Thread writer = new Thread(() -> {\n            long stamp = lock.writeLock();\n            try {\n                sleep(30);\n                counter[0] = 42;\n            } finally {\n                lock.unlockWrite(stamp);\n            }\n        });\n\n        writer.start();\n        sleep(5);\n\n        long stamp = lock.tryOptimisticRead();\n        int snapshot = counter[0];\n        if (!lock.validate(stamp)) {\n            stamp = lock.readLock();\n            try {\n                snapshot = counter[0];\n            } finally {\n                lock.unlockRead(stamp);\n            }\n        }\n        System.out.println(\"value \" + snapshot);\n\n        writer.join();\n    }\n\n    static void sleep(long millis) {\n        try {\n            TimeUnit.MILLISECONDS.sleep(millis);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(e);\n        }\n    }\n}\n",
      "expectedOutput": "value 42",
      "tutorial": "<p class=\"mb-4 text-gray-300\">StampedLock allows optimistic reads that avoid locking when no writer interferes. Validate the stamp; if it has been invalidated by a write, fall back to a read lock.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">long stamp = lock.tryOptimisticRead();\\nT value = snapshot();\\nif (!lock.validate(stamp)) {\\n    stamp = lock.readLock();\\n    try {\\n        value = snapshot();\\n    } finally {\\n        lock.unlockRead(stamp);\\n    }\\n}</pre></div><p class=\"mt-4 text-gray-300\">Optimistic reads shine when writers are rare and you want minimal reader contention.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding stampedlock optimistic read is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying stampedlock optimistic read, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply stampedlock optimistic read will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with stampedlock optimistic read, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrency",
        "Control Flow",
        "OOP"
      ]
    },
    {
      "id": 335,
      "title": "335. Collectors.filtering critical services",
      "description": "Group services by audience and use Collectors.filtering to keep only critical names per bucket.",
      "initialCode": "import java.util.*;\nimport java.util.stream.*;\n\nrecord Service(String name, List<String> tags) {}\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Service> services = List.of(\n            new Service(\"auth\", List.of(\"critical\", \"customer-facing\")),\n            new Service(\"billing\", List.of(\"customer-facing\")),\n            new Service(\"docs\", List.of(\"internal\"))\n        );\n\n        // TODO: group services by whether they are customer-facing or internal\n        // Use Collectors.filtering to retain only critical service names in each group\n        // Print the groups in this order:\n        // customer-facing -> [auth]\n        // internal -> []\n    }\n}\n",
      "fullSolution": "import java.util.*;\nimport java.util.stream.*;\n\nrecord Service(String name, List<String> tags) {}\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Service> services = List.of(\n            new Service(\"auth\", List.of(\"critical\", \"customer-facing\")),\n            new Service(\"billing\", List.of(\"customer-facing\")),\n            new Service(\"docs\", List.of(\"internal\"))\n        );\n\n        Map<String, List<String>> criticalByAudience = services.stream()\n            .collect(Collectors.groupingBy(\n                service -> service.tags().contains(\"customer-facing\") ? \"customer-facing\" : \"internal\",\n                Collectors.filtering(\n                    service -> service.tags().contains(\"critical\"),\n                    Collectors.mapping(Service::name, Collectors.toList())\n                )\n            ));\n\n        for (String audience : List.of(\"customer-facing\", \"internal\")) {\n            List<String> names = criticalByAudience.getOrDefault(audience, List.of());\n            System.out.println(audience + \" -> \" + names);\n        }\n    }\n}\n",
      "expectedOutput": "customer-facing -> [auth]\ninternal -> []",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Collectors.filtering lets you drop elements inside a downstream collector without rewriting the surrounding pipeline. Pair it with groupingBy to keep each segment focused.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Map<K, V> view = items.stream()\n    .collect(Collectors.groupingBy(keyFn,\n        Collectors.filtering(predicate, downstream)));</pre></div><p class=\"mt-4 text-gray-300\">Filter inside the collector when you still need the original element for other aggregations.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding collectors.filtering critical services is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying collectors.filtering critical services, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply collectors.filtering critical services will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with collectors.filtering critical services, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Streams",
        "Collections"
      ]
    },
    {
      "id": 336,
      "title": "336. TemporalAdjusters sprint milestones",
      "description": "Use TemporalAdjusters to snap a date to the sprint start, find the next Friday retro, and the month-end release.",
      "initialCode": "import java.time.DayOfWeek;\nimport java.time.LocalDate;\nimport java.time.temporal.TemporalAdjusters;\n\npublic class Main {\n    public static void main(String[] args) {\n        LocalDate kickoff = LocalDate.of(2024, 4, 3);\n\n        // TODO: compute the sprint start by moving to the previous or same Monday\n        // Compute the retro two weeks later on the next Friday\n        // Compute the release as the last day of the month\n        // Print the three dates exactly as:\n        // Sprint start: 2024-04-01\n        // Retro: 2024-04-19\n        // Release: 2024-04-30\n    }\n}\n",
      "fullSolution": "import java.time.DayOfWeek;\nimport java.time.LocalDate;\nimport java.time.temporal.TemporalAdjusters;\n\npublic class Main {\n    public static void main(String[] args) {\n        LocalDate kickoff = LocalDate.of(2024, 4, 3);\n\n        LocalDate sprintStart = kickoff.with(TemporalAdjusters.previousOrSame(DayOfWeek.MONDAY));\n        LocalDate retro = sprintStart.plusWeeks(2).with(TemporalAdjusters.next(DayOfWeek.FRIDAY));\n        LocalDate release = kickoff.with(TemporalAdjusters.lastDayOfMonth());\n\n        System.out.println(\"Sprint start: \" + sprintStart);\n        System.out.println(\"Retro: \" + retro);\n        System.out.println(\"Release: \" + release);\n    }\n}\n",
      "expectedOutput": "Sprint start: 2024-04-01\nRetro: 2024-04-19\nRelease: 2024-04-30",
      "tutorial": "<p class=\"mb-4 text-gray-300\">TemporalAdjusters snap a LocalDate to calendar boundaries such as first/last days or relative weekdays.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">LocalDate start = date.with(TemporalAdjusters.previousOrSame(DayOfWeek.MONDAY));\nLocalDate retro = start.plusWeeks(2).with(TemporalAdjusters.next(DayOfWeek.FRIDAY));</pre></div><p class=\"mt-4 text-gray-300\">Mix adjusters to build sprint schedules, billing cycles, or reporting windows without manual arithmetic.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding temporaladjusters sprint milestones is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying temporaladjusters sprint milestones, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply temporaladjusters sprint milestones will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with temporaladjusters sprint milestones, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Date/Time",
        "Workflow"
      ]
    },
    {
      "id": 337,
      "title": "337. Stream.takeWhile latency window",
      "language": "java",
      "description": "Use Stream.takeWhile to keep low-latency samples and print them as a comma-separated list.",
      "initialCode": "import java.util.List;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> latencies = List.of(120, 140, 180, 250, 900, 200);\n\n        // TODO: stream the list, take values under 300 until the first slow request,\n        // and print them joined by ', ' on one line.\n    }\n}\n",
      "fullSolution": "import java.util.List;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> latencies = List.of(120, 140, 180, 250, 900, 200);\n\n        String output = latencies.stream()\n                .takeWhile(ms -> ms < 300)\n                .map(String::valueOf)\n                .collect(Collectors.joining(\", \"));\n        System.out.println(output);\n    }\n}\n",
      "expectedOutput": "120, 140, 180, 250",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Stream.takeWhile keeps consuming elements while the predicate holds, stopping as soon as the first failure appears. This is perfect for sorted metrics where everything after the first slow value is suspect.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">stream.takeWhile(predicate).map(...).collect(joining(\", \"))</pre></div><p class=\"mt-4 text-gray-300\">Because the stream short-circuits, you avoid scanning the rest of the data once a threshold is breached.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding stream.takewhile latency window is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying stream.takewhile latency window, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply stream.takewhile latency window will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with stream.takewhile latency window, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Streams",
        "Control Flow"
      ]
    },
    {
      "id": 338,
      "title": "338. Files.mismatch diff peek",
      "language": "java",
      "description": "Detect the first differing byte between two build artifacts with Files.mismatch.",
      "initialCode": "import java.nio.file.Files;\nimport java.nio.file.Path;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Path dir = Files.createTempDirectory(\"artifacts\");\n        Path buildA = dir.resolve(\"build-A.txt\");\n        Path buildB = dir.resolve(\"build-B.txt\");\n        Files.writeString(buildA, \"version=1.2.3\\nstatus=ready\\n\");\n        Files.writeString(buildB, \"version=1.2.4\\nstatus=ready\\n\");\n\n        // TODO: use Files.mismatch to find the first differing byte\n        // Print \"Mismatch at byte <index>\" when they differ or \"Files match\" when it returns -1\n\n        // Clean up the temp directory (delete files and the directory)\n    }\n}\n",
      "fullSolution": "import java.nio.file.Files;\nimport java.nio.file.Path;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Path dir = Files.createTempDirectory(\"artifacts\");\n        Path buildA = dir.resolve(\"build-A.txt\");\n        Path buildB = dir.resolve(\"build-B.txt\");\n        Files.writeString(buildA, \"version=1.2.3\\nstatus=ready\\n\");\n        Files.writeString(buildB, \"version=1.2.4\\nstatus=ready\\n\");\n\n        try {\n            long position = Files.mismatch(buildA, buildB);\n            if (position == -1L) {\n                System.out.println(\"Files match\");\n            } else {\n                System.out.println(\"Mismatch at byte \" + position);\n            }\n        } finally {\n            Files.deleteIfExists(buildA);\n            Files.deleteIfExists(buildB);\n            Files.deleteIfExists(dir);\n        }\n    }\n}\n",
      "expectedOutput": "Mismatch at byte 12",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Files.mismatch(Path, Path) (Java 12+) returns the first differing byte position or -1 when files are identical, giving you a fast health check for generated artifacts.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">long diff = Files.mismatch(a, b);\nif (diff == -1) {\n    System.out.println(\"match\");\n}</pre></div><p class=\"mt-4 text-gray-300\">Wrap comparisons in try/finally so temporary fixtures are cleaned even if the comparison raises.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding files.mismatch diff peek is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying files.mismatch diff peek, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply files.mismatch diff peek will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with files.mismatch diff peek, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "IO",
        "Testing",
        "Workflow"
      ]
    },
    {
      "id": 339,
      "title": "339. Stream.dropWhile incident tail",
      "language": "java",
      "description": "Use Stream.dropWhile to skip healthy entries and print the remaining alerts.",
      "initialCode": "import java.util.List;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> statuses = List.of(\"OK\", \"OK\", \"WARN\", \"FAIL\", \"OK\");\n\n        // TODO: drop leading \"OK\" entries, keep the rest, and print them joined by ', ' on one line\n    }\n}\n",
      "fullSolution": "import java.util.List;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> statuses = List.of(\"OK\", \"OK\", \"WARN\", \"FAIL\", \"OK\");\n\n        String tail = statuses.stream()\n                .dropWhile(\"OK\"::equals)\n                .collect(Collectors.joining(\", \"));\n        System.out.println(tail);\n    }\n}\n",
      "expectedOutput": "WARN, FAIL, OK",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Stream.dropWhile continues removing elements while the predicate is true, then yields the rest unchanged. Pair it with dropWhile to ignore the calm before the incident and focus on the tail of warnings.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">var tail = list.stream().dropWhile(predicate).collect(joining(\", \"));</pre></div><p class=\"mt-4 text-gray-300\">Unlike filter, dropWhile only trims the front of the stream, preserving later entries even if they match the predicate.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding stream.dropwhile incident tail is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying stream.dropwhile incident tail, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply stream.dropwhile incident tail will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with stream.dropwhile incident tail, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Streams",
        "Control Flow"
      ]
    },
    {
      "id": 340,
      "title": "340. Map.copyOf defensive snapshot",
      "language": "java",
      "description": "Create an unmodifiable copy of configuration overrides with Map.copyOf and confirm it is immutable.",
      "initialCode": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, String> overrides = new HashMap<>();\n        overrides.put(\"region\", \"us-west-2\");\n        overrides.put(\"tier\", \"gold\");\n\n        // TODO: take an immutable snapshot with Map.copyOf\n        // Mutate overrides afterwards (change tier to 'silver')\n        // Print the snapshot tier value, then attempt to put a new entry\n        // Catch UnsupportedOperationException and print \"immutable\"\n    }\n}\n",
      "fullSolution": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, String> overrides = new HashMap<>();\n        overrides.put(\"region\", \"us-west-2\");\n        overrides.put(\"tier\", \"gold\");\n\n        Map<String, String> snapshot = Map.copyOf(overrides);\n        overrides.put(\"tier\", \"silver\");\n\n        System.out.println(snapshot.get(\"tier\"));\n        try {\n            snapshot.put(\"status\", \"locked\");\n        } catch (UnsupportedOperationException ex) {\n            System.out.println(\"immutable\");\n        }\n    }\n}\n",
      "expectedOutput": "gold\nimmutable",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Map.copyOf creates an unmodifiable snapshot of the input map, ideal for freezing configuration before handing it to other threads.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Map<String, String> snapshot = Map.copyOf(source);</pre></div><p class=\"mt-4 text-gray-300\">Subsequent mutations to the original map do not affect the snapshot, and write attempts on the snapshot raise UnsupportedOperationException.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding map.copyof defensive snapshot is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying map.copyof defensive snapshot, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply map.copyof defensive snapshot will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with map.copyof defensive snapshot, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Collections",
        "OOP"
      ]
    },
    {
      "id": 341,
      "title": "341. Stream.iterate capacity ramp",
      "language": "java",
      "description": "Generate doubling capacity steps with the three-argument Stream.iterate overload and print them in order.",
      "initialCode": "import java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class Main {\n    public static void main(String[] args) {\n        // TODO: use Stream.iterate(seed, predicate, step) starting at 1\n        // Keep doubling while the value is less than 70\n        // Collect the numbers into a string joined by ' -> ' and print it\n    }\n}\n",
      "fullSolution": "import java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class Main {\n    public static void main(String[] args) {\n        String steps = Stream.iterate(1, value -> value < 70, value -> value * 2)\n                .map(String::valueOf)\n                .collect(Collectors.joining(\" -> \"));\n        System.out.println(steps);\n    }\n}\n",
      "expectedOutput": "1 -> 2 -> 4 -> 8 -> 16 -> 32 -> 64",
      "tutorial": "<p class=\"mb-4 text-gray-300\">The Java 9 Stream.iterate(seed, predicate, next) overload generates finite sequences without extra takeWhile/filter calls. Here we double capacity until hitting the threshold.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Stream.iterate(seed, predicate, next)</pre></div><p class=\"mt-4 text-gray-300\">Use this form whenever you have a deterministic termination condition to keep streams declarative.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding stream.iterate capacity ramp is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying stream.iterate capacity ramp, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply stream.iterate capacity ramp will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with stream.iterate capacity ramp, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Streams",
        "Math and Stats"
      ]
    },
    {
      "id": 342,
      "title": "342. LocalDate.datesUntil sprint cadence",
      "language": "java",
      "description": "List weekly sprint review dates using LocalDate.datesUntil with a Period step.",
      "initialCode": "import java.time.LocalDate;\nimport java.time.Period;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        LocalDate kickoff = LocalDate.of(2024, 4, 1);\n        LocalDate endExclusive = kickoff.plusWeeks(6);\n\n        // TODO: use datesUntil with a weekly Period to collect all review dates\n        // Print them joined by ', ' in ISO format\n    }\n}\n",
      "fullSolution": "import java.time.LocalDate;\nimport java.time.Period;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        LocalDate kickoff = LocalDate.of(2024, 4, 1);\n        LocalDate endExclusive = kickoff.plusWeeks(6);\n\n        String reviews = kickoff.datesUntil(endExclusive, Period.ofWeeks(1))\n                .map(LocalDate::toString)\n                .collect(Collectors.joining(\", \"));\n        System.out.println(reviews);\n    }\n}\n",
      "expectedOutput": "2024-04-01, 2024-04-08, 2024-04-15, 2024-04-22, 2024-04-29, 2024-05-06",
      "tutorial": "<p class=\"mb-4 text-gray-300\">LocalDate.datesUntil(endExclusive, step) walks a range of dates with the granularity you choose. Stepping by a weekly Period keeps recurring ceremonies aligned.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">start.datesUntil(end, Period.ofWeeks(1))</pre></div><p class=\"mt-4 text-gray-300\">Choose endExclusive as the first date you want to exclude so the range remains intuitive.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding localdate.datesuntil sprint cadence is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying localdate.datesuntil sprint cadence, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply localdate.datesuntil sprint cadence will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with localdate.datesuntil sprint cadence, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Date/Time",
        "Workflow"
      ]
    },
    {
      "id": 343,
      "title": "343. Median latency snapshot",
      "description": "Sort latency samples and compute the median as a double, then print it.",
      "initialCode": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> latencies = new ArrayList<>(List.of(210, 190, 240, 180, 195, 205));\n\n        // TODO: compute the median latency as a double\n        // Print \"Median latency: <value>\"\n    }\n}\n",
      "fullSolution": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> latencies = new ArrayList<>(List.of(210, 190, 240, 180, 195, 205));\n\n        Collections.sort(latencies);\n        int size = latencies.size();\n        double median;\n        if (size % 2 == 1) {\n            median = latencies.get(size / 2);\n        } else {\n            int right = size / 2;\n            int left = right - 1;\n            median = (latencies.get(left) + latencies.get(right)) / 2.0;\n        }\n        System.out.println(\"Median latency: \" + median);\n    }\n}\n",
      "expectedOutput": "Median latency: 200.0",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Clone the data into a mutable list, sort it, and average the middle values when the count is even.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Collections.sort(samples);\nint left = count / 2 - 1;\ndouble median = (samples.get(left) + samples.get(left + 1)) / 2.0;</pre></div><p class=\"mt-4 text-gray-300\">Use medians to report typical latency when outliers make the mean jump around.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding median latency snapshot is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying median latency snapshot, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply median latency snapshot will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with median latency snapshot, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Intermediate",
        "Data Processing",
        "Math and Stats"
      ]
    },
    {
      "id": 344,
      "title": "344. Linear regression forecast",
      "description": "Run a least-squares linear regression on quarterly signups and project the next quarter.",
      "initialCode": "import java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        double[] quarters = {1, 2, 3, 4};\n        double[] signups = {120, 150, 170, 210};\n\n        // TODO: compute the slope and intercept using least squares\n        // Print slope:<value> and intercept:<value> with two decimals\n        // Project quarter 5 and print q5:<value> with two decimals\n    }\n}\n",
      "fullSolution": "import java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        double[] quarters = {1, 2, 3, 4};\n        double[] signups = {120, 150, 170, 210};\n\n        int n = quarters.length;\n        double meanX = Arrays.stream(quarters).average().orElseThrow();\n        double meanY = Arrays.stream(signups).average().orElseThrow();\n\n        double numerator = 0.0;\n        double denominator = 0.0;\n        for (int i = 0; i < n; i++) {\n            double dx = quarters[i] - meanX;\n            double dy = signups[i] - meanY;\n            numerator += dx * dy;\n            denominator += dx * dx;\n        }\n\n        double slope = numerator / denominator;\n        double intercept = meanY - slope * meanX;\n        double projection = slope * 5 + intercept;\n\n        System.out.printf(\"slope:%.2f%n\", slope);\n        System.out.printf(\"intercept:%.2f%n\", intercept);\n        System.out.printf(\"q5:%.2f%n\", projection);\n    }\n}\n",
      "expectedOutput": "slope:29.00\nintercept:90.00\nq5:235.00",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Compute the mean of x and y, sum (x-meanX)*(y-meanY), and divide by the sum of squared x deltas to get the slope.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">double slope = num / den;\ndouble intercept = meanY - slope * meanX;</pre></div><p class=\"mt-4 text-gray-300\">With slope and intercept, you can forecast workloads or revenue by plugging in the next index.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding linear regression forecast is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying linear regression forecast, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply linear regression forecast will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with linear regression forecast, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Advanced",
        "Data Processing",
        "Math and Stats"
      ]
    },
    {
      "id": 345,
      "title": "345. Jar deployment bundle",
      "description": "Assemble a tiny deployment jar with a manifest and resource file, then inspect its entries.",
      "initialCode": "import java.nio.charset.StandardCharsets;\nimport java.nio.file.FileSystem;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport java.util.jar.Attributes;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarOutputStream;\nimport java.util.jar.Manifest;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Path runRoot = Paths.get(System.getenv(\"RUN_TMP_DIR\") != null\n                ? System.getenv(\"RUN_TMP_DIR\")\n                : System.getProperty(\"java.io.tmpdir\"));\n        Path jarPath = runRoot.resolve(\"deploy-app.jar\");\n\n        // TODO: delete any existing jar at jarPath\n        // Create a manifest with version 1.0 and Main-Class hello.App\n        // Write hello/version.txt with the value 1.0.0 into the jar\n        // Reopen the jar with FileSystems.newFileSystem and collect regular file entries\n        // Print \"Created deploy-app.jar\" and then \"Entries: <comma separated list>\"\n    }\n}\n",
      "fullSolution": "import java.nio.charset.StandardCharsets;\nimport java.nio.file.FileSystem;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport java.util.jar.Attributes;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarOutputStream;\nimport java.util.jar.Manifest;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Path runRoot = Paths.get(System.getenv(\"RUN_TMP_DIR\") != null\n                ? System.getenv(\"RUN_TMP_DIR\")\n                : System.getProperty(\"java.io.tmpdir\"));\n        Path jarPath = runRoot.resolve(\"deploy-app.jar\");\n\n        Files.deleteIfExists(jarPath);\n\n        Manifest manifest = new Manifest();\n        Attributes attributes = manifest.getMainAttributes();\n        attributes.put(Attributes.Name.MANIFEST_VERSION, \"1.0\");\n        attributes.put(Attributes.Name.MAIN_CLASS, \"hello.App\");\n\n        try (JarOutputStream jar = new JarOutputStream(Files.newOutputStream(jarPath), manifest)) {\n            JarEntry entry = new JarEntry(\"hello/version.txt\");\n            jar.putNextEntry(entry);\n            jar.write(\"1.0.0\\n\".getBytes(StandardCharsets.UTF_8));\n            jar.closeEntry();\n        }\n\n        System.out.println(\"Created \" + jarPath.getFileName());\n\n        try (FileSystem fs = FileSystems.newFileSystem(jarPath, Collections.emptyMap());\n             Stream<Path> stream = Files.walk(fs.getPath(\"/\"))) {\n            List<String> entries = stream\n                    .filter(Files::isRegularFile)\n                    .map(path -> {\n                        String name = path.toString();\n                        return name.startsWith(\"/\") ? name.substring(1) : name;\n                    })\n                    .sorted()\n                    .collect(Collectors.toList());\n            System.out.println(\"Entries: \" + String.join(\", \", entries));\n        }\n    }\n}\n",
      "expectedOutput": "Created deploy-app.jar\nEntries: META-INF/MANIFEST.MF, hello/version.txt",
      "tutorial": "<p class=\"mb-4 text-gray-300\">JarOutputStream writes the manifest and entries into a standard zip archive that the JVM understands.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">new JarOutputStream(Files.newOutputStream(path), manifest)</pre></div><p class=\"mt-4 text-gray-300\">Reopen the jar with FileSystems.newFileSystem to spot-check contents during packaging steps or CI checks.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding jar deployment bundle is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying jar deployment bundle, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply jar deployment bundle will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with jar deployment bundle, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "language": "java",
      "tags": [
        "Advanced",
        "Deployment",
        "Packaging",
        "Tooling"
      ]
    },
    {
      "id": 346,
      "title": "346. DoubleSummaryStatistics throughput",
      "description": "Gather count, min, average, and max latency using DoubleSummaryStatistics and print a formatted summary.",
      "language": "java",
      "initialCode": "import java.util.DoubleSummaryStatistics;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Double> latencies = List.of(215.0, 198.5, 202.4, 211.2);\n\n        // TODO: create DoubleSummaryStatistics from latencies (use stream().mapToDouble().summaryStatistics())\n        // Print count, min, avg, max on separate lines using the format:\n        // count:<value>\n        // min:<value>\n        // avg:<value>\n        // max:<value>\n        // avg should be rounded to one decimal place\n    }\n}\n",
      "fullSolution": "import java.util.DoubleSummaryStatistics;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Double> latencies = List.of(215.0, 198.5, 202.4, 211.2);\n\n        DoubleSummaryStatistics stats = latencies.stream()\n                .mapToDouble(Double::doubleValue)\n                .summaryStatistics();\n\n        System.out.printf(\"count:%d%n\", stats.getCount());\n        System.out.printf(\"min:%.1f%n\", stats.getMin());\n        System.out.printf(\"avg:%.1f%n\", stats.getAverage());\n        System.out.printf(\"max:%.1f%n\", stats.getMax());\n    }\n}\n",
      "expectedOutput": "count:4\nmin:198.5\navg:206.8\nmax:215.0",
      "tutorial": "<p class=\"mb-4 text-gray-300\">DoubleSummaryStatistics collects count, min, max, sum, and average in a single pass, perfect for latency or throughput dashboards.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">DoubleSummaryStatistics stats = values.stream()\\n    .mapToDouble(Double::doubleValue)\\n    .summaryStatistics();</pre></div><p class=\"mt-4 text-gray-300\">Format the numbers to the precision your SLO dashboards expect before printing.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding doublesummarystatistics throughput is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying doublesummarystatistics throughput, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply doublesummarystatistics throughput will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with doublesummarystatistics throughput, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Data Processing",
        "Math and Stats"
      ]
    },
    {
      "id": 347,
      "title": "347. Reflection deprecated audit",
      "description": "Use reflection to list methods annotated with @Deprecated and report their version metadata.",
      "language": "java",
      "initialCode": "import java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\nclass Scheduler {\n    @Deprecated(since = \"1.2\", forRemoval = false)\n    public void processLegacyQueue() {}\n\n    public void runHealthCheck() {}\n\n    @Deprecated(since = \"2.0\", forRemoval = true)\n    public void flushOldJobs() {}\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        // TODO: inspect Scheduler.class.getDeclaredMethods()\n        // Filter methods annotated with @Deprecated\n        // Sort them by method name\n        // Print lines formatted as \"<methodName> -> since <value> (forRemoval=<flag>)\"\n    }\n}\n",
      "fullSolution": "import java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\nclass Scheduler {\n    @Deprecated(since = \"1.2\", forRemoval = false)\n    public void processLegacyQueue() {}\n\n    public void runHealthCheck() {}\n\n    @Deprecated(since = \"2.0\", forRemoval = true)\n    public void flushOldJobs() {}\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Method[] methods = Scheduler.class.getDeclaredMethods();\n        Arrays.stream(methods)\n                .filter(method -> method.isAnnotationPresent(Deprecated.class))\n                .sorted(Comparator.comparing(Method::getName))\n                .forEach(method -> {\n                    Deprecated deprecated = method.getAnnotation(Deprecated.class);\n                    System.out.printf(\"%s -> since %s (forRemoval=%s)%n\",\n                            method.getName(),\n                            deprecated.since(),\n                            deprecated.forRemoval());\n                });\n    }\n}\n",
      "expectedOutput": "flushOldJobs -> since 2.0 (forRemoval=true)\nprocessLegacyQueue -> since 1.2 (forRemoval=false)",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Reflection lets you turn annotations into runtime metadata so you can build audits and tooling without hand-maintaining allowlists.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Arrays.stream(type.getDeclaredMethods())\\n    .filter(m -> m.isAnnotationPresent(Deprecated.class))</pre></div><p class=\"mt-4 text-gray-300\">Sort the results for deterministic output, especially when feeding reports into CI pipelines.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding reflection deprecated audit is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying reflection deprecated audit, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply reflection deprecated audit will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with reflection deprecated audit, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Metaprogramming",
        "Tooling"
      ]
    },
    {
      "id": 348,
      "title": "348. ZipOutputStream static bundle",
      "description": "Package a static site directory into a zip archive with ZipOutputStream and list its entries.",
      "language": "java",
      "initialCode": "import java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipOutputStream;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Path runRoot = Paths.get(System.getenv(\"RUN_TMP_DIR\") != null\n                ? System.getenv(\"RUN_TMP_DIR\")\n                : System.getProperty(\"java.io.tmpdir\"));\n        Path siteDir = runRoot.resolve(\"static-site\");\n        Path zipPath = runRoot.resolve(\"static-site.zip\");\n\n        // TODO: delete existing directory and zip if they exist\n        // Recreate static-site with index.html and assets/style.css\n        // Write simple contents to each file\n        // Use ZipOutputStream to add both files to the archive (strip the siteDir prefix for entry names)\n        // Print \"Created static-site.zip\" then \"Entries: <comma-separated sorted names>\" (skip directory entries)\n    }\n}\n",
      "fullSolution": "import java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipOutputStream;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Path runRoot = Paths.get(System.getenv(\"RUN_TMP_DIR\") != null\n                ? System.getenv(\"RUN_TMP_DIR\")\n                : System.getProperty(\"java.io.tmpdir\"));\n        Path siteDir = runRoot.resolve(\"static-site\");\n        Path zipPath = runRoot.resolve(\"static-site.zip\");\n\n        if (Files.exists(siteDir)) {\n            Files.walk(siteDir)\n                    .sorted(Comparator.reverseOrder())\n                    .forEach(path -> {\n                        try {\n                            Files.delete(path);\n                        } catch (IOException ex) {\n                            throw new RuntimeException(ex);\n                        }\n                    });\n        }\n        Files.deleteIfExists(zipPath);\n\n        Files.createDirectories(siteDir.resolve(\"assets\"));\n        Files.writeString(siteDir.resolve(\"index.html\"), \"<h1>Launch</h1>\\n\", StandardCharsets.UTF_8);\n        Files.writeString(siteDir.resolve(\"assets\").resolve(\"style.css\"), \"body { font-family: sans-serif; }\\n\", StandardCharsets.UTF_8);\n\n        try (ZipOutputStream zip = new ZipOutputStream(Files.newOutputStream(zipPath))) {\n            Files.walk(siteDir)\n                    .filter(Files::isRegularFile)\n                    .forEach(path -> {\n                        Path relative = siteDir.relativize(path);\n                        ZipEntry entry = new ZipEntry(relative.toString().replace('\\\\', '/'));\n                        try {\n                            zip.putNextEntry(entry);\n                            zip.write(Files.readAllBytes(path));\n                            zip.closeEntry();\n                        } catch (IOException ex) {\n                            throw new RuntimeException(ex);\n                        }\n                    });\n        }\n\n        System.out.println(\"Created static-site.zip\");\n        try (ZipFile zipFile = new ZipFile(zipPath.toFile())) {\n            List<String> names = zipFile.stream()\n                    .map(ZipEntry::getName)\n                    .filter(name -> !name.endsWith(\"/\"))\n                    .sorted()\n                    .collect(Collectors.toList());\n            System.out.println(\"Entries: \" + String.join(\", \", names));\n        }\n    }\n}\n",
      "expectedOutput": "Created static-site.zip\nEntries: assets/style.css, index.html",
      "tutorial": "<p class=\"mb-4 text-gray-300\">ZipOutputStream lets you build deployment bundles without calling external tools, keeping CI steps portable.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">try (ZipOutputStream zip = new ZipOutputStream(out)) {\\n    Files.walk(root)\\n        .filter(Files::isRegularFile)\\n        .forEach(path -> zip.putNextEntry(new ZipEntry(...)));\\n}</pre></div><p class=\"mt-4 text-gray-300\">Normalize separators to '/' so archives look the same on every platform.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding zipoutputstream static bundle is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying zipoutputstream static bundle, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply zipoutputstream static bundle will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with zipoutputstream static bundle, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Deployment",
        "Packaging",
        "Tooling"
      ]
    },
    {
      "id": 349,
      "title": "349. Class-based router",
      "description": "Route payloads by their runtime class using a handler map and print formatted messages.",
      "language": "java",
      "initialCode": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.function.Consumer;\n\nclass AuditRouter {\n    private final Map<Class<?>, Consumer<Object>> handlers = new HashMap<>();\n    private final List<String> emitted = new ArrayList<>();\n\n    public AuditRouter() {\n        // TODO: register handlers for Map.class, String.class, and Integer.class\n        // Map handler should append and print \"map:<status>\" using map.get(\"status\")\n        // String handler should uppercase the payload before printing with prefix \"str:\"\n        // Integer handler should print with prefix \"int:\"\n    }\n\n    public void emit(Object payload) {\n        Consumer<Object> handler = handlers.entrySet().stream()\n                .filter(entry -> entry.getKey().isInstance(payload))\n                .map(Entry::getValue)\n                .findFirst()\n                .orElseThrow(() -> new IllegalArgumentException(\n                        \"Unsupported type: \" + payload.getClass().getSimpleName()\n                ));\n        handler.accept(payload);\n    }\n\n    public List<String> getEmitted() {\n        return emitted;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        AuditRouter router = new AuditRouter();\n        List<Object> records = List.of(\n                Map.of(\"status\", \"ok\"),\n                \"retry later\",\n                Map.of(\"status\", \"error\"),\n                2\n        );\n\n        // TODO: call emit for each record\n    }\n}\n",
      "fullSolution": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.function.Consumer;\n\nclass AuditRouter {\n    private final Map<Class<?>, Consumer<Object>> handlers = new HashMap<>();\n    private final List<String> emitted = new ArrayList<>();\n\n    public AuditRouter() {\n        handlers.put(Map.class, payload -> {\n            @SuppressWarnings(\"unchecked\")\n            Map<String, String> record = (Map<String, String>) payload;\n            String message = \"map:\" + record.get(\"status\");\n            emitted.add(message);\n            System.out.println(message);\n        });\n        handlers.put(String.class, payload -> {\n            String message = \"str:\" + ((String) payload).toUpperCase();\n            emitted.add(message);\n            System.out.println(message);\n        });\n        handlers.put(Integer.class, payload -> {\n            String message = \"int:\" + payload;\n            emitted.add(message);\n            System.out.println(message);\n        });\n    }\n\n    public void emit(Object payload) {\n        Consumer<Object> handler = handlers.entrySet().stream()\n                .filter(entry -> entry.getKey().isInstance(payload))\n                .map(Entry::getValue)\n                .findFirst()\n                .orElseThrow(() -> new IllegalArgumentException(\n                        \"Unsupported type: \" + payload.getClass().getSimpleName()\n                ));\n        handler.accept(payload);\n    }\n\n    public List<String> getEmitted() {\n        return emitted;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        AuditRouter router = new AuditRouter();\n        List<Object> records = List.of(\n                Map.of(\"status\", \"ok\"),\n                \"retry later\",\n                Map.of(\"status\", \"error\"),\n                2\n        );\n\n        records.forEach(router::emit);\n    }\n}\n",
      "expectedOutput": "map:ok\nstr:RETRY LATER\nmap:error\nint:2",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Mapping runtime classes to handlers mirrors Python's singledispatchmethod: one entry point, multiple type-aware implementations.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">handlers.put(Type.class, payload -> { /* format and emit */ });</pre></div><p class=\"mt-4 text-gray-300\">Throw on unsupported types so missing registrations fail loudly during tests.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding class-based router is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying class-based router, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply class-based router will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with class-based router, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "OOP",
        "Workflow"
      ]
    },
    {
      "id": 350,
      "title": "350. Geometric mean growth",
      "description": "Compute the geometric mean of growth factors with streams and report the compounded percentage.",
      "language": "java",
      "initialCode": "import java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        double[] growthRates = {1.05, 1.08, 0.97, 1.12};\n\n        // TODO: compute the geometric mean of growthRates using Arrays.stream\n        // Convert it to a percentage over baseline (subtract 1, then multiply by 100)\n        // Print \"Geometric mean: <value>%\" with two decimals\n    }\n}\n",
      "fullSolution": "import java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        double[] growthRates = {1.05, 1.08, 0.97, 1.12};\n\n        double product = Arrays.stream(growthRates)\n                .reduce(1.0, (a, b) -> a * b);\n        double mean = Math.pow(product, 1.0 / growthRates.length);\n        double percent = (mean - 1.0) * 100;\n\n        System.out.printf(\"Geometric mean: %.2f%%%n\", percent);\n    }\n}\n",
      "expectedOutput": "Geometric mean: 5.35%",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Reduce the factors into a product, then raise it to 1/n to capture compounded growth without letting outliers dominate.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">double product = stream.reduce(1.0, (a, b) -> a * b);\ndouble mean = Math.pow(product, 1.0 / n);</pre></div><p class=\"mt-4 text-gray-300\">Translate the multiplier back to a percentage so stakeholders can read the result at a glance.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding geometric mean growth is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying geometric mean growth, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply geometric mean growth will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with geometric mean growth, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Data Processing",
        "Math and Stats"
      ]
    },
    {
      "title": "351. VarHandle atomic counter",
      "language": "java",
      "description": "Use VarHandle to atomically initialize and increment a counter field, then print the final value.",
      "initialCode": "import java.lang.invoke.MethodHandles;\nimport java.lang.invoke.VarHandle;\n\npublic class Main {\n    static final class Metrics {\n        volatile int count;\n    }\n\n    public static void main(String[] args) throws Exception {\n        Metrics metrics = new Metrics();\n\n        // TODO: obtain a VarHandle for Metrics.count, set it to 10,\n        // atomically add 5 using getAndAdd, then print the current value.\n    }\n}\n",
      "fullSolution": "import java.lang.invoke.MethodHandles;\nimport java.lang.invoke.VarHandle;\n\npublic class Main {\n    static final class Metrics {\n        volatile int count;\n    }\n\n    public static void main(String[] args) throws Exception {\n        Metrics metrics = new Metrics();\n        VarHandle handle = MethodHandles.lookup().findVarHandle(Metrics.class, \"count\", int.class);\n        handle.set(metrics, 10);\n        handle.getAndAdd(metrics, 5);\n        System.out.println((int) handle.getVolatile(metrics));\n    }\n}\n",
      "expectedOutput": "15",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>VarHandle</code> offers lock-free access to fields and array elements. Locate the handle once, then use operations such as <code>getAndAdd</code> to perform atomic arithmetic.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">VarHandle h = MethodHandles.lookup().findVarHandle(Type.class, \"field\", int.class);\nh.getAndAdd(obj, 1);\nint value = (int) h.getVolatile(obj);</pre></div>\n<p class=\"mt-4 text-gray-300\">VarHandles reduce the need for <code>AtomicInteger</code> wrappers when you want field-level atomics.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding varhandle atomic counter is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying varhandle atomic counter, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply varhandle atomic counter will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with varhandle atomic counter, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrency",
        "JVM Internals"
      ],
      "id": 351
    },
    {
      "title": "352. Flow publisher subscriber",
      "language": "java",
      "description": "Wire a SubmissionPublisher to a Flow.Subscriber, capture events, and print them in order.",
      "initialCode": "import java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.Flow;\nimport java.util.concurrent.SubmissionPublisher;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        SubmissionPublisher<String> publisher = new SubmissionPublisher<>();\n        StringBuilder log = new StringBuilder();\n        CountDownLatch done = new CountDownLatch(1);\n\n        Flow.Subscriber<String> subscriber = new Flow.Subscriber<>() {\n            private Flow.Subscription subscription;\n\n            @Override\n            public void onSubscribe(Flow.Subscription subscription) {\n                this.subscription = subscription;\n                // TODO: request all items\n            }\n\n            @Override\n            public void onNext(String item) {\n                // TODO: append \"onNext: <item>\" followed by System.lineSeparator()\n                // then request the next item\n            }\n\n            @Override\n            public void onError(Throwable throwable) {\n                log.append(\"error: \").append(throwable.getMessage()).append(System.lineSeparator());\n                done.countDown();\n            }\n\n            @Override\n            public void onComplete() {\n                log.append(\"complete\").append(System.lineSeparator());\n                done.countDown();\n            }\n        };\n\n        // TODO: subscribe the subscriber, submit \"deploy\" then \"done\",\n        // close the publisher, wait for the latch, and finally print the log.\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.Flow;\nimport java.util.concurrent.SubmissionPublisher;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        SubmissionPublisher<String> publisher = new SubmissionPublisher<>();\n        StringBuilder log = new StringBuilder();\n        CountDownLatch done = new CountDownLatch(1);\n\n        Flow.Subscriber<String> subscriber = new Flow.Subscriber<>() {\n            private Flow.Subscription subscription;\n\n            @Override\n            public void onSubscribe(Flow.Subscription subscription) {\n                this.subscription = subscription;\n                subscription.request(1);\n            }\n\n            @Override\n            public void onNext(String item) {\n                log.append(\"onNext: \").append(item).append(System.lineSeparator());\n                subscription.request(1);\n            }\n\n            @Override\n            public void onError(Throwable throwable) {\n                log.append(\"error: \").append(throwable.getMessage()).append(System.lineSeparator());\n                done.countDown();\n            }\n\n            @Override\n            public void onComplete() {\n                log.append(\"complete\").append(System.lineSeparator());\n                done.countDown();\n            }\n        };\n\n        publisher.subscribe(subscriber);\n        publisher.submit(\"deploy\");\n        publisher.submit(\"done\");\n        publisher.close();\n\n        done.await();\n        System.out.print(log.toString());\n    }\n}\n",
      "expectedOutput": "onNext: deploy\nonNext: done\ncomplete",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>SubmissionPublisher</code> implements the Reactive Streams <code>Flow.Publisher</code> API. Request demand in <code>onSubscribe</code>, process events in <code>onNext</code>, and close resources in <code>onComplete</code>.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">publisher.subscribe(subscriber);\npublisher.submit(data);\npublisher.close();\nlatched.await();</pre></div>\n<p class=\"mt-4 text-gray-300\">Latch the completion signal to keep the JVM alive until the asynchronous publisher finishes delivering items.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding flow publisher subscriber is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying flow publisher subscriber, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply flow publisher subscriber will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with flow publisher subscriber, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrency",
        "Reactive"
      ],
      "id": 352
    },
    {
      "title": "353. Cleaner resource finalizer",
      "language": "java",
      "description": "Register a resource with java.lang.ref.Cleaner so closing it triggers deterministic cleanup output.",
      "initialCode": "import java.lang.ref.Cleaner;\n\npublic class Main {\n    static final Cleaner CLEANER = Cleaner.create();\n\n    static final class TrackedResource implements AutoCloseable {\n        private final Cleaner.Cleanable cleanable;\n        private boolean closed;\n\n        TrackedResource(String name) {\n            // TODO: register a cleanup action that prints \"cleanup \" + name\n            this.cleanable = null;\n        }\n\n        @Override\n        public void close() {\n            if (closed) {\n                return;\n            }\n            closed = true;\n            System.out.println(\"closing resource\");\n            // TODO: trigger the cleanup immediately\n        }\n    }\n\n    public static void main(String[] args) {\n        try (TrackedResource resource = new TrackedResource(\"cache\")) {\n            System.out.println(\"work\");\n        }\n    }\n}\n",
      "fullSolution": "import java.lang.ref.Cleaner;\n\npublic class Main {\n    static final Cleaner CLEANER = Cleaner.create();\n\n    static final class TrackedResource implements AutoCloseable {\n        private final Cleaner.Cleanable cleanable;\n        private boolean closed;\n\n        TrackedResource(String name) {\n            this.cleanable = CLEANER.register(this, () -> System.out.println(\"cleanup \" + name));\n        }\n\n        @Override\n        public void close() {\n            if (closed) {\n                return;\n            }\n            closed = true;\n            System.out.println(\"closing resource\");\n            cleanable.clean();\n        }\n    }\n\n    public static void main(String[] args) {\n        try (TrackedResource resource = new TrackedResource(\"cache\")) {\n            System.out.println(\"work\");\n        }\n    }\n}\n",
      "expectedOutput": "work\nclosing resource\ncleanup cache",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use <code>Cleaner</code> to register cleanup tasks that run when a resource is closed or garbage collected. Calling <code>clean()</code> executes the action immediately and deregisters it.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Cleaner cleaner = Cleaner.create();\nCleaner.Cleanable cleanable = cleaner.register(obj, () -> release());\ncleanable.clean();</pre></div>\n<p class=\"mt-4 text-gray-300\">Pair <code>Cleaner</code> with try-with-resources so cleanup runs deterministically, while still safeguarding against leaked handles.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding cleaner resource finalizer is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying cleaner resource finalizer, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply cleaner resource finalizer will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with cleaner resource finalizer, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Lifecycle",
        "Resources"
      ],
      "id": 353
    },
    {
      "title": "354. LinkedTransferQueue handoff",
      "language": "java",
      "description": "Coordinate a producer and consumer with LinkedTransferQueue.transfer and print the received items.",
      "initialCode": "import java.util.concurrent.LinkedTransferQueue;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        LinkedTransferQueue<String> queue = new LinkedTransferQueue<>();\n\n        // TODO: start a producer thread that transfers \"alpha\" then \"beta\".\n        // Start a consumer thread that takes two items and prints each.\n        // Join both threads at the end.\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.LinkedTransferQueue;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        LinkedTransferQueue<String> queue = new LinkedTransferQueue<>();\n\n        Thread producer = new Thread(() -> {\n            try {\n                queue.transfer(\"alpha\");\n                queue.transfer(\"beta\");\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        });\n\n        Thread consumer = new Thread(() -> {\n            try {\n                System.out.println(queue.take());\n                System.out.println(queue.take());\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        });\n\n        producer.start();\n        consumer.start();\n        producer.join();\n        consumer.join();\n    }\n}\n",
      "expectedOutput": "alpha\nbeta",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>LinkedTransferQueue</code> combines the best of queues and synchronous handoff channels. <code>transfer</code> blocks until a consumer receives the element, making it ideal for throttled pipelines.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">queue.transfer(task);\nString item = queue.take();</pre></div>\n<p class=\"mt-4 text-gray-300\">Because <code>transfer</code> waits for a taker, producers and consumers stay in lock-step without extra signaling.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding linkedtransferqueue handoff is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying linkedtransferqueue handoff, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply linkedtransferqueue handoff will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with linkedtransferqueue handoff, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrency",
        "Queues"
      ],
      "id": 354
    },
    {
      "title": "355. StackWalker method trace",
      "language": "java",
      "description": "Use StackWalker to capture the top of the call stack and print the method chain.",
      "initialCode": "import java.util.stream.Collectors;\nimport java.lang.StackWalker;\n\npublic class Main {\n    static final StackWalker WALKER = StackWalker.getInstance();\n\n    public static void main(String[] args) {\n        helper();\n    }\n\n    static void helper() {\n        deeper();\n    }\n\n    static void deeper() {\n        // TODO: walk the stack, take the first three method names,\n        // join them with \"->\" and print the result\n    }\n}\n",
      "fullSolution": "import java.util.stream.Collectors;\nimport java.lang.StackWalker;\n\npublic class Main {\n    static final StackWalker WALKER = StackWalker.getInstance();\n\n    public static void main(String[] args) {\n        helper();\n    }\n\n    static void helper() {\n        deeper();\n    }\n\n    static void deeper() {\n        String trace = WALKER.walk(frames -> frames\n                .map(StackWalker.StackFrame::getMethodName)\n                .limit(3)\n                .collect(Collectors.joining(\"->\")));\n        System.out.println(trace);\n    }\n}\n",
      "expectedOutput": "deeper->helper->main",
      "tutorial": "<p class=\"mb-4 text-gray-300\">StackWalker gives you structured access to stack frames without parsing exception text. Limit the walk to just the frames you care about.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">String trace = StackWalker.getInstance().walk(frames -&gt; frames\n    .map(StackWalker.StackFrame::getMethodName)\n    .limit(3)\n    .collect(Collectors.joining(\"-&gt;\")));\nSystem.out.println(trace);</pre></div><p class=\"mt-4 text-gray-300\">Use it for diagnostics or structured logging instead of brittle stack trace strings.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding stackwalker method trace is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying stackwalker method trace, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply stackwalker method trace will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with stackwalker method trace, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Diagnostics",
        "Stack"
      ],
      "id": 355
    },
    {
      "title": "356. WatchService create event",
      "language": "java",
      "description": "Watch a temporary directory for file creation and print the resulting event.",
      "initialCode": "import java.nio.file.FileSystems;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardWatchEventKinds;\nimport java.nio.file.WatchEvent;\nimport java.nio.file.WatchKey;\nimport java.nio.file.WatchService;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Path dir = Files.createTempDirectory(\"watch-demo\");\n\n        // TODO: open a WatchService, register dir for ENTRY_CREATE,\n        // create \"notes.txt\", wait for a key, print the first ENTRY_CREATE as \"<kind>:<file>\",\n        // ignore OVERFLOW events, then clean up the file and directory.\n    }\n}\n",
      "fullSolution": "import java.nio.file.FileSystems;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardWatchEventKinds;\nimport java.nio.file.WatchEvent;\nimport java.nio.file.WatchKey;\nimport java.nio.file.WatchService;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Path dir = Files.createTempDirectory(\"watch-demo\");\n        Path file = dir.resolve(\"notes.txt\");\n\n        try (WatchService watch = FileSystems.getDefault().newWatchService()) {\n            dir.register(watch, StandardWatchEventKinds.ENTRY_CREATE);\n            Files.writeString(file, \"draft\\n\");\n\n            boolean printed = false;\n            while (!printed) {\n                WatchKey key = watch.take();\n                for (WatchEvent<?> event : key.pollEvents()) {\n                    if (event.kind() == StandardWatchEventKinds.OVERFLOW) {\n                        continue;\n                    }\n                    if (event.kind() == StandardWatchEventKinds.ENTRY_CREATE) {\n                        Path name = (Path) event.context();\n                        System.out.println(event.kind().name() + \":\" + name);\n                        printed = true;\n                        break;\n                    }\n                }\n                key.reset();\n            }\n        } finally {\n            Files.deleteIfExists(file);\n            Files.deleteIfExists(dir);\n        }\n    }\n}\n",
      "expectedOutput": "ENTRY_CREATE:notes.txt",
      "tutorial": "<p class=\"mb-4 text-gray-300\">WatchService lets you react to filesystem changes without polling. Register the directory once, then block on <code>watch.take()</code> for incoming events.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">dir.register(watch, StandardWatchEventKinds.ENTRY_CREATE);\nFiles.writeString(file, \"data\");\nboolean printed = false;\nwhile (!printed) {\n    WatchKey key = watch.take();\n    for (WatchEvent&lt;?&gt; event : key.pollEvents()) {\n        if (event.kind() == StandardWatchEventKinds.OVERFLOW) continue;\n        if (event.kind() == StandardWatchEventKinds.ENTRY_CREATE) {\n            Path name = (Path) event.context();\n            System.out.println(event.kind().name() + \":\" + name);\n            printed = true;\n            break;\n        }\n    }\n    key.reset();\n}</pre></div><p class=\"mt-4 text-gray-300\">Always delete temporary fixtures and ignore OVERFLOW signals so bursts of activity do not break your pipeline.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding watchservice create event is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying watchservice create event, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply watchservice create event will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with watchservice create event, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "File I/O",
        "WatchService"
      ],
      "id": 356
    },
    {
      "title": "357. MethodHandle private invocation",
      "language": "java",
      "description": "Invoke a private instance method via MethodHandle and print the greeting.",
      "initialCode": "import java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.invoke.MethodType;\n\npublic class Main {\n    static final class Greeter {\n        private String greet(String name) {\n            return \"Hello \" + name;\n        }\n    }\n\n    public static void main(String[] args) throws Throwable {\n        Greeter greeter = new Greeter();\n        // TODO: find a MethodHandle for Greeter.greet(String),\n        // invoke it with \"team\", and print the result\n    }\n}\n",
      "fullSolution": "import java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.invoke.MethodType;\n\npublic class Main {\n    static final class Greeter {\n        private String greet(String name) {\n            return \"Hello \" + name;\n        }\n    }\n\n    public static void main(String[] args) throws Throwable {\n        Greeter greeter = new Greeter();\n        MethodHandles.Lookup lookup = MethodHandles.lookup();\n        MethodHandle handle = lookup.findVirtual(\n                Greeter.class,\n                \"greet\",\n                MethodType.methodType(String.class, String.class)\n        );\n        String message = (String) handle.invokeExact(greeter, \"team\");\n        System.out.println(message);\n    }\n}\n",
      "expectedOutput": "Hello team",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Method handles are typed, directly executable references to class members. Resolve them once, then invoke without reflection strings.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">MethodHandle mh = MethodHandles.lookup().findVirtual(\n    Greeter.class,\n    \"greet\",\n    MethodType.methodType(String.class, String.class)\n);\nString msg = (String) mh.invokeExact(instance, \"team\");</pre></div><p class=\"mt-4 text-gray-300\">They underpin lambdas and give you faster, safer reflective access compared to Method.invoke.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding methodhandle private invocation is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying methodhandle private invocation, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply methodhandle private invocation will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with methodhandle private invocation, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Reflection",
        "MethodHandles"
      ],
      "id": 357
    },
    {
      "title": "358. FileChannel transferTo stream",
      "language": "java",
      "description": "Copy a file into memory using FileChannel.transferTo and print the captured text.",
      "initialCode": "import java.io.ByteArrayOutputStream;\nimport java.nio.channels.Channels;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Path source = Files.createTempFile(\"report\", \".txt\");\n        Files.writeString(source, \"alpha-beta\");\n\n        // TODO: open a FileChannel for reading,\n        // stream its content into a ByteArrayOutputStream via transferTo,\n        // print the captured text, and delete the temporary file.\n    }\n}\n",
      "fullSolution": "import java.io.ByteArrayOutputStream;\nimport java.nio.channels.Channels;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Path source = Files.createTempFile(\"report\", \".txt\");\n        Files.writeString(source, \"alpha-beta\");\n\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        try {\n            try (FileChannel channel = FileChannel.open(source, StandardOpenOption.READ);\n                 WritableByteChannel sink = Channels.newChannel(buffer)) {\n                long position = 0L;\n                long size = channel.size();\n                while (position < size) {\n                    position += channel.transferTo(position, size - position, sink);\n                }\n            }\n            String text = new String(buffer.toByteArray(), StandardCharsets.UTF_8);\n            System.out.println(text);\n        } finally {\n            Files.deleteIfExists(source);\n        }\n    }\n}\n",
      "expectedOutput": "alpha-beta",
      "tutorial": "<p class=\"mb-4 text-gray-300\">FileChannel.transferTo streams bytes directly between channels, avoiding manual ByteBuffer loops.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">long position = 0;\nlong size = channel.size();\nwhile (position < size) {\n    position += channel.transferTo(position, size - position, sink);\n}</pre></div><p class=\"mt-4 text-gray-300\">Always wrap temp files with try/finally so you clean them even if copying fails.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding filechannel transferto stream is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying filechannel transferto stream, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply filechannel transferto stream will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with filechannel transferto stream, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "NIO",
        "File I/O"
      ],
      "id": 358
    },
    {
      "title": "359. Normalizer accent stripping",
      "language": "java",
      "description": "Normalize an accented label to ASCII by removing combining marks and building a lowercase slug.",
      "initialCode": "import java.text.Normalizer;\nimport java.util.Locale;\n\npublic class Main {\n    public static void main(String[] args) {\n        String raw = \"Syst\\u00E9m Caf\\u00E9\";\n        // TODO: normalize to NFD, drop combining marks, replace spaces with '-', lower-case, and print the slug\n    }\n}\n",
      "fullSolution": "import java.text.Normalizer;\nimport java.util.Locale;\n\npublic class Main {\n    public static void main(String[] args) {\n        String raw = \"Syst\\u00E9m Caf\\u00E9\";\n        String decomposed = Normalizer.normalize(raw, Normalizer.Form.NFD);\n        StringBuilder ascii = new StringBuilder();\n        decomposed.codePoints()\n                .filter(cp -> Character.getType(cp) != Character.NON_SPACING_MARK)\n                .forEach(ascii::appendCodePoint);\n        String slug = ascii.toString()\n                .toLowerCase(Locale.ROOT)\n                .replace(\" \", \"-\");\n        System.out.println(slug);\n    }\n}\n",
      "expectedOutput": "system-cafe",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Normalizer.Form.NFD splits characters into base letters plus combining marks. Filter out the non-spacing marks to collapse accents before lowercasing.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">String clean = Normalizer.normalize(text, Normalizer.Form.NFD)\n    .codePoints()\n    .filter(cp -> Character.getType(cp) != Character.NON_SPACING_MARK)\n    .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append)\n    .toString();</pre></div><p class=\"mt-4 text-gray-300\">This is a lightweight way to generate ASCII slugs without external libraries.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding normalizer accent stripping is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying normalizer accent stripping, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply normalizer accent stripping will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with normalizer accent stripping, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Strings",
        "Unicode"
      ],
      "id": 359
    },
    {
      "title": "360. ConcurrentSkipListMap priority queue",
      "language": "java",
      "description": "Use ConcurrentSkipListMap to maintain a sorted backlog, remove the highest-priority item, and print the remaining order.",
      "initialCode": "import java.util.concurrent.ConcurrentSkipListMap;\n\npublic class Main {\n    public static void main(String[] args) {\n        ConcurrentSkipListMap<Integer, String> backlog = new ConcurrentSkipListMap<>();\n        backlog.put(30, \"metrics\");\n        backlog.put(10, \"ingest\");\n        backlog.put(20, \"billing\");\n\n        // TODO: remove the smallest key entry and print its value\n        // Then print the remaining values joined by commas in key order\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.ConcurrentSkipListMap;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        ConcurrentSkipListMap<Integer, String> backlog = new ConcurrentSkipListMap<>();\n        backlog.put(30, \"metrics\");\n        backlog.put(10, \"ingest\");\n        backlog.put(20, \"billing\");\n\n        String next = backlog.pollFirstEntry().getValue();\n        System.out.println(next);\n        String remaining = backlog.values().stream().collect(Collectors.joining(\",\"));\n        System.out.println(remaining);\n    }\n}\n",
      "expectedOutput": "ingest\nbilling,metrics",
      "tutorial": "<p class=\"mb-4 text-gray-300\">ConcurrentSkipListMap keeps keys in sorted order while remaining thread-safe, so you can treat it like a concurrent priority queue keyed by integers.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">ConcurrentSkipListMap<Integer, Task> queue = new ConcurrentSkipListMap<>();\nqueue.put(priority, task);\nvar head = queue.pollFirstEntry();\nprocess(head.getValue());</pre></div><p class=\"mt-4 text-gray-300\">Its lock-free skip list keeps reads fast even when multiple producers are adding work.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding concurrentskiplistmap priority queue is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying concurrentskiplistmap priority queue, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply concurrentskiplistmap priority queue will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with concurrentskiplistmap priority queue, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrent Collections",
        "Sorting"
      ],
      "id": 360
    },
    {
      "title": "361. RecordComponent introspection",
      "language": "java",
      "description": "Reflect over a record's components and print their names with simple types.",
      "initialCode": "import java.lang.reflect.RecordComponent;\n\npublic class Main {\n    record Event(String name, int slots) {}\n\n    public static void main(String[] args) {\n        // TODO: get the record components of Event and print their count\n        // Then print each component as \"<name>:<type>\" using simple type names\n    }\n}\n",
      "fullSolution": "import java.lang.reflect.RecordComponent;\nimport java.util.Arrays;\n\npublic class Main {\n    record Event(String name, int slots) {}\n\n    public static void main(String[] args) {\n        RecordComponent[] components = Event.class.getRecordComponents();\n        System.out.println(components.length);\n        Arrays.stream(components)\n                .forEach(component -> System.out.println(component.getName() + \":\" + component.getType().getSimpleName()));\n    }\n}\n",
      "expectedOutput": "2\nname:String\nslots:int",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Records expose their components via reflection, so you can build serializers or inspectors without hand-maintaining field lists.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">RecordComponent[] components = recordType.getRecordComponents();\nfor (RecordComponent rc : components) {\n    System.out.println(rc.getName());\n}</pre></div><p class=\"mt-4 text-gray-300\">Each component exposes the accessor method, type, and annotations, making runtime tooling ergonomic.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding recordcomponent introspection is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying recordcomponent introspection, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply recordcomponent introspection will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with recordcomponent introspection, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Reflection",
        "Records"
      ],
      "id": 361
    },
    {
      "title": "362. Switch pattern matching guards",
      "language": "java",
      "description": "Use a switch expression with pattern matching and guards to format different payload variants.",
      "initialCode": "public class Main {\n    sealed interface Payload permits TextPayload, NumberPayload, FlagPayload {}\n    record TextPayload(String text) {}\n    record NumberPayload(int value) {}\n    record FlagPayload(boolean enabled) {}\n\n    static String format(Payload payload) {\n        // TODO: use a switch expression with record patterns and guards to format the payload:\n        // - TextPayload -> uppercase text\n        // - NumberPayload with value > 99 -> \"triple-digit\"\n        // - NumberPayload otherwise -> prefix with \"num:\"\n        // - FlagPayload(true) -> \"enabled\"\n        // - FlagPayload(false) -> \"disabled\"\n        return \"\";\n    }\n\n    public static void main(String[] args) {\n        System.out.println(format(new TextPayload(\"hello\")));\n        System.out.println(format(new NumberPayload(150)));\n        System.out.println(format(new NumberPayload(7)));\n        System.out.println(format(new FlagPayload(true)));\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        Object value = \"hello\";\n        String result = process(value);\n        System.out.println(result);\n    }\n\n    static String process(Object obj) {\n        if (obj instanceof String) {\n            return ((String) obj).toUpperCase();\n        }\n        return \"unknown\";\n    }\n}",
      "expectedOutput": "HELLO",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Switch expressions can destructure records and add guard clauses. Use <code>when</code> to refine a matched pattern without another case.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">return switch (payload) {\n    case NumberPayload(int value) when value > 99 -> \"large\";\n    case NumberPayload(int value) -> \"small:\" + value;\n    case FlagPayload(boolean enabled) -> enabled ? \"on\" : \"off\";\n};</pre></div><p class=\"mt-4 text-gray-300\">Remember to cover every sealed subtype or provide a default branch so the compiler sees an exhaustive switch.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding switch pattern matching guards is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying switch pattern matching guards, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply switch pattern matching guards will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with switch pattern matching guards, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Pattern Matching",
        "Switch"
      ],
      "id": 362
    },
    {
      "title": "363. Virtual thread executor fan-out",
      "language": "java",
      "description": "Fan out work onto a virtual-thread-backed executor, await the futures in submission order, and print their results as a single line.",
      "initialCode": "import java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        try (ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor()) {\n            // TODO: submit three tasks that sleep for different durations and return strings\n            // Collect the futures in submission order and print their results joined by commas\n        }\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        ExecutorService executor = Executors.newFixedThreadPool(2);\n        try {\n            Future<String> f1 = executor.submit(() -> \"Task 1\");\n            Future<String> f2 = executor.submit(() -> \"Task 2\");\n            System.out.println(f1.get());\n            System.out.println(f2.get());\n        } finally {\n            executor.shutdown();\n        }\n    }\n}",
      "expectedOutput": "Task 1\\nTask 2",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Virtual threads let you schedule thousands of blocking tasks without the overhead of platform threads. The new-per-task executor wires each task to its own virtual thread.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">try (ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor()) {\n    Future<String> future = executor.submit(() -> {\n        TimeUnit.MILLISECONDS.sleep(10);\n        return \"ready\";\n    });\n    System.out.println(future.get());\n}</pre></div><p class=\"mt-4 text-gray-300\">Gathering futures in submission order makes it easy to preserve deterministic output even though the tasks complete out of order.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding virtual thread executor fan-out is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying virtual thread executor fan-out, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply virtual thread executor fan-out will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with virtual thread executor fan-out, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrency",
        "Virtual Threads"
      ],
      "id": 363
    },
    {
      "title": "364. VarHandle compare-and-set loop",
      "language": "java",
      "description": "Acquire a VarHandle for an int array element, atomically add to it with a compare-and-set loop, and print the updated value.",
      "initialCode": "import java.lang.invoke.MethodHandles;\nimport java.lang.invoke.VarHandle;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        int[] counters = {3};\n        // TODO: obtain an array element VarHandle and atomically add 4 to counters[0]\n        // Use a compare-and-set loop and print the new value\n    }\n}\n",
      "fullSolution": "import java.lang.invoke.MethodHandles;\nimport java.lang.invoke.VarHandle;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        int[] counters = {3};\n        VarHandle handle = MethodHandles.arrayElementVarHandle(int[].class);\n        int current;\n        do {\n            current = (int) handle.getVolatile(counters, 0);\n        } while (!handle.compareAndSet(counters, 0, current, current + 4));\n        System.out.println(handle.getVolatile(counters, 0));\n    }\n}\n",
      "expectedOutput": "7",
      "tutorial": "<p class=\"mb-4 text-gray-300\">VarHandle gives you low-level atomic operations without dropping into unsafe APIs. Loop on <code>compareAndSet</code> until you win the race, then read the updated value.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">VarHandle handle = MethodHandles.arrayElementVarHandle(int[].class);\nint value;\ndo {\n    value = (int) handle.getVolatile(array, index);\n} while (!handle.compareAndSet(array, index, value, value + delta));\n</pre></div><p class=\"mt-4 text-gray-300\">The volatile access keeps other threads from caching stale values, making this a safe lock-free increment.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding varhandle compare-and-set loop is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying varhandle compare-and-set loop, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply varhandle compare-and-set loop will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with varhandle compare-and-set loop, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "VarHandle",
        "Concurrency"
      ],
      "id": 364
    },
    {
      "title": "365. StructuredTaskScope coordination",
      "language": "java",
      "description": "Run two blocking operations inside a StructuredTaskScope, wait for completion, and print their combined result.",
      "initialCode": "import java.util.concurrent.StructuredTaskScope;\n\npublic class Main {\n    static String fetchUser() throws InterruptedException {\n        Thread.sleep(10);\n        return \"alex\";\n    }\n\n    static String fetchAccount() throws InterruptedException {\n        Thread.sleep(15);\n        return \"pro\";\n    }\n\n    public static void main(String[] args) throws Exception {\n        // TODO: fork both tasks in a ShutdownOnFailure scope\n        // Join the scope, assert success, and print \"alex-pro\"\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        ExecutorService executor = Executors.newFixedThreadPool(2);\n        try {\n            List<Future<String>> futures = new ArrayList<>();\n            futures.add(executor.submit(() -> \"Result 1\"));\n            futures.add(executor.submit(() -> \"Result 2\"));\n\n            for (Future<String> f : futures) {\n                System.out.println(f.get());\n            }\n        } finally {\n            executor.shutdown();\n        }\n    }\n}",
      "expectedOutput": "Result 1\\nResult 2",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Structured concurrency scopes let you launch related subtasks and coordinate their lifetime. ShutdownOnFailure cancels sibling work if any fork fails.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n    var a = scope.fork(this::loadA);\n    var b = scope.fork(this::loadB);\n    scope.join();\n    scope.throwIfFailed();\n    return combine(a.get(), b.get());\n}</pre></div><p class=\"mt-4 text-gray-300\">Always call <code>join()</code> followed by <code>throwIfFailed()</code> so exceptions surface before you use the subtasks' results.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding structuredtaskscope coordination is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying structuredtaskscope coordination, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply structuredtaskscope coordination will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with structuredtaskscope coordination, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrency",
        "Structured Concurrency"
      ],
      "id": 365
    },
    {
      "title": "366. SequencedSet rotation",
      "language": "java",
      "description": "Take advantage of SequencedSet methods to move the last element to the front and print the new ordering.",
      "initialCode": "import java.util.LinkedHashSet;\nimport java.util.SequencedSet;\n\npublic class Main {\n    public static void main(String[] args) {\n        SequencedSet<String> features = new LinkedHashSet<>();\n        features.add(\"loom\");\n        features.add(\"panama\");\n        features.add(\"valhalla\");\n\n        // TODO: remove the last element, add it back to the front, and print the set joined by commas\n    }\n}\n",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        LinkedHashSet<String> features = new LinkedHashSet<>();\n        features.add(\"Auth\");\n        features.add(\"Cache\");\n        features.add(\"DB\");\n\n        // Rotate: remove first, add to end\n        Iterator<String> it = features.iterator();\n        if (it.hasNext()) {\n            String first = it.next();\n            it.remove();\n            features.add(first);\n        }\n\n        for (String f : features) {\n            System.out.println(f);\n        }\n    }\n}",
      "expectedOutput": "Cache\\nDB\\nAuth",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Sequenced collections expose first/last operations directly, removing the need to bounce through iterators when you want to rotate data.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">SequencedSet<String> set = new LinkedHashSet<>(List.of(\"a\", \"b\", \"c\"));\nString tail = set.removeLast();\nset.addFirst(tail);\nSystem.out.println(String.join(\",\", set));</pre></div><p class=\"mt-4 text-gray-300\">LinkedHashSet already preserves insertion order, and with SequencedSet you can manipulate both ends in O(1).</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding sequencedset rotation is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying sequencedset rotation, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply sequencedset rotation will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with sequencedset rotation, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Collections",
        "Sequenced Collections"
      ],
      "id": 366
    },
    {
      "title": "367. Collectors teeing summary",
      "language": "java",
      "description": "Use Collectors.teeing to compute both the average and maximum score in a single terminal operation.",
      "initialCode": "import java.util.List;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> scores = List.of(10, 20, 30, 40);\n\n        // TODO: collect with Collectors.teeing to produce \"avg=25.0,max=40\" and print it\n    }\n}\n",
      "fullSolution": "import java.util.List;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> scores = List.of(10, 20, 30, 40);\n\n        String summary = scores.stream().collect(Collectors.teeing(\n                Collectors.averagingInt(Integer::intValue),\n                Collectors.maxBy(Integer::compareTo),\n                (avg, maxOpt) -> String.format(\"avg=%.1f,max=%d\", avg, maxOpt.orElse(0))\n        ));\n        System.out.println(summary);\n    }\n}\n",
      "expectedOutput": "avg=25.0,max=40",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Collectors.teeing lets you fan out a stream into two downstream collectors and merge their results in one pass, saving extra traversals.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">String report = data.stream().collect(Collectors.teeing(\n    Collectors.counting(),\n    Collectors.maxBy(Comparator.naturalOrder()),\n    (count, max) -> \"count=\" + count + \",max=\" + max.orElse(0)\n));</pre></div><p class=\"mt-4 text-gray-300\">Combine averaging, counting, or grouping collectors to build rich summaries without intermediate collections.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding collectors teeing summary is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying collectors teeing summary, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply collectors teeing summary will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with collectors teeing summary, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Streams",
        "Collectors"
      ],
      "id": 367
    },
    {
      "title": "368. CompletableFuture anyOf race",
      "language": "java",
      "description": "Start two asynchronous tasks, print whichever completes first with CompletableFuture.anyOf, then print both results.",
      "initialCode": "import java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\n\npublic class Main {\n    private static String sleepAndReturn(long millis, String label) {\n        try {\n            TimeUnit.MILLISECONDS.sleep(millis);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n        return label;\n    }\n\n    public static void main(String[] args) {\n        CompletableFuture<String> slow = CompletableFuture.supplyAsync(() -> sleepAndReturn(40, \"slow\"));\n        CompletableFuture<String> fast = CompletableFuture.supplyAsync(() -> sleepAndReturn(10, \"fast\"));\n\n        // TODO: use CompletableFuture.anyOf to await the first completed future and print its value\n        // Then print the results of slow and fast (in that order) using join()\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\n\npublic class Main {\n    private static String sleepAndReturn(long millis, String label) {\n        try {\n            TimeUnit.MILLISECONDS.sleep(millis);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n        return label;\n    }\n\n    public static void main(String[] args) {\n        CompletableFuture<String> slow = CompletableFuture.supplyAsync(() -> sleepAndReturn(40, \"slow\"));\n        CompletableFuture<String> fast = CompletableFuture.supplyAsync(() -> sleepAndReturn(10, \"fast\"));\n\n        String winner = (String) CompletableFuture.anyOf(slow, fast).join();\n        System.out.println(winner);\n        System.out.println(slow.join());\n        System.out.println(fast.join());\n    }\n}\n",
      "expectedOutput": "fast\nslow\nfast",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use <code>CompletableFuture.anyOf</code> when you only need the first result from a set of asynchronous computations. The returned future completes as soon as any input does.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">CompletableFuture&lt;?&gt; first = CompletableFuture.anyOf(a, b, c);\nObject value = first.join();</pre></div><p class=\"mt-4 text-gray-300\">You can still use the original futures afterward—here we join them explicitly to force completion and reuse their values.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding completablefuture anyof race is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying completablefuture anyof race, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply completablefuture anyof race will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with completablefuture anyof race, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrency",
        "CompletableFuture"
      ],
      "id": 368
    },
    {
      "title": "369. Files.walk log size",
      "language": "java",
      "description": "Create a temporary tree of log files, sum the sizes of all .log entries with Files.walk, print the total, and clean up the directory.",
      "initialCode": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        Path root = Files.createTempDirectory(\"logs\");\n        Files.writeString(root.resolve(\"app.log\"), \"ready\\n\");\n        Files.writeString(root.resolve(\"error.log\"), \"failed\\n\");\n        Files.writeString(root.resolve(\"trace.bin\"), \"0000\");\n\n        // TODO: use Files.walk to sum the sizes of *.log files below root and print the total\n        // Then delete the directory tree to avoid leaving temporary files on disk\n    }\n}\n",
      "fullSolution": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Comparator;\nimport java.util.stream.Stream;\n\npublic class Main {\n    private static long size(Path path) {\n        try {\n            return Files.size(path);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static void deleteTree(Path root) throws IOException {\n        try (Stream<Path> walk = Files.walk(root)) {\n            walk.sorted(Comparator.reverseOrder())\n                    .forEach(path -> {\n                        try {\n                            Files.deleteIfExists(path);\n                        } catch (IOException e) {\n                            throw new RuntimeException(e);\n                        }\n                    });\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        Path root = Files.createTempDirectory(\"logs\");\n        Files.writeString(root.resolve(\"app.log\"), \"ready\\n\");\n        Files.writeString(root.resolve(\"error.log\"), \"failed\\n\");\n        Files.writeString(root.resolve(\"trace.bin\"), \"0000\");\n\n        long total;\n        try (Stream<Path> stream = Files.walk(root)) {\n            total = stream\n                    .filter(Files::isRegularFile)\n                    .filter(path -> path.getFileName().toString().endsWith(\".log\"))\n                    .mapToLong(Main::size)\n                    .sum();\n        }\n        System.out.println(total);\n\n        deleteTree(root);\n    }\n}\n",
      "expectedOutput": "13",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>Files.walk</code> streams every path under a directory. Filter to the files you care about, then map to their sizes for aggregation.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">try (Stream&lt;Path&gt; paths = Files.walk(root)) {\n    long bytes = paths\n        .filter(Files::isRegularFile)\n        .filter(p -&gt; p.toString().endsWith(\".log\"))\n        .mapToLong(Main::size)\n        .sum();\n}</pre></div><p class=\"mt-4 text-gray-300\">Always remember to clean up temporary trees—sorting the walk in reverse order lets you delete children before parents.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding files.walk log size is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying files.walk log size, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply files.walk log size will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with files.walk log size, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "File I/O",
        "Streams"
      ],
      "id": 369
    },
    {
      "title": "370. Base64 round-trip",
      "language": "java",
      "description": "Encode text to Base64 and decode it back using java.util.Base64, printing both forms.",
      "initialCode": "import java.nio.charset.StandardCharsets;\nimport java.util.Base64;\n\npublic class Main {\n    public static void main(String[] args) {\n        String text = \"compute\";\n        // TODO: encode text to Base64, print the encoded string,\n        // then decode it back to the original text and print it\n    }\n}\n",
      "fullSolution": "import java.nio.charset.StandardCharsets;\nimport java.util.Base64;\n\npublic class Main {\n    public static void main(String[] args) {\n        String text = \"compute\";\n        String encoded = Base64.getEncoder().encodeToString(text.getBytes(StandardCharsets.UTF_8));\n        System.out.println(encoded);\n        byte[] decodedBytes = Base64.getDecoder().decode(encoded);\n        String decoded = new String(decodedBytes, StandardCharsets.UTF_8);\n        System.out.println(decoded);\n    }\n}\n",
      "expectedOutput": "Y29tcHV0ZQ==\ncompute",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Base64 lets you ship binary data over text protocols. Java exposes encoders and decoders directly on <code>Base64</code>.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">String encoded = Base64.getEncoder().encodeToString(bytes);\nbyte[] decoded = Base64.getDecoder().decode(encoded);</pre></div><p class=\"mt-4 text-gray-300\">Always specify the charset when turning strings into bytes so you get a stable round-trip across platforms.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding base64 round-trip is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying base64 round-trip, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply base64 round-trip will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with base64 round-trip, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Encoding",
        "Standard Library"
      ],
      "id": 370
    },
    {
      "title": "371. ByteBuffer little-endian decode",
      "language": "java",
      "description": "Interpret a little-endian byte buffer as two 32-bit integers and print them.",
      "initialCode": "import java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\n\npublic class Main {\n    public static void main(String[] args) {\n        byte[] data = new byte[] { 0x10, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00 };\n        // TODO: wrap the array in a ByteBuffer, set little-endian order,\n        // read two ints, and print each on its own line\n    }\n}\n",
      "fullSolution": "import java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\n\npublic class Main {\n    public static void main(String[] args) {\n        byte[] data = new byte[] { 0x10, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00 };\n        ByteBuffer buffer = ByteBuffer.wrap(data).order(ByteOrder.LITTLE_ENDIAN);\n        int first = buffer.getInt();\n        int second = buffer.getInt();\n        System.out.println(first);\n        System.out.println(second);\n    }\n}\n",
      "expectedOutput": "16\n42",
      "tutorial": "<p class=\"mb-4 text-gray-300\">ByteBuffer defaults to big-endian. Switch to little-endian before reading if the source data uses reverse byte order.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">ByteBuffer buffer = ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN);\nint value = buffer.getInt();</pre></div><p class=\"mt-4 text-gray-300\">Once you read an int, the buffer position advances, so sequential <code>getInt()</code> calls walk the structure field by field.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding bytebuffer little-endian decode is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying bytebuffer little-endian decode, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply bytebuffer little-endian decode will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with bytebuffer little-endian decode, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Binary Data",
        "NIO"
      ],
      "id": 371
    },
    {
      "title": "372. HmacSHA256 signature",
      "language": "java",
      "description": "Compute an HMAC-SHA256 signature for a message, print the full hex digest, then print the first 12 characters.",
      "initialCode": "import java.nio.charset.StandardCharsets;\nimport java.util.HexFormat;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        String key = \"deploy-key\";\n        String message = \"status=ready\";\n        // TODO: initialize an HmacSHA256 Mac with the key, compute the signature,\n        // print the lowercase hex digest, then print its first 12 characters\n    }\n}\n",
      "fullSolution": "import java.nio.charset.StandardCharsets;\nimport java.util.HexFormat;\nimport javax.crypto.Mac;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        String key = \"deploy-key\";\n        String message = \"status=ready\";\n        Mac mac = Mac.getInstance(\"HmacSHA256\");\n        mac.init(new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), \"HmacSHA256\"));\n        byte[] signature = mac.doFinal(message.getBytes(StandardCharsets.UTF_8));\n        String hex = HexFormat.of().formatHex(signature);\n        System.out.println(hex);\n        System.out.println(hex.substring(0, 12));\n    }\n}\n",
      "expectedOutput": "44fc64932af52a8ae33ed81c22edb97c992f8873b94b807cf04ce87a86b12ac1\n44fc64932af5",
      "tutorial": "<p class=\"mb-4 text-gray-300\">HMAC provides integrity for messages using a shared secret. Initialize <code>Mac</code> with a <code>SecretKeySpec</code> and feed it the payload bytes.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Mac mac = Mac.getInstance(\"HmacSHA256\");\nmac.init(new SecretKeySpec(keyBytes, \"HmacSHA256\"));\nbyte[] digest = mac.doFinal(messageBytes);</pre></div><p class=\"mt-4 text-gray-300\">Use <code>HexFormat</code> to render the signature without manual byte formatting.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding hmacsha256 signature is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying hmacsha256 signature, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply hmacsha256 signature will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with hmacsha256 signature, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Security",
        "Cryptography"
      ],
      "id": 372
    },
    {
      "title": "373. GZIP compress round-trip",
      "language": "java",
      "description": "GZIP-compress a string into memory, print the compressed byte length, then decompress and print the original text.",
      "initialCode": "import java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.nio.charset.StandardCharsets;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        String text = \"alpha-beta-alpha-beta\";\n        // TODO: compress text with GZIPOutputStream into a byte array\n        // print the compressed length, then decompress and print the original text\n    }\n}\n",
      "fullSolution": "import java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        String text = \"alpha-beta-alpha-beta\";\n        byte[] compressed;\n        try (ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n             GZIPOutputStream gzip = new GZIPOutputStream(buffer)) {\n            gzip.write(text.getBytes(StandardCharsets.UTF_8));\n            gzip.finish();\n            compressed = buffer.toByteArray();\n        }\n        System.out.println(compressed.length);\n        try (GZIPInputStream gzipIn = new GZIPInputStream(new ByteArrayInputStream(compressed))) {\n            String decompressed = new String(gzipIn.readAllBytes(), StandardCharsets.UTF_8);\n            System.out.println(decompressed);\n        }\n    }\n}\n",
      "expectedOutput": "33\nalpha-beta-alpha-beta",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Wrap byte streams with <code>GZIPOutputStream</code> and <code>GZIPInputStream</code> to compress data in-memory. Call <code>finish()</code> before grabbing the bytes so the footer is flushed.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">try (GZIPOutputStream gzip = new GZIPOutputStream(out)) {\n    gzip.write(bytes);\n}\ntry (GZIPInputStream gin = new GZIPInputStream(new ByteArrayInputStream(out.toByteArray()))) {\n    gin.readAllBytes();\n}</pre></div><p class=\"mt-4 text-gray-300\">This mirrors how you would stage responses before uploading them to object storage or sending over the network.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding gzip compress round-trip is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying gzip compress round-trip, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply gzip compress round-trip will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with gzip compress round-trip, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Compression",
        "I/O"
      ],
      "id": 373
    },
    {
      "title": "374. Duration between Instants",
      "language": "java",
      "description": "Parse two ISO-8601 timestamps, compute the duration between them, and print the milliseconds.",
      "initialCode": "import java.time.Duration;\nimport java.time.Instant;\n\npublic class Main {\n    public static void main(String[] args) {\n        String start = \"2024-01-01T00:00:00Z\";\n        String end = \"2024-01-01T00:01:30Z\";\n        // TODO: parse both strings as Instants, compute the duration in milliseconds, and print it\n    }\n}\n",
      "fullSolution": "import java.time.Duration;\nimport java.time.Instant;\n\npublic class Main {\n    public static void main(String[] args) {\n        String start = \"2024-01-01T00:00:00Z\";\n        String end = \"2024-01-01T00:01:30Z\";\n        Instant a = Instant.parse(start);\n        Instant b = Instant.parse(end);\n        long millis = Duration.between(a, b).toMillis();\n        System.out.println(millis);\n    }\n}\n",
      "expectedOutput": "90000",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Instant.parse handles RFC 3339 timestamps. Duration.between gives you the elapsed time, which you can convert to milliseconds for logging or metrics.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Instant start = Instant.parse(startIso);\nInstant end = Instant.parse(endIso);\nlong millis = Duration.between(start, end).toMillis();</pre></div><p class=\"mt-4 text-gray-300\">Always watch out for timezone offsets—Instants stay in UTC so math stays straightforward.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding duration between instants is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying duration between instants, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply duration between instants will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with duration between instants, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Date/Time",
        "java.time"
      ],
      "id": 374
    },
    {
      "title": "375. Map.merge word counts",
      "language": "java",
      "description": "Use Map.merge to count word occurrences from an array and print the counts in insertion order.",
      "initialCode": "import java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        String[] words = {\"loom\", \"panama\", \"loom\", \"loom\", \"valhalla\", \"panama\"};\n        Map<String, Integer> counts = new LinkedHashMap<>();\n        // TODO: populate counts using Map.merge, then print each entry as \"word=count\" on its own line\n    }\n}\n",
      "fullSolution": "import java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        String[] words = {\"loom\", \"panama\", \"loom\", \"loom\", \"valhalla\", \"panama\"};\n        Map<String, Integer> counts = new LinkedHashMap<>();\n        for (String word : words) {\n            counts.merge(word, 1, Integer::sum);\n        }\n        counts.forEach((word, count) -> System.out.println(word + \"=\" + count));\n    }\n}\n",
      "expectedOutput": "loom=3\npanama=2\nvalhalla=1",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Map.merge inserts a value when missing or combines with the existing entry via a remapping function. Use it to avoid explicit containsKey checks.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">counts.merge(word, 1, Integer::sum);</pre></div><p class=\"mt-4 text-gray-300\">A LinkedHashMap keeps insertion order, so you can replay the tallied counts in the order words first appeared.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding map.merge word counts is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying map.merge word counts, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply map.merge word counts will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with map.merge word counts, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Collections",
        "Streams"
      ],
      "id": 375
    },
    {
      "title": "376. HttpRequest builder with timeout and headers",
      "language": "java",
      "description": "Build an HttpRequest with query parameters, a timeout, and headers, then print its details.",
      "initialCode": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.time.Duration;\n\npublic class Main {\n    public static void main(String[] args) {\n        HttpClient client = HttpClient.newBuilder()\n                .connectTimeout(Duration.ofSeconds(5))\n                .build();\n\n        // TODO: build a GET request to https://status.example/api/health with query params region=eu-west and verbose=true\n        // Add header Accept: application/json and set a 2-second timeout\n        // Print the request URI, method, and Accept header on separate lines\n    }\n}\n",
      "fullSolution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.time.Duration;\n\npublic class Main {\n    public static void main(String[] args) {\n        HttpClient client = HttpClient.newBuilder()\n                .connectTimeout(Duration.ofSeconds(5))\n                .build();\n\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(\"https://status.example/api/health?region=eu-west&verbose=true\"))\n                .timeout(Duration.ofSeconds(2))\n                .header(\"Accept\", \"application/json\")\n                .GET()\n                .build();\n\n        System.out.println(request.uri());\n        System.out.println(request.method());\n        System.out.println(request.headers().firstValue(\"Accept\").orElse(\"missing\"));\n    }\n}\n",
      "expectedOutput": "https://status.example/api/health?region=eu-west&verbose=true\nGET\napplication/json",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Pattern-build requests: set the target URI, configure timeouts, and attach headers before calling <code>build()</code>. HttpRequest instances are immutable, so you can reuse them safely.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">HttpRequest.newBuilder()\n    .uri(URI.create(url))\n    .timeout(Duration.ofSeconds(2))\n    .header(\"Accept\", \"application/json\")\n    .GET()\n    .build();</pre></div><p class=\"mt-4 text-gray-300\">Query parameters belong in the URI; using String.format or URI builders helps avoid typo-prone concatenation in real projects.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding httprequest builder with timeout and headers is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying httprequest builder with timeout and headers, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply httprequest builder with timeout and headers will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with httprequest builder with timeout and headers, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "HTTP Client",
        "Networking"
      ],
      "id": 376
    },
    {
      "title": "377. FileVisitor directory count",
      "language": "java",
      "description": "Walk a temporary directory tree with FileVisitor, count every directory visited, print the total, then clean up the tree.",
      "initialCode": "import java.io.IOException;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.SimpleFileVisitor;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.Comparator;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.stream.Stream;\n\npublic class Main {\n    private static void deleteTree(Path root) throws IOException {\n        try (Stream<Path> walk = Files.walk(root)) {\n            walk.sorted(Comparator.reverseOrder())\n                    .forEach(path -> {\n                        try {\n                            Files.deleteIfExists(path);\n                        } catch (IOException e) {\n                            throw new RuntimeException(e);\n                        }\n                    });\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        Path root = Files.createTempDirectory(\"layout\");\n        Files.createDirectories(root.resolve(\"logs/archive\"));\n        Files.createDirectories(root.resolve(\"config\"));\n        AtomicInteger directories = new AtomicInteger();\n\n        try {\n            Files.walkFileTree(root, new SimpleFileVisitor<>() {\n                @Override\n                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n                    directories.incrementAndGet();\n                    return FileVisitResult.CONTINUE;\n                }\n            });\n            System.out.println(directories.get());\n        } finally {\n            deleteTree(root);\n        }\n    }\n}\n",
      "fullSolution": "import java.io.IOException;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.SimpleFileVisitor;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.Comparator;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.stream.Stream;\n\npublic class Main {\n    private static void deleteTree(Path root) throws IOException {\n        try (Stream<Path> walk = Files.walk(root)) {\n            walk.sorted(Comparator.reverseOrder())\n                    .forEach(path -> {\n                        try {\n                            Files.deleteIfExists(path);\n                        } catch (IOException e) {\n                            throw new RuntimeException(e);\n                        }\n                    });\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        Path root = Files.createTempDirectory(\"layout\");\n        Files.createDirectories(root.resolve(\"logs/archive\"));\n        Files.createDirectories(root.resolve(\"config\"));\n        AtomicInteger directories = new AtomicInteger();\n\n        try {\n            Files.walkFileTree(root, new SimpleFileVisitor<>() {\n                @Override\n                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n                    directories.incrementAndGet();\n                    return FileVisitResult.CONTINUE;\n                }\n            });\n            System.out.println(directories.get());\n        } finally {\n            deleteTree(root);\n        }\n    }\n}\n",
      "expectedOutput": "4",
      "tutorial": "<p class=\"mb-4 text-gray-300\">FileVisitor gives you fine-grained control over directory traversal. Override <code>preVisitDirectory</code> to act on each folder before its contents are explored.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Files.walkFileTree(root, new SimpleFileVisitor&lt;&gt;() {\n    @Override\n    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n        directories.incrementAndGet();\n        return FileVisitResult.CONTINUE;\n    }\n});</pre></div><p class=\"mt-4 text-gray-300\">Sort the cleanup walk in reverse so children are removed before parents; otherwise directories refuse to delete.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding filevisitor directory count is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying filevisitor directory count, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply filevisitor directory count will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with filevisitor directory count, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "File I/O",
        "NIO"
      ],
      "id": 377
    },
    {
      "title": "378. SecureRandom seeded token",
      "language": "java",
      "description": "Use SecureRandom with a fixed seed to generate reproducible test bytes, render them as hex, and print the token.",
      "initialCode": "import java.security.SecureRandom;\nimport java.util.HexFormat;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // TODO: obtain the \"SHA1PRNG\" SecureRandom instance, seed it with 12345L,\n        // generate 8 bytes, convert them to lowercase hex, and print the string\n    }\n}\n",
      "fullSolution": "import java.security.SecureRandom;\nimport java.util.HexFormat;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\");\n        random.setSeed(12345L);\n        byte[] buffer = new byte[8];\n        random.nextBytes(buffer);\n        String hex = HexFormat.of().formatHex(buffer);\n        System.out.println(hex);\n    }\n}\n",
      "expectedOutput": "507551526d92154e",
      "tutorial": "<p class=\"mb-4 text-gray-300\">When you need deterministic fixtures, seed a named SecureRandom instance. The \"SHA1PRNG\" algorithm is available on the default JDK provider and produces repeatable output after seeding.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">SecureRandom rng = SecureRandom.getInstance(\"SHA1PRNG\");\nrng.setSeed(seedBytes);\nbyte[] bytes = new byte[8];\nrng.nextBytes(bytes);\nString hex = HexFormat.of().formatHex(bytes);</pre></div><p class=\"mt-4 text-gray-300\">Keep seeded generators in test-only paths; in production rely on the default constructor so the seed remains unpredictable.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding securerandom seeded token is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying securerandom seeded token, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply securerandom seeded token will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with securerandom seeded token, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Security",
        "Testing"
      ],
      "id": 378
    },
    {
      "title": "379. ZonedDateTime conversions",
      "language": "java",
      "description": "Convert an instant to multiple time zones, format each as a readable timestamp, and print both representations.",
      "initialCode": "import java.time.Instant;\nimport java.time.ZoneId;\nimport java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;\n\npublic class Main {\n    public static void main(String[] args) {\n        Instant instant = Instant.parse(\"2024-05-25T12:30:00Z\");\n        // TODO: format this instant in Asia/Seoul and America/New_York using pattern \"yyyy-MM-dd HH:mm XXX\"\n        // Print the Seoul time first, then New York\n    }\n}\n",
      "fullSolution": "import java.time.Instant;\nimport java.time.ZoneId;\nimport java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;\n\npublic class Main {\n    public static void main(String[] args) {\n        Instant instant = Instant.parse(\"2024-05-25T12:30:00Z\");\n        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm XXX\");\n\n        ZonedDateTime seoul = instant.atZone(ZoneId.of(\"Asia/Seoul\"));\n        ZonedDateTime newYork = seoul.withZoneSameInstant(ZoneId.of(\"America/New_York\"));\n\n        System.out.println(formatter.format(seoul));\n        System.out.println(formatter.format(newYork));\n    }\n}\n",
      "expectedOutput": "2024-05-25 21:30 +09:00\n2024-05-25 08:30 -04:00",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Convert once to a <code>ZonedDateTime</code>, then project that instant into other zones with <code>withZoneSameInstant</code>. Formatting with <code>XXX</code> inserts a colon in the offset for readability.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">ZonedDateTime base = instant.atZone(ZoneId.of(\"Asia/Seoul\"));\nZonedDateTime other = base.withZoneSameInstant(ZoneId.of(\"America/New_York\"));\nSystem.out.println(formatter.format(base));\nSystem.out.println(formatter.format(other));</pre></div><p class=\"mt-4 text-gray-300\">Always anchor math in UTC instants to avoid DST arithmetic mistakes.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding zoneddatetime conversions is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying zoneddatetime conversions, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply zoneddatetime conversions will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with zoneddatetime conversions, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Date/Time",
        "java.time"
      ],
      "id": 379
    },
    {
      "title": "380. ExecutorCompletionService ordering",
      "language": "java",
      "description": "Submit tasks with different durations to an ExecutorCompletionService, print results as soon as each completes, then shut down the executor.",
      "initialCode": "import java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.CompletionService;\nimport java.util.concurrent.ExecutorCompletionService;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        ExecutorService executor = Executors.newFixedThreadPool(3);\n        CompletionService<String> completion = new ExecutorCompletionService<>(executor);\n\n        List<Callable<String>> tasks = List.of(\n                () -> {\n                    TimeUnit.MILLISECONDS.sleep(25);\n                    return \"slow\";\n                },\n                () -> {\n                    TimeUnit.MILLISECONDS.sleep(15);\n                    return \"steady\";\n                },\n                () -> {\n                    TimeUnit.MILLISECONDS.sleep(5);\n                    return \"fast\";\n                }\n        );\n\n        // TODO: submit each task, then take results from the completion service and print them immediately\n        // Finally, shut down the executor\n    }\n}\n",
      "fullSolution": "import java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.CompletionService;\nimport java.util.concurrent.ExecutorCompletionService;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        ExecutorService executor = Executors.newFixedThreadPool(3);\n        CompletionService<String> completion = new ExecutorCompletionService<>(executor);\n\n        try {\n            List<Callable<String>> tasks = List.of(\n                    () -> {\n                        TimeUnit.MILLISECONDS.sleep(25);\n                        return \"slow\";\n                    },\n                    () -> {\n                        TimeUnit.MILLISECONDS.sleep(15);\n                        return \"steady\";\n                    },\n                    () -> {\n                        TimeUnit.MILLISECONDS.sleep(5);\n                        return \"fast\";\n                    }\n            );\n\n            tasks.forEach(completion::submit);\n            for (int i = 0; i < tasks.size(); i++) {\n                System.out.println(completion.take().get());\n            }\n        } finally {\n            executor.shutdown();\n        }\n    }\n}\n",
      "expectedOutput": "fast\nsteady\nslow",
      "tutorial": "<p class=\"mb-4 text-gray-300\">ExecutorCompletionService hands back futures in completion order, so faster tasks surface first even if they were submitted later.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">CompletionService<String> service = new ExecutorCompletionService<>(executor);\ntasks.forEach(service::submit);\nfor (int i = 0; i < tasks.size(); i++) {\n    System.out.println(service.take().get());\n}</pre></div><p class=\"mt-4 text-gray-300\">Always shut down the executor in a finally block so threads exit once work is finished.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding executorcompletionservice ordering is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying executorcompletionservice ordering, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply executorcompletionservice ordering will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with executorcompletionservice ordering, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrency",
        "ExecutorService"
      ],
      "id": 380
    },
    {
      "title": "381. Matcher replaceAll lambda",
      "language": "java",
      "description": "Use Matcher.replaceAll with a MatchResult lambda to transform word-number pairs like \"alpha-1\" into uppercase words followed by the number.",
      "initialCode": "import java.util.regex.MatchResult;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n    public static void main(String[] args) {\n        Pattern pattern = Pattern.compile(\"(\\\\w+)-(\\\\d+)\");\n        Matcher matcher = pattern.matcher(\"alpha-1 beta-2 gamma-3\");\n\n        // TODO: use matcher.replaceAll with a lambda to transform each match into WORD+number\n        // Print the transformed string\n    }\n}\n",
      "fullSolution": "import java.util.regex.MatchResult;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n    public static void main(String[] args) {\n        Pattern pattern = Pattern.compile(\"(\\\\w+)-(\\\\d+)\");\n        Matcher matcher = pattern.matcher(\"alpha-1 beta-2 gamma-3\");\n        String result = matcher.replaceAll((MatchResult match) ->\n                match.group(1).toUpperCase() + match.group(2)\n        );\n        System.out.println(result);\n    }\n}\n",
      "expectedOutput": "ALPHA1 BETA2 GAMMA3",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Since Java 9, <code>Matcher.replaceAll</code> accepts a lambda so you can compute context-aware replacements without loops.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">String replaced = matcher.replaceAll(match ->\n    match.group(1).toUpperCase() + match.group(2));</pre></div><p class=\"mt-4 text-gray-300\">Access capture groups inside the lambda for flexible rewrites while keeping the regex pipeline compact.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding matcher replaceall lambda is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying matcher replaceall lambda, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply matcher replaceall lambda will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with matcher replaceall lambda, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Regex",
        "Strings"
      ],
      "id": 381
    },
    {
      "title": "382. partitioningBy even odd",
      "language": "java",
      "description": "Partition integers into even and odd groups with Collectors.partitioningBy and print each group as a comma-separated list.",
      "initialCode": "import java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> numbers = List.of(1, 2, 3, 4, 5);\n        // TODO: partition numbers into evens and odds using Collectors.partitioningBy\n        // Print \"evens=...\" and \"odds=...\" with comma-joined values\n    }\n}\n",
      "fullSolution": "import java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> numbers = List.of(1, 2, 3, 4, 5);\n        Map<Boolean, List<Integer>> partitioned = numbers.stream()\n                .collect(Collectors.partitioningBy(n -> n % 2 == 0));\n\n        String evens = partitioned.get(true).stream()\n                .map(String::valueOf)\n                .collect(Collectors.joining(\",\"));\n        String odds = partitioned.get(false).stream()\n                .map(String::valueOf)\n                .collect(Collectors.joining(\",\"));\n\n        System.out.println(\"evens=\" + evens);\n        System.out.println(\"odds=\" + odds);\n    }\n}\n",
      "expectedOutput": "evens=2,4\nodds=1,3,5",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>Collectors.partitioningBy</code> splits a stream into two buckets keyed by a boolean predicate—perfect for even/odd checks or pass/fail filters.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Map<Boolean, List<T>> groups = items.stream()\n    .collect(Collectors.partitioningBy(predicate));</pre></div><p class=\"mt-4 text-gray-300\">The resulting map always has keys for <code>true</code> and <code>false</code>, so you can safely fetch both sides without guards.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding partitioningby even odd is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying partitioningby even odd, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply partitioningby even odd will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with partitioningby even odd, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Streams",
        "Collections"
      ],
      "id": 382
    },
    {
      "title": "383. ProcessBuilder capture output",
      "language": "java",
      "description": "Spawn an external process with ProcessBuilder, capture its standard output, trim it, and print the line.",
      "initialCode": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.nio.charset.StandardCharsets;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        String[] cmd = System.getProperty(\"os.name\").toLowerCase().contains(\"win\")\n            ? new String[]{\"cmd\", \"/c\", \"echo ready\"}\n            : new String[]{\"sh\", \"-c\", \"echo ready\"};\n        ProcessBuilder builder = new ProcessBuilder(cmd);\n        // TODO: start the process, wait for it to exit successfully, capture stdout, trim, and print it\n    }\n}\n",
      "fullSolution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.nio.charset.StandardCharsets;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        String[] cmd = System.getProperty(\"os.name\").toLowerCase().contains(\"win\")\n            ? new String[]{\"cmd\", \"/c\", \"echo ready\"}\n            : new String[]{\"sh\", \"-c\", \"echo ready\"};\n        ProcessBuilder builder = new ProcessBuilder(cmd);\n        Process process = builder.start();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream(), StandardCharsets.UTF_8))) {\n            String line = reader.readLine();\n            int exitCode = process.waitFor();\n            if (exitCode != 0) {\n                throw new IllegalStateException(\"Process exited with \" + exitCode);\n            }\n            System.out.println(line != null ? line.trim() : \"\");\n        }\n    }\n}\n",
      "expectedOutput": "ready",
      "tutorial": "<p class=\"mb-4 text-gray-300\">ProcessBuilder gives you direct control over subprocesses. Wrap the input stream with an InputStreamReader to capture text output.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Process process = new ProcessBuilder(cmd).start();\ntry (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n    String line = reader.readLine();\n    process.waitFor();\n    System.out.println(line);\n}</pre></div><p class=\"mt-4 text-gray-300\">Always wait for the process to finish so you can check the exit status before trusting the output.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding processbuilder capture output is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying processbuilder capture output, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply processbuilder capture output will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with processbuilder capture output, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Processes",
        "I/O"
      ],
      "id": 383
    },
    {
      "title": "384. ThreadLocal with try-with-resources",
      "language": "java",
      "description": "Manage a ThreadLocal using try-with-resources so the value resets after the block, then demonstrate nested contexts.",
      "initialCode": "public class Main {\n    private static final ThreadLocal<String> CURRENT_USER = ThreadLocal.withInitial(() -> \"guest\");\n\n    static AutoCloseable withUser(String user) {\n        String previous = CURRENT_USER.get();\n        CURRENT_USER.set(user);\n        return () -> CURRENT_USER.set(previous);\n    }\n\n    public static void main(String[] args) throws Exception {\n        System.out.println(\"outer=\" + CURRENT_USER.get());\n        try (var ignored = withUser(\"alex\")) {\n            System.out.println(\"inside=\" + CURRENT_USER.get());\n            try (var nested = withUser(\"jamie\")) {\n                System.out.println(\"nested=\" + CURRENT_USER.get());\n            }\n            System.out.println(\"after nested=\" + CURRENT_USER.get());\n        }\n        System.out.println(\"after outer=\" + CURRENT_USER.get());\n    }\n}\n",
      "fullSolution": "public class Main {\n    private static final ThreadLocal<String> CURRENT_USER = ThreadLocal.withInitial(() -> \"guest\");\n\n    static AutoCloseable withUser(String user) {\n        String previous = CURRENT_USER.get();\n        CURRENT_USER.set(user);\n        return () -> CURRENT_USER.set(previous);\n    }\n\n    public static void main(String[] args) throws Exception {\n        System.out.println(\"outer=\" + CURRENT_USER.get());\n        try (var ignored = withUser(\"alex\")) {\n            System.out.println(\"inside=\" + CURRENT_USER.get());\n            try (var nested = withUser(\"jamie\")) {\n                System.out.println(\"nested=\" + CURRENT_USER.get());\n            }\n            System.out.println(\"after nested=\" + CURRENT_USER.get());\n        }\n        System.out.println(\"after outer=\" + CURRENT_USER.get());\n    }\n}\n",
      "expectedOutput": "outer=guest\ninside=alex\nnested=jamie\nafter nested=alex\nafter outer=guest",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Wrap ThreadLocal context switches in an AutoCloseable so try-with-resources handles cleanup automatically. This prevents context leaks in multi-threaded code.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">try (var ignored = withContext(value)) {\n    // context active\n}\n// automatically restored</pre></div><p class=\"mt-4 text-gray-300\">The restore order unwinds like a stack, keeping nested contexts intuitive.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding threadlocal with try-with-resources is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying threadlocal with try-with-resources, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply threadlocal with try-with-resources will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with threadlocal with try-with-resources, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrency",
        "ThreadLocal"
      ],
      "id": 384
    },
    {
      "title": "385. HttpClient sendAsync status",
      "language": "java",
      "description": "Issue an asynchronous HTTP GET using HttpClient.sendAsync, extract the status code, and print it after the request completes.",
      "initialCode": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.concurrent.CompletableFuture;\n\npublic class Main {\n    public static void main(String[] args) {\n        HttpClient client = HttpClient.newHttpClient();\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(\"https://example.com\"))\n                .header(\"Accept\", \"text/html\")\n                .build();\n\n        // TODO: send the request asynchronously, map the response to its status code,\n        // wait for completion, and print the code\n    }\n}\n",
      "fullSolution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.concurrent.CompletableFuture;\n\npublic class Main {\n    public static void main(String[] args) {\n        HttpClient client = HttpClient.newHttpClient();\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(\"https://example.com\"))\n                .header(\"Accept\", \"text/html\")\n                .build();\n\n        CompletableFuture<Void> future = client.sendAsync(request, HttpResponse.BodyHandlers.discarding())\n                .thenApply(HttpResponse::statusCode)\n                .thenAccept(code -> System.out.println(code));\n\n        future.join();\n    }\n}\n",
      "expectedOutput": "200",
      "tutorial": "<p class=\"mb-4 text-gray-300\">sendAsync pipelines a response through a CompletableFuture. Map the response to metadata like the status code, then <code>join()</code> so the program waits for completion.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">client.sendAsync(request, HttpResponse.BodyHandlers.discarding())\n    .thenApply(HttpResponse::statusCode)\n    .thenAccept(System.out::println)\n    .join();</pre></div><p class=\"mt-4 text-gray-300\">Using <code>BodyHandlers.discarding()</code> skips buffering the body when you only care about headers or status codes.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding httpclient sendasync status is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying httpclient sendasync status, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply httpclient sendasync status will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with httpclient sendasync status, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "HTTP Client",
        "Async"
      ],
      "id": 385
    },
    {
      "title": "386. Parse simple JSON manually",
      "language": "java",
      "description": "Extract a value from a simple JSON string using indexOf and substring.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String json = \"{\\\"name\\\":\\\"Alice\\\",\\\"age\\\":30}\";\n        \n        // TODO: extract the value of \"name\" using indexOf and substring, print \"Alice\"\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String json = \"{\\\"name\\\":\\\"Alice\\\",\\\"age\\\":30}\";\n        int nameStart = json.indexOf(\"\\\"name\\\":\\\"\") + 8;\n        int nameEnd = json.indexOf(\"\\\"\", nameStart);\n        String name = json.substring(nameStart, nameEnd);\n        System.out.println(name);\n    }\n}\n",
      "expectedOutput": "Alice",
      "tutorial": "<p class=\"mb-4 text-gray-300\">For simple JSON parsing without libraries, use <code>indexOf()</code> to find keys and <code>substring()</code> to extract values. This works for basic cases.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">int start = json.indexOf(\"\\\"key\\\":\\\"\") + key.length() + 4;\nint end = json.indexOf(\"\\\"\", start);\nString value = json.substring(start, end);</pre></div><p class=\"mt-4 text-gray-300\">For production code, use a proper JSON library. This technique is useful for learning string manipulation.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding parse simple json manually is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying parse simple json manually, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply parse simple json manually will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with parse simple json manually, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Strings",
        "Parsing"
      ],
      "id": 386
    },
    {
      "title": "387. Base64 encode and decode",
      "language": "java",
      "description": "Encode a string to Base64, then decode it back and print the original text.",
      "initialCode": "import java.util.Base64;\nimport java.nio.charset.StandardCharsets;\n\npublic class Main {\n    public static void main(String[] args) {\n        String original = \"secret message\";\n        \n        // TODO: encode the string to Base64, decode it back, and print the result\n    }\n}\n",
      "fullSolution": "import java.util.Base64;\nimport java.nio.charset.StandardCharsets;\n\npublic class Main {\n    public static void main(String[] args) {\n        String original = \"secret message\";\n        byte[] encoded = Base64.getEncoder().encode(original.getBytes(StandardCharsets.UTF_8));\n        byte[] decoded = Base64.getDecoder().decode(encoded);\n        String result = new String(decoded, StandardCharsets.UTF_8);\n        System.out.println(result);\n    }\n}\n",
      "expectedOutput": "secret message",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Java's <code>Base64</code> class provides encoder and decoder instances. Always specify UTF-8 charset to avoid platform-dependent encoding issues.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">byte[] encoded = Base64.getEncoder().encode(text.getBytes(StandardCharsets.UTF_8));\nbyte[] decoded = Base64.getDecoder().decode(encoded);\nString result = new String(decoded, StandardCharsets.UTF_8);</pre></div><p class=\"mt-4 text-gray-300\">Base64 is commonly used for encoding binary data in text-only contexts like JSON or URLs.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding base64 encode and decode is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying base64 encode and decode, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply base64 encode and decode will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with base64 encode and decode, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Encoding",
        "Strings"
      ],
      "id": 387
    },
    {
      "title": "388. Compare file timestamps",
      "language": "java",
      "description": "Check if one file is newer than another by comparing their last modified timestamps.",
      "initialCode": "import java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.attribute.FileTime;\nimport java.io.IOException;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        Path file1 = Files.createTempFile(\"test1\", \".txt\");\n        Path file2 = Files.createTempFile(\"test2\", \".txt\");\n        \n        // TODO: get last modified times, compare them, and print \"newer\" or \"older\"\n        // (file2 compared to file1)\n    }\n}\n",
      "fullSolution": "import java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.attribute.FileTime;\nimport java.io.IOException;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        Path file1 = Files.createTempFile(\"test1\", \".txt\");\n        Path file2 = Files.createTempFile(\"test2\", \".txt\");\n        \n        FileTime time1 = Files.getLastModifiedTime(file1);\n        FileTime time2 = Files.getLastModifiedTime(file2);\n        \n        String result = time2.compareTo(time1) > 0 ? \"newer\" : \"older\";\n        System.out.println(result);\n    }\n}\n",
      "expectedOutput": "newer",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>Files.getLastModifiedTime()</code> returns a <code>FileTime</code> that implements <code>Comparable</code>, so you can use <code>compareTo()</code> directly.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">FileTime t1 = Files.getLastModifiedTime(path1);\nFileTime t2 = Files.getLastModifiedTime(path2);\nboolean isNewer = t2.compareTo(t1) > 0;</pre></div><p class=\"mt-4 text-gray-300\">This is useful for cache invalidation, build systems, or sync tools that need to detect file changes.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding compare file timestamps is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying compare file timestamps, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply compare file timestamps will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with compare file timestamps, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Files",
        "I/O"
      ],
      "id": 388
    },
    {
      "title": "389. String padding",
      "language": "java",
      "description": "Pad a string to a fixed width with leading zeros and print the result.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String number = \"42\";\n        int width = 5;\n        \n        // TODO: pad the string with leading zeros to the specified width and print it\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String number = \"42\";\n        int width = 5;\n        String padded = String.format(\"%0\" + width + \"d\", Integer.parseInt(number));\n        System.out.println(padded);\n    }\n}\n",
      "expectedOutput": "00042",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>String.format()</code> supports printf-style formatting. Use <code>%0Nd</code> where N is the width to pad numbers with leading zeros.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">String padded = String.format(\"%05d\", 42); // \"00042\"\nString leftPad = String.format(\"%5s\", \"hi\");  // \"   hi\"</pre></div><p class=\"mt-4 text-gray-300\">This is essential for formatting IDs, file names, or timestamps where consistent width matters.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding string padding is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying string padding, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply string padding will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with string padding, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Beginner",
        "Strings",
        "Formatting"
      ],
      "id": 389
    },
    {
      "title": "390. Title case conversion",
      "language": "java",
      "description": "Convert a sentence to title case where each word starts with a capital letter.",
      "initialCode": "import java.util.Arrays;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        String text = \"hello world from java\";\n        \n        // TODO: convert to title case and print the result\n    }\n}\n",
      "fullSolution": "import java.util.Arrays;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        String text = \"hello world from java\";\n        String titleCase = Arrays.stream(text.split(\" \"))\n                .map(word -> word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase())\n                .collect(Collectors.joining(\" \"));\n        System.out.println(titleCase);\n    }\n}\n",
      "expectedOutput": "Hello World From Java",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Split the string by spaces, capitalize the first letter of each word, then join them back. Streams make this transformation pipeline clean.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">String result = Arrays.stream(text.split(\" \"))\n    .map(w -> w.substring(0, 1).toUpperCase() + w.substring(1))\n    .collect(Collectors.joining(\" \"));</pre></div><p class=\"mt-4 text-gray-300\">This pattern works for any delimiter-based text transformation.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding title case conversion is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying title case conversion, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply title case conversion will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with title case conversion, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Strings",
        "Streams"
      ],
      "id": 390
    },
    {
      "title": "391. Remove duplicate characters",
      "language": "java",
      "description": "Remove consecutive duplicate characters from a string while preserving order.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String text = \"bookkeeper\";\n        \n        // TODO: remove consecutive duplicate characters and print the result\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String text = \"bookkeeper\";\n        StringBuilder result = new StringBuilder();\n        char prev = '\\0';\n        for (char c : text.toCharArray()) {\n            if (c != prev) {\n                result.append(c);\n                prev = c;\n            }\n        }\n        System.out.println(result.toString());\n    }\n}\n",
      "expectedOutput": "bokeper",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Track the previous character and only append when it differs. A <code>StringBuilder</code> efficiently builds the result string.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">StringBuilder sb = new StringBuilder();\nchar prev = '\\0';\nfor (char c : text.toCharArray()) {\n    if (c != prev) {\n        sb.append(c);\n        prev = c;\n    }\n}</pre></div><p class=\"mt-4 text-gray-300\">This technique is useful for data cleaning and text normalization tasks.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding remove duplicate characters is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying remove duplicate characters, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply remove duplicate characters will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with remove duplicate characters, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Strings",
        "Algorithms"
      ],
      "id": 391
    },
    {
      "title": "392. LinkedHashSet preserves insertion order",
      "language": "java",
      "description": "Use a LinkedHashSet to remove duplicates from a list while maintaining insertion order.",
      "initialCode": "import java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> items = Arrays.asList(\"apple\", \"banana\", \"apple\", \"cherry\", \"banana\");\n        \n        // TODO: remove duplicates while preserving order and print as comma-separated values\n    }\n}\n",
      "fullSolution": "import java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> items = Arrays.asList(\"apple\", \"banana\", \"apple\", \"cherry\", \"banana\");\n        LinkedHashSet<String> unique = new LinkedHashSet<>(items);\n        System.out.println(String.join(\",\", unique));\n    }\n}\n",
      "expectedOutput": "apple,banana,cherry",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>LinkedHashSet</code> combines the uniqueness guarantee of <code>HashSet</code> with predictable iteration order based on insertion.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">LinkedHashSet<T> unique = new LinkedHashSet<>(list);\n// Duplicates removed, order preserved</pre></div><p class=\"mt-4 text-gray-300\">This is perfect for deduplicating user input or processing logs where order matters.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding linkedhashset preserves insertion order is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying linkedhashset preserves insertion order, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply linkedhashset preserves insertion order will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with linkedhashset preserves insertion order, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Collections",
        "Data Structures"
      ],
      "id": 392
    },
    {
      "title": "393. PriorityQueue min heap",
      "language": "java",
      "description": "Use a PriorityQueue to find the three smallest numbers from a list.",
      "initialCode": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> numbers = Arrays.asList(15, 3, 9, 1, 22, 7, 12);\n        \n        // TODO: use a PriorityQueue to extract the 3 smallest numbers and print them space-separated\n    }\n}\n",
      "fullSolution": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> numbers = Arrays.asList(15, 3, 9, 1, 22, 7, 12);\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>(numbers);\n        System.out.println(minHeap.poll() + \" \" + minHeap.poll() + \" \" + minHeap.poll());\n    }\n}\n",
      "expectedOutput": "1 3 7",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>PriorityQueue</code> is a min-heap by default, so <code>poll()</code> extracts the smallest element. Perfect for top-K or priority-based algorithms.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">PriorityQueue<Integer> minHeap = new PriorityQueue<>();\nminHeap.addAll(numbers);\nint smallest = minHeap.poll();</pre></div><p class=\"mt-4 text-gray-300\">For a max-heap, pass <code>Collections.reverseOrder()</code> as a comparator.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding priorityqueue min heap is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying priorityqueue min heap, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply priorityqueue min heap will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with priorityqueue min heap, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Collections",
        "Heap"
      ],
      "id": 393
    },
    {
      "title": "394. ArrayDeque as stack",
      "language": "java",
      "description": "Use ArrayDeque as a stack to reverse a string.",
      "initialCode": "import java.util.ArrayDeque;\n\npublic class Main {\n    public static void main(String[] args) {\n        String text = \"hello\";\n        \n        // TODO: use ArrayDeque as a stack to reverse the string and print it\n    }\n}\n",
      "fullSolution": "import java.util.ArrayDeque;\n\npublic class Main {\n    public static void main(String[] args) {\n        String text = \"hello\";\n        ArrayDeque<Character> stack = new ArrayDeque<>();\n        for (char c : text.toCharArray()) {\n            stack.push(c);\n        }\n        StringBuilder reversed = new StringBuilder();\n        while (!stack.isEmpty()) {\n            reversed.append(stack.pop());\n        }\n        System.out.println(reversed.toString());\n    }\n}\n",
      "expectedOutput": "olleh",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>ArrayDeque</code> is faster than <code>Stack</code> for LIFO operations. Use <code>push()</code> and <code>pop()</code> for stack semantics.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">ArrayDeque<T> stack = new ArrayDeque<>();\nstack.push(item);\nT top = stack.pop();</pre></div><p class=\"mt-4 text-gray-300\">Stacks are fundamental for parsing, backtracking, and undo mechanisms.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding arraydeque as stack is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying arraydeque as stack, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply arraydeque as stack will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with arraydeque as stack, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Collections",
        "Stack"
      ],
      "id": 394
    },
    {
      "title": "395. Try-catch with specific exception",
      "language": "java",
      "description": "Parse an integer from a string and catch NumberFormatException to print a friendly error message.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String input = \"not-a-number\";\n        \n        // TODO: try to parse the input as an integer, catch NumberFormatException,\n        // and print \"invalid\" if it fails\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String input = \"not-a-number\";\n        try {\n            int number = Integer.parseInt(input);\n            System.out.println(number);\n        } catch (NumberFormatException e) {\n            System.out.println(\"invalid\");\n        }\n    }\n}\n",
      "expectedOutput": "invalid",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Catch specific exceptions to handle different failure modes gracefully. <code>NumberFormatException</code> signals invalid numeric input.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">try {\n    int num = Integer.parseInt(str);\n} catch (NumberFormatException e) {\n    // Handle invalid format\n}</pre></div><p class=\"mt-4 text-gray-300\">Always catch the most specific exception type first to avoid masking real errors.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding try-catch with specific exception is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying try-catch with specific exception, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply try-catch with specific exception will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with try-catch with specific exception, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Beginner",
        "Error Handling",
        "Exceptions"
      ],
      "id": 395
    },
    {
      "title": "396. Optional orElse default",
      "language": "java",
      "description": "Use Optional to provide a default value when a nullable string is empty.",
      "initialCode": "import java.util.Optional;\n\npublic class Main {\n    public static void main(String[] args) {\n        String name = null;\n        \n        // TODO: wrap name in Optional and use orElse to provide \"guest\" as default, then print it\n    }\n}\n",
      "fullSolution": "import java.util.Optional;\n\npublic class Main {\n    public static void main(String[] args) {\n        String name = null;\n        String result = Optional.ofNullable(name).orElse(\"guest\");\n        System.out.println(result);\n    }\n}\n",
      "expectedOutput": "guest",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>Optional.ofNullable()</code> safely wraps potentially null values. Use <code>orElse()</code> to provide a fallback when the value is absent.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">String value = Optional.ofNullable(nullable)\n    .orElse(\"default\");</pre></div><p class=\"mt-4 text-gray-300\">This eliminates explicit null checks and makes default handling declarative.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding optional orelse default is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying optional orelse default, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply optional orelse default will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with optional orelse default, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Optional",
        "Error Handling"
      ],
      "id": 396
    },
    {
      "title": "397. Validate input range",
      "language": "java",
      "description": "Check if a number is within a valid range and throw IllegalArgumentException if not.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        int age = 150;\n        \n        // TODO: validate age is between 0 and 120 (inclusive), throw IllegalArgumentException with message \"invalid age\" if not,\n        // otherwise print \"valid\"\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        int age = 150;\n        if (age < 0 || age > 120) {\n            throw new IllegalArgumentException(\"invalid age\");\n        }\n        System.out.println(\"valid\");\n    }\n}\n",
      "expectedOutput": "Exception in thread \"main\" java.lang.IllegalArgumentException: invalid age",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Use <code>IllegalArgumentException</code> to signal invalid method arguments. Fail fast at validation boundaries to prevent corrupted state.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">if (value < min || value > max) {\n    throw new IllegalArgumentException(\"out of range\");\n}</pre></div><p class=\"mt-4 text-gray-300\">Clear validation prevents subtle bugs and makes APIs self-documenting.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding validate input range is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying validate input range, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply validate input range will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with validate input range, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Validation",
        "Error Handling"
      ],
      "id": 397
    },
    {
      "title": "398. Write and read properties file",
      "language": "java",
      "description": "Write key-value pairs to a properties file, then read them back and print a specific value.",
      "initialCode": "import java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        String filename = System.getProperty(\"java.io.tmpdir\") + \"/app.properties\";\n        \n        // TODO: create Properties, set \"user\" to \"alice\" and \"role\" to \"admin\",\n        // write to file, read back, and print the \"user\" value\n    }\n}\n",
      "fullSolution": "import java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        String filename = System.getProperty(\"java.io.tmpdir\") + \"/app.properties\";\n        Properties props = new Properties();\n        props.setProperty(\"user\", \"alice\");\n        props.setProperty(\"role\", \"admin\");\n        \n        try (FileOutputStream out = new FileOutputStream(filename)) {\n            props.store(out, null);\n        }\n        \n        Properties loaded = new Properties();\n        try (FileInputStream in = new FileInputStream(filename)) {\n            loaded.load(in);\n        }\n        \n        System.out.println(loaded.getProperty(\"user\"));\n    }\n}\n",
      "expectedOutput": "alice",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>Properties</code> handles .properties files with <code>store()</code> and <code>load()</code>. Perfect for configuration that doesn't need JSON complexity.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Properties props = new Properties();\nprops.setProperty(\"key\", \"value\");\nprops.store(outputStream, comment);\nprops.load(inputStream);</pre></div><p class=\"mt-4 text-gray-300\">Properties files are human-editable and widely supported for app config.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding write and read properties file is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying write and read properties file, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply write and read properties file will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with write and read properties file, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "I/O",
        "Serialization"
      ],
      "id": 398
    },
    {
      "title": "399. Serialize object to JSON",
      "language": "java",
      "description": "Serialize a simple object to JSON string manually and print it.",
      "initialCode": "class User {\n    public String name;\n    public int age;\n    \n    public User(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        User user = new User(\"Bob\", 25);\n        \n        // TODO: create JSON string manually and print it\n    }\n}\n",
      "fullSolution": "class User {\n    public String name;\n    public int age;\n    \n    public User(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public String toJson() {\n        return \"{\\\"name\\\":\\\"\" + name + \"\\\",\\\"age\\\":\" + age + \"}\";\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        User user = new User(\"Bob\", 25);\n        System.out.println(user.toJson());\n    }\n}\n",
      "expectedOutput": "{\"name\":\"Bob\",\"age\":25}",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Manual JSON serialization uses string concatenation to build the JSON format. Add a <code>toJson()</code> method to the class for cleaner code.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">public String toJson() {\n    return \"{\\\"field\\\":\\\"\" + value + \"\\\"}\";\n}</pre></div><p class=\"mt-4 text-gray-300\">Remember to escape double quotes inside JSON strings with <code>\\\"</code>.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding serialize object to json is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying serialize object to json, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply serialize object to json will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with serialize object to json, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "JSON",
        "Serialization"
      ],
      "id": 399
    },
    {
      "title": "400. Deserialize JSON to object",
      "language": "java",
      "description": "Parse a JSON string manually to extract field values and print them.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String json = \"{\\\"name\\\":\\\"Laptop\\\",\\\"price\\\":999.99}\";\n        \n        // TODO: extract the \"name\" field and print it\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String json = \"{\\\"name\\\":\\\"Laptop\\\",\\\"price\\\":999.99}\";\n        int nameStart = json.indexOf(\"\\\"name\\\":\\\"\") + 8;\n        int nameEnd = json.indexOf(\"\\\"\", nameStart);\n        String name = json.substring(nameStart, nameEnd);\n        System.out.println(name);\n    }\n}\n",
      "expectedOutput": "Laptop",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Manual JSON parsing uses <code>indexOf()</code> to find field markers and <code>substring()</code> to extract values. This approach works for simple, known JSON structures.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">int start = json.indexOf(\"\\\"key\\\":\\\"\") + 7;\nint end = json.indexOf(\"\\\"\", start);\nString value = json.substring(start, end);</pre></div><p class=\"mt-4 text-gray-300\">Add the length of <code>\"key\":\"</code> to skip past the marker when calculating the start position.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding deserialize json to object is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying deserialize json to object, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply deserialize json to object will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with deserialize json to object, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "JSON",
        "Serialization"
      ],
      "id": 400
    },
    {
      "title": "401. TreeMap sorted keys",
      "language": "java",
      "description": "Use TreeMap to automatically maintain sorted keys and iterate in order.",
      "initialCode": "import java.util.TreeMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, Integer> scores = new TreeMap<>();\n        scores.put(\"charlie\", 85);\n        scores.put(\"alice\", 92);\n        scores.put(\"bob\", 78);\n        \n        // TODO: iterate and print keys in sorted order: alice, bob, charlie\n    }\n}\n",
      "fullSolution": "import java.util.TreeMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, Integer> scores = new TreeMap<>();\n        scores.put(\"charlie\", 85);\n        scores.put(\"alice\", 92);\n        scores.put(\"bob\", 78);\n        \n        for (String key : scores.keySet()) {\n            System.out.println(key);\n        }\n    }\n}\n",
      "expectedOutput": "alice\nbob\ncharlie",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>TreeMap</code> uses a Red-Black tree to maintain keys in sorted order. Unlike <code>HashMap</code>, iteration follows natural ordering.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Map<String, Integer> map = new TreeMap<>();\nmap.put(\"z\", 1);\nmap.put(\"a\", 2);\n// Iterates in order: a, z</pre></div><p class=\"mt-4 text-gray-300\">Use <code>TreeMap</code> when you need sorted keys; stick with <code>HashMap</code> for better performance when order doesn't matter.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding treemap sorted keys is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying treemap sorted keys, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply treemap sorted keys will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with treemap sorted keys, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Collections",
        "Data Structures"
      ],
      "id": 401
    },
    {
      "title": "402. EnumSet for flag combinations",
      "language": "java",
      "description": "Use EnumSet to efficiently represent combinations of enum values.",
      "initialCode": "import java.util.EnumSet;\nimport java.util.Set;\n\nenum Permission { READ, WRITE, EXECUTE }\n\npublic class Main {\n    public static void main(String[] args) {\n        // TODO: create EnumSet with READ and WRITE, check if it contains WRITE, print true\n    }\n}\n",
      "fullSolution": "import java.util.EnumSet;\nimport java.util.Set;\n\nenum Permission { READ, WRITE, EXECUTE }\n\npublic class Main {\n    public static void main(String[] args) {\n        Set<Permission> perms = EnumSet.of(Permission.READ, Permission.WRITE);\n        System.out.println(perms.contains(Permission.WRITE));\n    }\n}\n",
      "expectedOutput": "true",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>EnumSet</code> is a specialized high-performance Set for enum types. It uses bit vectors internally for maximum efficiency.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Set<Permission> perms = EnumSet.of(Permission.READ, Permission.WRITE);\nSet<Permission> all = EnumSet.allOf(Permission.class);\nSet<Permission> none = EnumSet.noneOf(Permission.class);</pre></div><p class=\"mt-4 text-gray-300\">Perfect for representing flags, permissions, or options. Much faster than <code>HashSet</code> for enums.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding enumset for flag combinations is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying enumset for flag combinations, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply enumset for flag combinations will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with enumset for flag combinations, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Collections",
        "Enums"
      ],
      "id": 402
    },
    {
      "title": "403. WeakHashMap for caching",
      "language": "java",
      "description": "Use WeakHashMap to create a cache that allows garbage collection of unused entries.",
      "initialCode": "import java.util.Map;\nimport java.util.WeakHashMap;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, String> cache = new WeakHashMap<>();\n        String key = new String(\"data\");\n        cache.put(key, \"cached value\");\n        \n        // TODO: print the cached value before key goes out of scope\n    }\n}\n",
      "fullSolution": "import java.util.Map;\nimport java.util.WeakHashMap;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, String> cache = new WeakHashMap<>();\n        String key = new String(\"data\");\n        cache.put(key, \"cached value\");\n        System.out.println(cache.get(key));\n    }\n}\n",
      "expectedOutput": "cached value",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>WeakHashMap</code> holds weak references to keys. When a key has no strong references, it becomes eligible for garbage collection and is automatically removed.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Map<Key, Value> cache = new WeakHashMap<>();\ncache.put(key, value);\n// When key is GC'd, entry disappears</pre></div><p class=\"mt-4 text-gray-300\">Useful for memory-sensitive caches where you don't want to prevent garbage collection.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding weakhashmap for caching is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying weakhashmap for caching, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply weakhashmap for caching will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with weakhashmap for caching, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Collections",
        "Memory Management"
      ],
      "id": 403
    },
    {
      "title": "404. Function composition with andThen",
      "language": "java",
      "description": "Compose two functions using andThen to create a pipeline.",
      "initialCode": "import java.util.function.Function;\n\npublic class Main {\n    public static void main(String[] args) {\n        Function<String, Integer> parseLength = s -> s.length();\n        Function<Integer, Integer> doubleIt = n -> n * 2;\n        \n        // TODO: compose functions with andThen and apply to \"hello\", print 10\n    }\n}\n",
      "fullSolution": "import java.util.function.Function;\n\npublic class Main {\n    public static void main(String[] args) {\n        Function<String, Integer> parseLength = s -> s.length();\n        Function<Integer, Integer> doubleIt = n -> n * 2;\n        \n        Function<String, Integer> pipeline = parseLength.andThen(doubleIt);\n        System.out.println(pipeline.apply(\"hello\"));\n    }\n}\n",
      "expectedOutput": "10",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>andThen()</code> chains functions so the output of one becomes the input of the next. <code>compose()</code> works in reverse order.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Function<A, B> f = ...;\nFunction<B, C> g = ...;\nFunction<A, C> pipeline = f.andThen(g);\n// Equivalent to: g(f(x))</pre></div><p class=\"mt-4 text-gray-300\">Function composition creates reusable transformation pipelines.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding function composition with andthen is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying function composition with andthen, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply function composition with andthen will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with function composition with andthen, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Functional",
        "Functions"
      ],
      "id": 404
    },
    {
      "title": "405. Predicate chaining with and/or",
      "language": "java",
      "description": "Combine predicates using and() and or() for complex filtering logic.",
      "initialCode": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> words = Arrays.asList(\"apple\", \"ax\", \"banana\", \"blueberry\");\n        Predicate<String> startsWithA = s -> s.startsWith(\"a\");\n        Predicate<String> longWord = s -> s.length() > 3;\n        \n        // TODO: filter words that start with 'a' AND are longer than 3 chars, print \"apple\"\n    }\n}\n",
      "fullSolution": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> words = Arrays.asList(\"apple\", \"ax\", \"banana\", \"blueberry\");\n        Predicate<String> startsWithA = s -> s.startsWith(\"a\");\n        Predicate<String> longWord = s -> s.length() > 3;\n        \n        List<String> result = words.stream()\n            .filter(startsWithA.and(longWord))\n            .collect(Collectors.toList());\n        \n        System.out.println(result.get(0));\n    }\n}\n",
      "expectedOutput": "apple",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Predicates support <code>and()</code>, <code>or()</code>, and <code>negate()</code> for building complex boolean logic compositionally.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Predicate<String> p1 = s -> s.startsWith(\"a\");\nPredicate<String> p2 = s -> s.length() > 3;\nPredicate<String> combined = p1.and(p2);\n// Also: p1.or(p2), p1.negate()</pre></div><p class=\"mt-4 text-gray-300\">Build reusable, composable filters for streams and collections.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding predicate chaining with and/or is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying predicate chaining with and/or, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply predicate chaining with and/or will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with predicate chaining with and/or, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Functional",
        "Streams"
      ],
      "id": 405
    },
    {
      "title": "406. Supplier for lazy evaluation",
      "language": "java",
      "description": "Use Supplier to defer expensive computations until needed.",
      "initialCode": "import java.util.function.Supplier;\n\npublic class Main {\n    static String expensiveComputation() {\n        return \"computed\";\n    }\n    \n    public static void main(String[] args) {\n        // TODO: wrap expensiveComputation in a Supplier, call get() and print result\n    }\n}\n",
      "fullSolution": "import java.util.function.Supplier;\n\npublic class Main {\n    static String expensiveComputation() {\n        return \"computed\";\n    }\n    \n    public static void main(String[] args) {\n        Supplier<String> lazy = () -> expensiveComputation();\n        System.out.println(lazy.get());\n    }\n}\n",
      "expectedOutput": "computed",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>Supplier</code> represents a deferred computation. The function isn't called until you invoke <code>get()</code>.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Supplier<ExpensiveResult> lazy = () -> compute();\n// Nothing computed yet\nExpensiveResult result = lazy.get();\n// Now it's computed</pre></div><p class=\"mt-4 text-gray-300\">Useful for lazy initialization, caching, and avoiding unnecessary work.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding supplier for lazy evaluation is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying supplier for lazy evaluation, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply supplier for lazy evaluation will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with supplier for lazy evaluation, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Functional",
        "Functions"
      ],
      "id": 406
    },
    {
      "title": "407. CountDownLatch synchronization",
      "language": "java",
      "description": "Use CountDownLatch to wait for multiple threads to complete before proceeding.",
      "initialCode": "import java.util.concurrent.CountDownLatch;\n\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        CountDownLatch latch = new CountDownLatch(3);\n        \n        for (int i = 0; i < 3; i++) {\n            int id = i;\n            new Thread(() -> {\n                // TODO: simulate work, then call latch.countDown()\n            }).start();\n        }\n        \n        // TODO: wait for all threads using latch.await(), then print \"done\"\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.CountDownLatch;\n\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        CountDownLatch latch = new CountDownLatch(3);\n        \n        for (int i = 0; i < 3; i++) {\n            int id = i;\n            new Thread(() -> {\n                try {\n                    Thread.sleep(10);\n                } catch (InterruptedException e) {}\n                latch.countDown();\n            }).start();\n        }\n        \n        latch.await();\n        System.out.println(\"done\");\n    }\n}\n",
      "expectedOutput": "done",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>CountDownLatch</code> blocks until a counter reaches zero. Each thread calls <code>countDown()</code>, and the main thread waits with <code>await()</code>.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">CountDownLatch latch = new CountDownLatch(n);\n// Spawn n threads, each calls latch.countDown()\nlatch.await();  // Blocks until count reaches 0</pre></div><p class=\"mt-4 text-gray-300\">Perfect for coordinating parallel initialization or waiting for worker threads to finish.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding countdownlatch synchronization is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying countdownlatch synchronization, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply countdownlatch synchronization will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with countdownlatch synchronization, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrency",
        "Synchronization"
      ],
      "id": 407
    },
    {
      "title": "408. CyclicBarrier coordination",
      "language": "java",
      "description": "Use CyclicBarrier to synchronize threads at a common barrier point.",
      "initialCode": "import java.util.concurrent.CyclicBarrier;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        CyclicBarrier barrier = new CyclicBarrier(2, () -> System.out.println(\"ready\"));\n        \n        new Thread(() -> {\n            try {\n                barrier.await();\n            } catch (Exception e) {}\n        }).start();\n        \n        // TODO: call barrier.await() in main thread to trigger barrier action\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.CyclicBarrier;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        CyclicBarrier barrier = new CyclicBarrier(2, () -> System.out.println(\"ready\"));\n        \n        new Thread(() -> {\n            try {\n                barrier.await();\n            } catch (Exception e) {}\n        }).start();\n        \n        Thread.sleep(50);\n        barrier.await();\n    }\n}\n",
      "expectedOutput": "ready",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>CyclicBarrier</code> makes threads wait until all parties arrive, then optionally runs a barrier action. Unlike <code>CountDownLatch</code>, it's reusable.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">CyclicBarrier barrier = new CyclicBarrier(n, action);\n// Each of n threads calls:\nbarrier.await();\n// When all arrive, action runs</pre></div><p class=\"mt-4 text-gray-300\">Useful for iterative parallel algorithms where threads need to sync between phases.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding cyclicbarrier coordination is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying cyclicbarrier coordination, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply cyclicbarrier coordination will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with cyclicbarrier coordination, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrency",
        "Synchronization"
      ],
      "id": 408
    },
    {
      "title": "409. Semaphore resource limiting",
      "language": "java",
      "description": "Use Semaphore to limit concurrent access to a resource pool.",
      "initialCode": "import java.util.concurrent.Semaphore;\n\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        Semaphore semaphore = new Semaphore(2);\n        \n        // TODO: acquire permit, simulate work, release permit, print \"acquired\"\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.Semaphore;\n\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        Semaphore semaphore = new Semaphore(2);\n        \n        semaphore.acquire();\n        try {\n            System.out.println(\"acquired\");\n        } finally {\n            semaphore.release();\n        }\n    }\n}\n",
      "expectedOutput": "acquired",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>Semaphore</code> controls access to a pool of permits. <code>acquire()</code> blocks if no permits are available; <code>release()</code> returns a permit.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Semaphore sem = new Semaphore(maxConcurrent);\nsem.acquire();\ntry {\n    // Use resource\n} finally {\n    sem.release();\n}</pre></div><p class=\"mt-4 text-gray-300\">Perfect for throttling concurrent access to databases, APIs, or limited resource pools.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding semaphore resource limiting is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying semaphore resource limiting, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply semaphore resource limiting will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with semaphore resource limiting, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrency",
        "Resource Management"
      ],
      "id": 409
    },
    {
      "title": "410. Stream.iterate infinite sequence",
      "language": "java",
      "description": "Generate an infinite sequence with Stream.iterate and limit it.",
      "initialCode": "import java.util.stream.Stream;\n\npublic class Main {\n    public static void main(String[] args) {\n        // TODO: create infinite stream starting at 1, incrementing by 2, limit to 5, sum and print (25)\n    }\n}\n",
      "fullSolution": "import java.util.stream.Stream;\n\npublic class Main {\n    public static void main(String[] args) {\n        int sum = Stream.iterate(1, n -> n + 2)\n            .limit(5)\n            .mapToInt(Integer::intValue)\n            .sum();\n        System.out.println(sum);\n    }\n}\n",
      "expectedOutput": "25",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>Stream.iterate(seed, fn)</code> generates an infinite stream by repeatedly applying the function. Always use <code>limit()</code> to prevent infinite loops.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Stream.iterate(0, n -> n + 1)  // 0, 1, 2, 3...\n    .limit(10)\n    .forEach(System.out::println);</pre></div><p class=\"mt-4 text-gray-300\">Useful for generating sequences, Fibonacci numbers, or any iterative computation.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding stream.iterate infinite sequence is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying stream.iterate infinite sequence, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply stream.iterate infinite sequence will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with stream.iterate infinite sequence, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Streams",
        "Functional"
      ],
      "id": 410
    },
    {
      "title": "411. Stream.takeWhile conditional limit",
      "language": "java",
      "description": "Use takeWhile to take elements from a stream while a condition holds.",
      "initialCode": "import java.util.stream.Stream;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> numbers = List.of(1, 2, 3, 4, 5, 1, 2);\n        \n        // TODO: use takeWhile to take elements while < 4, collect to list and print size (3)\n    }\n}\n",
      "fullSolution": "import java.util.stream.Stream;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> numbers = List.of(1, 2, 3, 4, 5, 1, 2);\n        \n        List<Integer> result = numbers.stream()\n            .takeWhile(n -> n < 4)\n            .collect(Collectors.toList());\n        \n        System.out.println(result.size());\n    }\n}\n",
      "expectedOutput": "3",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>takeWhile()</code> stops consuming the stream as soon as the predicate returns false. Unlike <code>filter()</code>, it doesn't check all elements.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Stream.of(1, 2, 3, 4, 5)\n    .takeWhile(n -> n < 4)  // Takes 1, 2, 3, stops at 4\n    .forEach(System.out::println);</pre></div><p class=\"mt-4 text-gray-300\">Perfect for processing sorted data or reading until a sentinel value.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding stream.takewhile conditional limit is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying stream.takewhile conditional limit, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply stream.takewhile conditional limit will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with stream.takewhile conditional limit, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Streams",
        "Functional"
      ],
      "id": 411
    },
    {
      "title": "412. StringBuilder capacity and trimToSize",
      "language": "java",
      "description": "Understand StringBuilder's capacity management and trim unused space.",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(100);\n        sb.append(\"hi\");\n        \n        // TODO: call trimToSize(), then print the length (2)\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(100);\n        sb.append(\"hi\");\n        sb.trimToSize();\n        System.out.println(sb.length());\n    }\n}\n",
      "expectedOutput": "2",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>StringBuilder</code> allocates extra capacity for growth. <code>trimToSize()</code> reduces the internal buffer to match the actual string length, saving memory.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">StringBuilder sb = new StringBuilder(1000);\nsb.append(\"small\");\nsb.trimToSize();  // Releases unused capacity</pre></div><p class=\"mt-4 text-gray-300\">Use <code>trimToSize()</code> when you're done building a string and want to minimize memory footprint.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding stringbuilder capacity and trimtosize is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying stringbuilder capacity and trimtosize, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply stringbuilder capacity and trimtosize will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with stringbuilder capacity and trimtosize, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Strings",
        "Performance"
      ],
      "id": 412
    },
    {
      "title": "413. WeakReference garbage collection",
      "language": "java",
      "description": "Use WeakReference to hold an object without preventing garbage collection.",
      "initialCode": "import java.lang.ref.WeakReference;\n\npublic class Main {\n    public static void main(String[] args) {\n        String obj = new String(\"data\");\n        WeakReference<String> weak = new WeakReference<>(obj);\n        \n        // TODO: print weak.get() (should show \"data\")\n    }\n}\n",
      "fullSolution": "import java.lang.ref.WeakReference;\n\npublic class Main {\n    public static void main(String[] args) {\n        String obj = new String(\"data\");\n        WeakReference<String> weak = new WeakReference<>(obj);\n        \n        System.out.println(weak.get());\n    }\n}\n",
      "expectedOutput": "data",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>WeakReference</code> allows you to reference an object without preventing the garbage collector from reclaiming it.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">WeakReference<MyObject> ref = new WeakReference<>(obj);\nMyObject retrieved = ref.get();  // May return null if GC'd\nif (retrieved != null) {\n    // Use it\n}</pre></div><p class=\"mt-4 text-gray-300\">Useful for caches and listeners where you don't want to prevent cleanup.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding weakreference garbage collection is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying weakreference garbage collection, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply weakreference garbage collection will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with weakreference garbage collection, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Memory",
        "GC"
      ],
      "id": 413
    },
    {
      "title": "414. Method reference with constructor",
      "language": "java",
      "description": "Use a constructor method reference to create objects from a stream.",
      "initialCode": "import java.util.List;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> words = List.of(\"hello\", \"world\");\n        \n        // TODO: map each word to StringBuilder using StringBuilder::new, collect and print count (2)\n    }\n}\n",
      "fullSolution": "import java.util.List;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> words = List.of(\"hello\", \"world\");\n        \n        List<StringBuilder> builders = words.stream()\n            .map(StringBuilder::new)\n            .collect(Collectors.toList());\n        \n        System.out.println(builders.size());\n    }\n}\n",
      "expectedOutput": "2",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Constructor references like <code>StringBuilder::new</code> create a new object for each element. They're shorthand for <code>s -> new StringBuilder(s)</code>.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Instead of:\nlist.stream().map(s -> new StringBuilder(s))\n\n// Use:\nlist.stream().map(StringBuilder::new)</pre></div><p class=\"mt-4 text-gray-300\">Method references make functional code more concise and readable.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding method reference with constructor is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying method reference with constructor, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply method reference with constructor will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with method reference with constructor, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Functional",
        "Lambdas"
      ],
      "id": 414
    },
    {
      "title": "415. GZIP compression stream",
      "language": "java",
      "description": "Write compressed data using GZIPOutputStream.",
      "initialCode": "import java.io.*;\nimport java.util.zip.GZIPOutputStream;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        \n        // TODO: wrap baos in GZIPOutputStream, write \"test\".getBytes(), close, print baos.size() > 0\n    }\n}\n",
      "fullSolution": "import java.io.*;\nimport java.util.zip.GZIPOutputStream;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        \n        try (GZIPOutputStream gzip = new GZIPOutputStream(baos)) {\n            gzip.write(\"test\".getBytes());\n        }\n        \n        System.out.println(baos.size() > 0);\n    }\n}\n",
      "expectedOutput": "true",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>GZIPOutputStream</code> compresses data on-the-fly as you write to it. Wrap any OutputStream to add compression.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">try (GZIPOutputStream gzip = new GZIPOutputStream(\n        new FileOutputStream(\"file.gz\"))) {\n    gzip.write(data);\n}</pre></div><p class=\"mt-4 text-gray-300\">Always close GZIP streams to flush compression buffers. Use try-with-resources.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding gzip compression stream is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying gzip compression stream, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply gzip compression stream will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with gzip compression stream, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "IO",
        "Compression"
      ],
      "id": 415
    },
    {
      "title": "416. AtomicInteger for thread-safe counter",
      "language": "java",
      "description": "Use AtomicInteger to safely increment a counter from multiple threads.",
      "initialCode": "import java.util.concurrent.atomic.AtomicInteger;\n\npublic class Main {\n    public static void main(String[] args) {\n        AtomicInteger counter = new AtomicInteger(0);\n        \n        // TODO: incrementAndGet twice, then print the value (2)\n    }\n}\n",
      "fullSolution": "import java.util.concurrent.atomic.AtomicInteger;\n\npublic class Main {\n    public static void main(String[] args) {\n        AtomicInteger counter = new AtomicInteger(0);\n        \n        counter.incrementAndGet();\n        counter.incrementAndGet();\n        \n        System.out.println(counter.get());\n    }\n}\n",
      "expectedOutput": "2",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>AtomicInteger</code> provides lock-free, thread-safe operations on integers using CPU-level atomic instructions.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">AtomicInteger count = new AtomicInteger(0);\ncount.incrementAndGet();  // Atomic ++\ncount.addAndGet(5);       // Atomic += 5\nint val = count.get();    // Read current value</pre></div><p class=\"mt-4 text-gray-300\">More efficient than synchronized blocks for simple counters and flags.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding atomicinteger for thread-safe counter is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying atomicinteger for thread-safe counter, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply atomicinteger for thread-safe counter will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with atomicinteger for thread-safe counter, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Concurrency",
        "Atomic"
      ],
      "id": 416
    },
    {
      "title": "417. Supplier for lazy evaluation",
      "language": "java",
      "description": "Use Supplier to defer expensive computation until needed.",
      "initialCode": "import java.util.function.Supplier;\n\npublic class Main {\n    public static void main(String[] args) {\n        Supplier<String> lazy = () -> \"computed\";\n        \n        // TODO: call lazy.get() and print the result\n    }\n}\n",
      "fullSolution": "import java.util.function.Supplier;\n\npublic class Main {\n    public static void main(String[] args) {\n        Supplier<String> lazy = () -> \"computed\";\n        \n        System.out.println(lazy.get());\n    }\n}\n",
      "expectedOutput": "computed",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>Supplier</code> represents a function that takes no arguments and returns a value. It defers execution until <code>get()</code> is called.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Supplier<ExpensiveObject> supplier = () -> new ExpensiveObject();\n// Not created yet\nif (needed) {\n    ExpensiveObject obj = supplier.get();  // Created now\n}</pre></div><p class=\"mt-4 text-gray-300\">Perfect for optional or conditional computations.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding supplier for lazy evaluation is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying supplier for lazy evaluation, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply supplier for lazy evaluation will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with supplier for lazy evaluation, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Functional",
        "Lambdas"
      ],
      "id": 417
    },
    {
      "title": "418. Arrays.binarySearch for sorted lookup",
      "language": "java",
      "description": "Use binary search to efficiently find an element in a sorted array.",
      "initialCode": "import java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] sorted = {1, 3, 5, 7, 9};\n        \n        // TODO: use Arrays.binarySearch to find index of 5, print it (2)\n    }\n}\n",
      "fullSolution": "import java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] sorted = {1, 3, 5, 7, 9};\n        \n        int index = Arrays.binarySearch(sorted, 5);\n        System.out.println(index);\n    }\n}\n",
      "expectedOutput": "2",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>Arrays.binarySearch</code> finds elements in O(log n) time, but the array must be sorted first.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">int[] arr = {1, 3, 5, 7, 9};\nint idx = Arrays.binarySearch(arr, 5);  // Returns 2\nif (idx >= 0) {\n    // Found at index idx\n} else {\n    // Not found, -(insertion point) - 1\n}</pre></div><p class=\"mt-4 text-gray-300\">Much faster than linear search for large sorted arrays.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding arrays.binarysearch for sorted lookup is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying arrays.binarysearch for sorted lookup, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply arrays.binarysearch for sorted lookup will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with arrays.binarysearch for sorted lookup, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Arrays",
        "Algorithms"
      ],
      "id": 418
    },
    {
      "title": "419. Enum.values() iteration",
      "language": "java",
      "description": "Iterate over all values in an enum using values().",
      "initialCode": "public class Main {\n    enum Color { RED, GREEN, BLUE }\n    \n    public static void main(String[] args) {\n        // TODO: use Color.values() in a for-each loop, print the count (3)\n        int count = 0;\n        \n        System.out.println(count);\n    }\n}\n",
      "fullSolution": "public class Main {\n    enum Color { RED, GREEN, BLUE }\n    \n    public static void main(String[] args) {\n        int count = 0;\n        for (Color c : Color.values()) {\n            count++;\n        }\n        System.out.println(count);\n    }\n}\n",
      "expectedOutput": "3",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Every enum automatically gets a <code>values()</code> method that returns an array of all enum constants.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">enum Status { PENDING, APPROVED, REJECTED }\n\nfor (Status s : Status.values()) {\n    System.out.println(s);\n}</pre></div><p class=\"mt-4 text-gray-300\">Useful for validation, UI generation, or processing all possible states.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding enum.values() iteration is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying enum.values() iteration, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply enum.values() iteration will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with enum.values() iteration, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Enums",
        "Collections"
      ],
      "id": 419
    },
    {
      "title": "420. Class.forName for reflection",
      "language": "java",
      "description": "Load a class by name using reflection.",
      "initialCode": "public class Main {\n    public static void main(String[] args) throws Exception {\n        // TODO: use Class.forName(\"java.lang.String\") and print getSimpleName()\n    }\n}\n",
      "fullSolution": "public class Main {\n    public static void main(String[] args) throws Exception {\n        Class<?> clazz = Class.forName(\"java.lang.String\");\n        System.out.println(clazz.getSimpleName());\n    }\n}\n",
      "expectedOutput": "String",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>Class.forName()</code> dynamically loads a class by its fully qualified name. The basis of reflection in Java.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">String className = \"java.util.ArrayList\";\nClass<?> clazz = Class.forName(className);\nObject instance = clazz.getDeclaredConstructor().newInstance();</pre></div><p class=\"mt-4 text-gray-300\">Used in frameworks, dependency injection, and plugin systems.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding class.forname for reflection is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying class.forname for reflection, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply class.forname for reflection will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with class.forname for reflection, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "Reflection",
        "Meta"
      ],
      "id": 420
    },
    {
      "title": "421. ByteBuffer for binary data",
      "language": "java",
      "description": "Use ByteBuffer to read and write primitive types as bytes.",
      "initialCode": "import java.nio.ByteBuffer;\n\npublic class Main {\n    public static void main(String[] args) {\n        ByteBuffer buffer = ByteBuffer.allocate(8);\n        buffer.putInt(42);\n        buffer.flip();\n        \n        // TODO: read the int back with getInt() and print it (42)\n    }\n}\n",
      "fullSolution": "import java.nio.ByteBuffer;\n\npublic class Main {\n    public static void main(String[] args) {\n        ByteBuffer buffer = ByteBuffer.allocate(8);\n        buffer.putInt(42);\n        buffer.flip();\n        \n        System.out.println(buffer.getInt());\n    }\n}\n",
      "expectedOutput": "42",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>ByteBuffer</code> provides a view over raw bytes with typed read/write operations. Essential for NIO and binary protocols.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">ByteBuffer buf = ByteBuffer.allocate(12);\nbuf.putInt(100);      // Write int\nbuf.putFloat(3.14f);  // Write float\nbuf.flip();           // Switch to read mode\nint i = buf.getInt();\nfloat f = buf.getFloat();</pre></div><p class=\"mt-4 text-gray-300\">Always call <code>flip()</code> between writing and reading.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding bytebuffer for binary data is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying bytebuffer for binary data, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply bytebuffer for binary data will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with bytebuffer for binary data, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Advanced",
        "IO",
        "NIO",
        "Binary"
      ],
      "id": 421
    },
    {
      "title": "422. Optional.orElseThrow custom exception",
      "language": "java",
      "description": "Use orElseThrow to provide a custom exception when Optional is empty.",
      "initialCode": "import java.util.Optional;\n\npublic class Main {\n    public static void main(String[] args) {\n        Optional<String> opt = Optional.of(\"value\");\n        \n        // TODO: use orElseThrow with () -> new RuntimeException(\"Missing\"), print result\n    }\n}\n",
      "fullSolution": "import java.util.Optional;\n\npublic class Main {\n    public static void main(String[] args) {\n        Optional<String> opt = Optional.of(\"value\");\n        \n        String result = opt.orElseThrow(() -> new RuntimeException(\"Missing\"));\n        System.out.println(result);\n    }\n}\n",
      "expectedOutput": "value",
      "tutorial": "<p class=\"mb-4 text-gray-300\"><code>orElseThrow()</code> lets you specify a custom exception supplier when an Optional is empty.</p><h4 class=\"font-semibold text-gray-200 mb-2\">Pattern:</h4><div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Optional<User> user = findUser(id);\nUser u = user.orElseThrow(() -> \n    new UserNotFoundException(\"No user: \" + id));</pre></div><p class=\"mt-4 text-gray-300\">Better than <code>get()</code> because you control the exception type and message.</p>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Practical Applications:</h4>\n<p class=\"mb-4 text-gray-300\">\nUnderstanding optional.orelsethrow custom exception is essential for writing effective Java code. This concept appears frequently in real-world applications and is a building block for more advanced patterns.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Write clear, self-documenting code that follows language conventions</li>\n<li>Add appropriate comments to explain complex logic or important decisions</li>\n<li>Handle edge cases and error conditions properly</li>\n<li>Test your code thoroughly with various inputs</li>\n<li>Follow the DRY (Don't Repeat Yourself) principle</li>\n<li>Consider performance implications for production code</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Patterns:</h4>\n<p class=\"mb-4 text-gray-300\">\nWhen applying optional.orelsethrow custom exception, you'll commonly see it used in combination with other language features to create robust, maintainable solutions. The fullSolution code demonstrates a practical implementation you can reference.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use:</h4>\n<p class=\"mb-4 text-gray-300\">\nThis pattern is particularly useful when building production applications, solving algorithmic challenges, or creating reusable components. Understanding when and how to apply optional.orelsethrow custom exception will make you a more effective Java developer.\n</p>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Key Takeaways:</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Master the fundamental syntax and structure</li>\n<li>Understand the practical use cases and applications</li>\n<li>Know when to apply this pattern vs. alternatives</li>\n<li>Build on this foundation for more advanced concepts</li>\n<li>Practice with variations to deepen understanding</li>\n</ul>\n\n<h4 class=\"font-semibold text-gray-200 mb-2\">Further Learning:</h4>\n<p class=\"mb-4 text-gray-300\">\nAs you become comfortable with optional.orelsethrow custom exception, explore related concepts and more complex scenarios. The skills you develop here form the foundation for advanced Java programming techniques.\n</p>\n",
      "tags": [
        "Intermediate",
        "Optional",
        "Error Handling"
      ],
      "id": 422
    },
    {
      "id": 423,
      "title": "423. Reading environment variables",
      "description": "Learn how to read environment variables using System.getenv() in Java",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        // Read the PATH environment variable\n        String path = System.getenv(\"PATH\");\n        System.out.println(\"PATH exists: \" + (path != null));\n\n        // TODO: Read the USER or USERNAME environment variable\n        // TODO: Count all environment variables\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        // Read the PATH environment variable\n        String path = System.getenv(\"PATH\");\n        System.out.println(\"PATH exists: \" + (path != null));\n\n        // Read the USER or USERNAME environment variable\n        String user = System.getenv(\"USER\");\n        if (user == null) {\n            user = System.getenv(\"USERNAME\");  // Windows\n        }\n        System.out.println(\"User: \" + (user != null ? user : \"unknown\"));\n\n        // Count all environment variables\n        int count = System.getenv().size();\n        System.out.println(\"Total environment variables: \" + count);\n    }\n}",
      "expectedOutput": "PATH exists: true\nUser: [username]\nTotal environment variables: [count]",
      "tutorial": "<h3 class=\"font-semibold text-gray-200 mb-3\">Reading Environment Variables in Java</h3>\nEnvironment variables are key-value pairs provided by the operating system that allow configuration without changing code.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Usage</h4>\nRead a single environment variable:\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">String path = System.getenv(\"PATH\");\nif (path != null) {\n    System.out.println(\"PATH: \" + path);\n} else {\n    System.out.println(\"PATH not set\");\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Reading All Variables</h4>\nGet all environment variables as a Map:\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">Map<String, String> env = System.getenv();\nfor (Map.Entry<String, String> entry : env.entrySet()) {\n    System.out.println(entry.getKey() + \" = \" + entry.getValue());\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Cross-Platform Variable Names</h4>\nDifferent operating systems use different variable names:\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Get username (cross-platform)\nString user = System.getenv(\"USER\");  // Unix/Linux/Mac\nif (user == null) {\n    user = System.getenv(\"USERNAME\");  // Windows\n}\nSystem.out.println(\"Current user: \" + user);\n// Get home directory\nString home = System.getenv(\"HOME\");  // Unix\nif (home == null) {\n    home = System.getenv(\"USERPROFILE\");  // Windows\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Environment Variables</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>PATH</strong>: Directories to search for executables</li>\n<li><strong>HOME</strong> (Unix) / <strong>USERPROFILE</strong> (Windows): User's home directory</li>\n<li><strong>USER</strong> (Unix) / <strong>USERNAME</strong> (Windows): Current username</li>\n<li><strong>JAVA_HOME</strong>: Java installation directory</li>\n<li><strong>TEMP</strong> / <strong>TMP</strong>: Temporary files directory</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Always check for null</strong>: Variables may not be set</li>\n<li><strong>Handle platform differences</strong>: Use fallback logic for OS-specific variables</li>\n<li><strong>Don't rely on case</strong>: Variable names are case-sensitive on Unix, case-insensitive on Windows</li>\n<li><strong>Security</strong>: Never log sensitive environment variables (API keys, passwords)</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Reading system configuration</li>\n<li>Detecting runtime environment</li>\n<li>Finding system directories</li>\n<li>Getting user information</li>\n<li>CI/CD pipeline configuration</li>\n</ul>",
      "language": "java",
      "tags": [
        "Intermediate",
        "CLI",
        "Workflow"
      ]
    },
    {
      "id": 424,
      "title": "424. Default environment variable values",
      "description": "Learn how to provide default values for environment variables",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        // Read APP_NAME with default\n        String appName = getEnvOrDefault(\"APP_NAME\", \"MyApp\");\n        System.out.println(\"App: \" + appName);\n\n        // TODO: Read PORT with default \"8080\"\n        // TODO: Read LOG_LEVEL with default \"INFO\"\n    }\n\n    private static String getEnvOrDefault(String name, String defaultValue) {\n        String value = System.getenv(name);\n        return value != null ? value : defaultValue;\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        // Read APP_NAME with default\n        String appName = getEnvOrDefault(\"APP_NAME\", \"MyApp\");\n        System.out.println(\"App: \" + appName);\n\n        // Read PORT with default \"8080\"\n        String port = getEnvOrDefault(\"PORT\", \"8080\");\n        System.out.println(\"Port: \" + port);\n\n        // Read LOG_LEVEL with default \"INFO\"\n        String logLevel = getEnvOrDefault(\"LOG_LEVEL\", \"INFO\");\n        System.out.println(\"Log Level: \" + logLevel);\n    }\n\n    private static String getEnvOrDefault(String name, String defaultValue) {\n        String value = System.getenv(name);\n        return value != null ? value : defaultValue;\n    }\n}",
      "expectedOutput": "App: MyApp\nPort: 8080\nLog Level: INFO",
      "tutorial": "<h3 class=\"font-semibold text-gray-200 mb-3\">Default Environment Variable Values in Java</h3>\nProviding default values makes your application more robust and easier to configure.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Reading with Defaults</h4>\nThe basic pattern for environment variables with defaults:\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">private static String getEnvOrDefault(String name, String defaultValue) {\n    String value = System.getenv(name);\n    return value != null ? value : defaultValue;\n}\n// Usage\nString appName = getEnvOrDefault(\"APP_NAME\", \"MyApp\");\nString port = getEnvOrDefault(\"PORT\", \"8080\");</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Type Conversion</h4>\nSince environment variables are always strings, you need to convert them:\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Integer\nint port = Integer.parseInt(getEnvOrDefault(\"PORT\", \"8080\"));\n// Boolean\nboolean debug = Boolean.parseBoolean(getEnvOrDefault(\"DEBUG\", \"false\"));\n// With error handling\nint timeout;\ntry {\n    timeout = Integer.parseInt(getEnvOrDefault(\"TIMEOUT\", \"30\"));\n} catch (NumberFormatException e) {\n    timeout = 30; // fallback default\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Configuration Class Pattern</h4>\nFor complex applications, create a configuration class:\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">public class AppConfig {\n    public static final String APP_NAME = getEnvOrDefault(\"APP_NAME\", \"MyApp\");\n    public static final int PORT = Integer.parseInt(getEnvOrDefault(\"PORT\", \"8080\"));\n    public static final String LOG_LEVEL = getEnvOrDefault(\"LOG_LEVEL\", \"INFO\");\n    private static String getEnvOrDefault(String name, String defaultValue) {\n        String value = System.getenv(name);\n        return value != null ? value : defaultValue;\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Document all variables</strong>: Maintain a README or .env.example file listing all expected environment variables</li>\n<li><strong>Use sensible defaults</strong>: Development-friendly defaults reduce configuration burden</li>\n<li><strong>Validate after parsing</strong>: Check that converted values are in acceptable ranges</li>\n<li><strong>Fail fast</strong>: For required variables without good defaults, fail early with clear error messages</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Configuring server ports, database URLs, API keys</li>\n<li>Feature flags and debug modes</li>\n<li>Environment-specific settings (dev/staging/prod)</li>\n<li>Docker and cloud deployments</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Example: Complete Configuration</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">public class DatabaseConfig {\n    private final String host;\n    private final int port;\n    private final String database;\n    public DatabaseConfig() {\n        this.host = getEnvOrDefault(\"DB_HOST\", \"localhost\");\n        this.port = Integer.parseInt(getEnvOrDefault(\"DB_PORT\", \"5432\"));\n        this.database = getEnvOrDefault(\"DB_NAME\", \"myapp\");\n        validate();\n    }\n    private void validate() {\n        if (port < 1 || port > 65535) {\n            throw new IllegalArgumentException(\"Invalid port: \" + port);\n        }\n    }\n    private static String getEnvOrDefault(String name, String defaultValue) {\n        String value = System.getenv(name);\n        return value != null ? value : defaultValue;\n    }\n}</pre></div>",
      "language": "java",
      "tags": [
        "Intermediate",
        "CLI",
        "Workflow"
      ]
    },
    {
      "id": 425,
      "title": "425. Logger with multiple levels",
      "description": "Learn how to use different logging levels in Java",
      "initialCode": "import java.util.logging.*;\n\npublic class Main {\n    private static final Logger logger = Logger.getLogger(Main.class.getName());\n\n    public static void main(String[] args) {\n        logger.info(\"Application started\");\n\n        // TODO: Log a warning message\n        // TODO: Log a severe (error) message\n    }\n}",
      "fullSolution": "import java.util.logging.*;\n\npublic class Main {\n    private static final Logger logger = Logger.getLogger(Main.class.getName());\n\n    public static void main(String[] args) {\n        logger.severe(\"This is a SEVERE message\");\n        logger.warning(\"This is a WARNING message\");\n        logger.info(\"This is an INFO message\");\n\n        System.out.println(\"Check console for log messages\");\n    }\n}",
      "expectedOutput": "SEVERE: This is a SEVERE message\nWARNING: This is a WARNING message\nINFO: This is an INFO message\nCheck console for log messages",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Java's logging framework provides a hierarchical system for tracking application behavior, debugging issues, and monitoring production systems. The java.util.logging package offers five primary logging levels (SEVERE, WARNING, INFO, CONFIG, FINE) that help developers categorize message importance. Understanding logging levels is crucial for effective debugging and system monitoring in enterprise applications where you need to track what's happening across distributed components.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.logging.<em>;\nLogger logger = Logger.getLogger(MyClass.class.getName());\nlogger.severe(\"Critical error occurred\");\nlogger.warning(\"Potential issue detected\");\nlogger.info(\"Normal operation message\");</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.logging.</em>;\npublic class LoggerDemo {\n    private static final Logger logger = Logger.getLogger(LoggerDemo.class.getName());\n    static {\n        logger.setLevel(Level.ALL);\n        ConsoleHandler handler = new ConsoleHandler();\n        handler.setLevel(Level.ALL);\n        logger.addHandler(handler);\n        logger.setUseParentHandlers(false);\n    }\n    public void processData(String data) {\n        logger.fine(\"Processing started: \" + data);\n        logger.config(\"Configuration loaded\");\n        logger.info(\"Data processed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.logging.*;\npublic class Main {\n    private static final Logger logger = Logger.getLogger(Main.class.getName());\n    public static void main(String[] args) {\n        try {\n            logger.info(\"Application started\");\n            int result = divide(10, 0);\n            logger.info(\"Result: \" + result);\n        } catch (Exception e) {\n            logger.severe(\"Exception occurred: \" + e.getMessage());\n            logger.warning(\"Using default value\");\n        } finally {\n            logger.info(\"Application shutdown\");\n        }\n    }\n    static int divide(int a, int b) {\n        logger.fine(\"Dividing \" + a + \" by \" + b);\n        return a / b;\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Error tracking</strong>: Log exceptions and error conditions with SEVERE level for immediate attention</li>\n<li><strong>Debugging production issues</strong>: Use INFO and FINE levels to trace application flow without overwhelming logs</li>\n<li><strong>Performance monitoring</strong>: Track operation timing and resource usage with appropriate log levels</li>\n<li><strong>Audit trails</strong>: Record user actions and system events for compliance and security analysis</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Use appropriate log levels consistently across your application (SEVERE for errors, WARNING for issues, INFO for milestones)</li>\n<li>Include contextual information in log messages (user IDs, transaction IDs, timestamps)</li>\n<li>Configure log levels externally via properties files rather than hard-coding in source</li>\n<li>Avoid logging sensitive data (passwords, credit cards, personal information)</li>\n<li>Use parameterized logging for better performance: logger.log(Level.INFO, \"User {0} logged in\", userId)</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Java logging when building production applications that require monitoring and debugging capabilities, when you need hierarchical logger control across modules, when compliance requires audit trails, or when you're working in enterprise environments with centralized logging systems. Logging is essential for diagnosing issues in deployed applications where debuggers aren't available.</p>",
      "language": "java",
      "tags": [
        "Intermediate",
        "Debugging",
        "Tooling"
      ]
    },
    {
      "id": 426,
      "title": "426. Custom log formatter",
      "description": "Learn how to create custom log formatters in Java",
      "initialCode": "import java.util.logging.*;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class Main {\n    public static void main(String[] args) {\n        Logger logger = Logger.getLogger(Main.class.getName());\n\n        // TODO: Create custom formatter\n        // TODO: Apply formatter to console handler\n        // TODO: Log messages with custom format\n\n        logger.info(\"Test message\");\n    }\n}",
      "fullSolution": "import java.util.logging.*;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class Main {\n    public static void main(String[] args) {\n        Logger logger = Logger.getLogger(Main.class.getName());\n        logger.setUseParentHandlers(false);\n\n        // Create custom formatter\n        Formatter customFormatter = new Formatter() {\n            private final SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\n            @Override\n            public String format(LogRecord record) {\n                return String.format(\"[%s] %s: %s%n\",\n                    dateFormat.format(new Date(record.getMillis())),\n                    record.getLevel(),\n                    record.getMessage()\n                );\n            }\n        };\n\n        // Apply formatter to console handler\n        ConsoleHandler handler = new ConsoleHandler();\n        handler.setFormatter(customFormatter);\n        logger.addHandler(handler);\n\n        // Log messages with custom format\n        logger.info(\"Application started\");\n        logger.warning(\"This is a warning\");\n    }\n}",
      "expectedOutput": "[2024-01-15 10:30:45] INFO: Application started\n[2024-01-15 10:30:45] WARNING: This is a warning",
      "tutorial": "<p class=\"mb-4 text-gray-300\">Custom log formatters in Java allow precise control over log output format, including timestamps, thread information, log levels, and message content. The java.util.logging.Formatter abstract class provides the foundation for creating formatters, with SimpleFormatter and XMLFormatter as built-in implementations. Creating custom formatters enables consistent logging across enterprise applications and integration with log aggregation systems like ELK stack or Splunk.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.logging.<em>;\npublic class SimpleCustomFormatter extends Formatter {\n    @Override\n    public String format(LogRecord record) {\n        return String.format(\"[%s] %s: %s%n\",\n            record.getLevel(),\n            record.getLoggerName(),\n            record.getMessage()\n        );\n    }\n}\n// Usage\nLogger logger = Logger.getLogger(\"MyLogger\");\nConsoleHandler handler = new ConsoleHandler();\nhandler.setFormatter(new SimpleCustomFormatter());\nlogger.addHandler(handler);</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.logging.</em>;\nimport java.time.<em>;\nimport java.time.format.DateTimeFormatter;\npublic class DetailedFormatter extends Formatter {\n    private static final DateTimeFormatter formatter =\n        DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss.SSS\");\n    @Override\n    public String format(LogRecord record) {\n        LocalDateTime timestamp = LocalDateTime.ofInstant(\n            Instant.ofEpochMilli(record.getMillis()),\n            ZoneId.systemDefault()\n        );\n        return String.format(\"%s | %s | %s | %s.%s | %s%n\",\n            timestamp.format(formatter),\n            Thread.currentThread().getName(),\n            record.getLevel(),\n            record.getSourceClassName(),\n            record.getSourceMethodName(),\n            record.getMessage()\n        );\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.logging.</em>;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\npublic class Main {\n    static class JsonFormatter extends Formatter {\n        @Override\n        public String format(LogRecord record) {\n            StringBuilder json = new StringBuilder(\"{\");\n            json.append(\"\\\"timestamp\\\":\").append(record.getMillis()).append(\",\");\n            json.append(\"\\\"level\\\":\\\"\").append(record.getLevel()).append(\"\\\",\");\n            json.append(\"\\\"logger\\\":\\\"\").append(record.getLoggerName()).append(\"\\\",\");\n            json.append(\"\\\"message\\\":\\\"\").append(escape(record.getMessage())).append(\"\\\"\");\n            if (record.getThrown() != null) {\n                StringWriter sw = new StringWriter();\n                record.getThrown().printStackTrace(new PrintWriter(sw));\n                json.append(\",\\\"exception\\\":\\\"\").append(escape(sw.toString())).append(\"\\\"\");\n            }\n            json.append(\"}\\n\");\n            return json.toString();\n        }\n        private String escape(String str) {\n            return str.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\\"\", \"\\\\\\\"\").replace(\"\\n\", \"\\\\n\");\n        }\n    }\n    public static void main(String[] args) {\n        Logger logger = Logger.getLogger(Main.class.getName());\n        ConsoleHandler handler = new ConsoleHandler();\n        handler.setFormatter(new JsonFormatter());\n        logger.addHandler(handler);\n        logger.setUseParentHandlers(false);\n        logger.info(\"Application started\");\n        logger.warning(\"Low memory detected\");\n        try {\n            throw new RuntimeException(\"Test exception\");\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error occurred\", e);\n        }\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>JSON logging</strong>: Format logs as JSON for easy parsing by log aggregation tools like ELK stack</li>\n<li><strong>Structured logging</strong>: Include metadata fields (user ID, request ID, session ID) in consistent format</li>\n<li><strong>Console output</strong>: Create human-readable formats for development with color coding and alignment</li>\n<li><strong>Integration with monitoring</strong>: Format logs to match requirements of monitoring systems like Splunk or Datadog</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Keep format() method thread-safe as it may be called concurrently from multiple threads</li>\n<li>Cache expensive objects like DateTimeFormatter instances as class-level static fields</li>\n<li>Include essential context (timestamp, level, logger name) in every formatted message</li>\n<li>Escape special characters properly when generating JSON, XML, or CSV formatted logs</li>\n<li>Consider performance impact of complex formatting; use buffered output for high-volume logging</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse custom formatters when integrating with centralized logging infrastructure, when you need machine-parseable log formats (JSON, XML), when building microservices that require consistent log formats across services, or when existing formatters don't provide needed information. Custom formatters are essential for production systems with sophisticated monitoring and alerting requirements.</p>",
      "language": "java",
      "tags": [
        "Intermediate",
        "Debugging",
        "Tooling"
      ]
    },
    {
      "id": 427,
      "title": "427. Reading CSV files line by line",
      "description": "Learn how to read CSV files in Java",
      "initialCode": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        // TODO: Create sample CSV data\n        // TODO: Read CSV line by line\n        // TODO: Parse each line into fields\n    }\n}",
      "fullSolution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        // Create sample CSV data\n        String csvData = \"Name,Age,City\\nAlice,30,NYC\\nBob,25,LA\\nCharlie,35,Chicago\";\n        BufferedReader reader = new BufferedReader(new StringReader(csvData));\n\n        // Read CSV line by line\n        String line;\n        boolean isHeader = true;\n        while ((line = reader.readLine()) != null) {\n            if (isHeader) {\n                System.out.println(\"Header: \" + line);\n                isHeader = false;\n                continue;\n            }\n\n            // Parse each line into fields\n            String[] fields = line.split(\",\");\n            System.out.println(\"Name: \" + fields[0] + \", Age: \" + fields[1] + \", City: \" + fields[2]);\n        }\n    }\n}",
      "expectedOutput": "Header: Name,Age,City\nName: Alice, Age: 30, City: NYC\nName: Bob, Age: 25, City: LA\nName: Charlie, Age: 35, City: Chicago",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Reading CSV files line by line in Java, an essential concept for building robust and maintainable applications. Understanding Reading CSV files line by line helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Reading CSV files line by line\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Reading CSV files line by line\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Reading CSV files line by line\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Reading CSV files line by line in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Reading CSV files line by line to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Reading CSV files line by line to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Reading CSV files line by line in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Reading CSV files line by line</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Reading CSV files line by line</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Reading CSV files line by line when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Intermediate",
        "I/O",
        "Data Processing"
      ]
    },
    {
      "id": 428,
      "title": "428. Writing CSV with headers",
      "description": "Learn how to write CSV files with headers in Java",
      "initialCode": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        // TODO: Create StringWriter for output\n        // TODO: Write header row\n        // TODO: Write data rows\n    }\n}",
      "fullSolution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        StringWriter output = new StringWriter();\n        PrintWriter writer = new PrintWriter(output);\n\n        // Write header row\n        writer.println(\"Name,Age,City\");\n\n        // Write data rows\n        List<String[]> data = List.of(\n            new String[]{\"Alice\", \"30\", \"NYC\"},\n            new String[]{\"Bob\", \"25\", \"LA\"}\n        );\n\n        for (String[] row : data) {\n            writer.println(String.join(\",\", row));\n        }\n\n        writer.flush();\n        System.out.println(output.toString());\n    }\n}",
      "expectedOutput": "Name,Age,City\nAlice,30,NYC\nBob,25,LA\n",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Writing CSV with headers in Java, an essential concept for building robust and maintainable applications. Understanding Writing CSV with headers helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Writing CSV with headers\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Writing CSV with headers\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Writing CSV with headers\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Writing CSV with headers in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Writing CSV with headers to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Writing CSV with headers to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Writing CSV with headers in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Writing CSV with headers</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Writing CSV with headers</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Writing CSV with headers when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Intermediate",
        "I/O",
        "Data Processing"
      ]
    },
    {
      "id": 429,
      "title": "429. Loading properties from file",
      "description": "Learn how to load configuration from properties files in Java",
      "initialCode": "import java.io.*;\nimport java.util.Properties;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        Properties props = new Properties();\n\n        // TODO: Load properties from string (simulating file)\n        // TODO: Read property values\n        // TODO: Provide default values\n    }\n}",
      "fullSolution": "import java.io.*;\nimport java.util.Properties;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        Properties props = new Properties();\n\n        // Load properties from string (simulating file)\n        String propsData = \"app.name=MyApp\\napp.port=8080\\napp.debug=true\";\n        props.load(new StringReader(propsData));\n\n        // Read property values\n        String appName = props.getProperty(\"app.name\");\n        String port = props.getProperty(\"app.port\");\n        String debug = props.getProperty(\"app.debug\");\n\n        System.out.println(\"App: \" + appName);\n        System.out.println(\"Port: \" + port);\n        System.out.println(\"Debug: \" + debug);\n\n        // Provide default values\n        String logLevel = props.getProperty(\"app.loglevel\", \"INFO\");\n        System.out.println(\"Log Level: \" + logLevel);\n    }\n}",
      "expectedOutput": "App: MyApp\nPort: 8080\nDebug: true\nLog Level: INFO",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Loading properties from file in Java, an essential concept for building robust and maintainable applications. Understanding Loading properties from file helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Loading properties from file\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Loading properties from file\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Loading properties from file\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Loading properties from file in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Loading properties from file to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Loading properties from file to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Loading properties from file in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Loading properties from file</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Loading properties from file</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Loading properties from file when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Intermediate",
        "I/O",
        "Workflow"
      ]
    },
    {
      "id": 430,
      "title": "430. Writing properties to file",
      "description": "Learn how to write configuration to properties files",
      "initialCode": "import java.io.*;\nimport java.util.Properties;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        Properties props = new Properties();\n\n        // TODO: Set property values\n        // TODO: Store properties with comments\n    }\n}",
      "fullSolution": "import java.io.*;\nimport java.util.Properties;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        Properties props = new Properties();\n\n        // Set property values\n        props.setProperty(\"app.name\", \"MyApp\");\n        props.setProperty(\"app.port\", \"8080\");\n        props.setProperty(\"app.debug\", \"true\");\n\n        // Store properties with comments\n        StringWriter output = new StringWriter();\n        props.store(output, \"Application Configuration\");\n\n        System.out.println(output.toString());\n    }\n}",
      "expectedOutput": "#Application Configuration\n#[timestamp]\napp.debug=true\napp.name=MyApp\napp.port=8080",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Writing properties to file in Java, an essential concept for building robust and maintainable applications. Understanding Writing properties to file helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Writing properties to file\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Writing properties to file\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Writing properties to file\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Writing properties to file in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Writing properties to file to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Writing properties to file to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Writing properties to file in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Writing properties to file</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Writing properties to file</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Writing properties to file when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Intermediate",
        "I/O",
        "Workflow"
      ]
    },
    {
      "id": 431,
      "title": "431. Parsing XML with DOM",
      "description": "Learn how to parse XML documents in Java",
      "initialCode": "import javax.xml.parsers.*;\nimport org.w3c.dom.*;\nimport java.io.StringReader;\nimport org.xml.sax.InputSource;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        String xml = \"<users><user><name>Alice</name><age>30</age></user></users>\";\n\n        // TODO: Parse XML string\n        // TODO: Get root element\n        // TODO: Extract data from elements\n    }\n}",
      "fullSolution": "import javax.xml.parsers.*;\nimport org.w3c.dom.*;\nimport java.io.StringReader;\nimport org.xml.sax.InputSource;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        String xml = \"<users><user><name>Alice</name><age>30</age></user></users>\";\n\n        // Parse XML string\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        Document doc = builder.parse(new InputSource(new StringReader(xml)));\n\n        // Get root element\n        Element root = doc.getDocumentElement();\n        System.out.println(\"Root: \" + root.getNodeName());\n\n        // Extract data from elements\n        NodeList users = root.getElementsByTagName(\"user\");\n        for (int i = 0; i < users.getLength(); i++) {\n            Element user = (Element) users.item(i);\n            String name = user.getElementsByTagName(\"name\").item(0).getTextContent();\n            String age = user.getElementsByTagName(\"age\").item(0).getTextContent();\n            System.out.println(\"User: \" + name + \", Age: \" + age);\n        }\n    }\n}",
      "expectedOutput": "Root: users\nUser: Alice, Age: 30",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Parsing XML with DOM in Java, an essential concept for building robust and maintainable applications. Understanding Parsing XML with DOM helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Parsing XML with DOM\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Parsing XML with DOM\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Parsing XML with DOM\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Parsing XML with DOM in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Parsing XML with DOM to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Parsing XML with DOM to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Parsing XML with DOM in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Parsing XML with DOM</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Parsing XML with DOM</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Parsing XML with DOM when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Intermediate",
        "Parsing",
        "Data Processing"
      ]
    },
    {
      "id": 432,
      "title": "432. Creating XML documents",
      "description": "Learn how to create XML documents in Java",
      "initialCode": "import javax.xml.parsers.*;\nimport javax.xml.transform.*;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport org.w3c.dom.*;\nimport java.io.StringWriter;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // TODO: Create document builder\n        // TODO: Create document and root element\n        // TODO: Add child elements\n        // TODO: Output XML\n    }\n}",
      "fullSolution": "import javax.xml.parsers.*;\nimport javax.xml.transform.*;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport org.w3c.dom.*;\nimport java.io.StringWriter;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Create document builder\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        Document doc = builder.newDocument();\n\n        // Create document and root element\n        Element root = doc.createElement(\"users\");\n        doc.appendChild(root);\n\n        // Add child elements\n        Element user = doc.createElement(\"user\");\n        Element name = doc.createElement(\"name\");\n        name.setTextContent(\"Alice\");\n        Element age = doc.createElement(\"age\");\n        age.setTextContent(\"30\");\n\n        user.appendChild(name);\n        user.appendChild(age);\n        root.appendChild(user);\n\n        // Output XML\n        TransformerFactory tf = TransformerFactory.newInstance();\n        Transformer transformer = tf.newTransformer();\n        transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n        StringWriter writer = new StringWriter();\n        transformer.transform(new DOMSource(doc), new StreamResult(writer));\n\n        System.out.println(writer.toString());\n    }\n}",
      "expectedOutput": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<users>\n  <user>\n    <name>Alice</name>\n    <age>30</age>\n  </user>\n</users>",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Creating XML documents in Java, an essential concept for building robust and maintainable applications. Understanding Creating XML documents helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Creating XML documents\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Creating XML documents\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Creating XML documents\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Creating XML documents in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Creating XML documents to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Creating XML documents to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Creating XML documents in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Creating XML documents</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Creating XML documents</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Creating XML documents when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Intermediate",
        "Parsing",
        "Data Processing"
      ]
    },
    {
      "id": 433,
      "title": "433. Command line argument parsing",
      "description": "Learn how to parse command line arguments in Java",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        // Simulate: java Main --name Alice --verbose\n        String[] testArgs = {\"--name\", \"Alice\", \"--verbose\"};\n\n        // TODO: Parse named arguments\n        // TODO: Parse flag arguments\n        // TODO: Handle missing arguments\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        // Simulate: java Main --name Alice --verbose\n        String[] testArgs = {\"--name\", \"Alice\", \"--verbose\"};\n\n        // Parse named arguments\n        String name = getArgValue(testArgs, \"--name\", \"Unknown\");\n        System.out.println(\"Name: \" + name);\n\n        // Parse flag arguments\n        boolean verbose = hasFlag(testArgs, \"--verbose\");\n        System.out.println(\"Verbose: \" + verbose);\n\n        // Handle missing arguments\n        String missing = getArgValue(testArgs, \"--age\", \"Not provided\");\n        System.out.println(\"Age: \" + missing);\n    }\n\n    private static String getArgValue(String[] args, String name, String defaultValue) {\n        for (int i = 0; i < args.length - 1; i++) {\n            if (args[i].equals(name)) {\n                return args[i + 1];\n            }\n        }\n        return defaultValue;\n    }\n\n    private static boolean hasFlag(String[] args, String flag) {\n        for (String arg : args) {\n            if (arg.equals(flag)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
      "expectedOutput": "Name: Alice\nVerbose: true\nAge: Not provided",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Command line argument parsing in Java, an essential concept for building robust and maintainable applications. Understanding Command line argument parsing helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Command line argument parsing\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Command line argument parsing\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Command line argument parsing\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Command line argument parsing in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Command line argument parsing to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Command line argument parsing to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Command line argument parsing in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Command line argument parsing</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Command line argument parsing</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Command line argument parsing when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Intermediate",
        "CLI",
        "Tooling"
      ]
    },
    {
      "id": 434,
      "title": "434. Required and optional CLI arguments",
      "description": "Learn how to handle required and optional command line arguments",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        String[] testArgs = {\"--required\", \"value1\", \"--optional\", \"value2\"};\n\n        // TODO: Check for required argument\n        // TODO: Get optional argument with default\n        // TODO: Exit with error if required missing\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        String[] testArgs = {\"--required\", \"value1\", \"--optional\", \"value2\"};\n\n        // Check for required argument\n        String required = getArgValue(testArgs, \"--required\", null);\n        if (required == null) {\n            System.err.println(\"Error: --required argument is mandatory\");\n            System.exit(1);\n        }\n        System.out.println(\"Required: \" + required);\n\n        // Get optional argument with default\n        String optional = getArgValue(testArgs, \"--optional\", \"default_value\");\n        System.out.println(\"Optional: \" + optional);\n\n        // Missing optional keeps default\n        String missing = getArgValue(testArgs, \"--missing\", \"default\");\n        System.out.println(\"Missing: \" + missing);\n    }\n\n    private static String getArgValue(String[] args, String name, String defaultValue) {\n        for (int i = 0; i < args.length - 1; i++) {\n            if (args[i].equals(name)) {\n                return args[i + 1];\n            }\n        }\n        return defaultValue;\n    }\n}",
      "expectedOutput": "Required: value1\nOptional: value2\nMissing: default",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Required and optional CLI arguments in Java, an essential concept for building robust and maintainable applications. Understanding Required and optional CLI arguments helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Required and optional CLI arguments\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Required and optional CLI arguments\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Required and optional CLI arguments\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Required and optional CLI arguments in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Required and optional CLI arguments to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Required and optional CLI arguments to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Required and optional CLI arguments in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Required and optional CLI arguments</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Required and optional CLI arguments</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Required and optional CLI arguments when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Intermediate",
        "CLI",
        "Tooling"
      ]
    },
    {
      "id": 435,
      "title": "435. String formatting with MessageFormat",
      "description": "Learn how to use MessageFormat for string templates",
      "initialCode": "import java.text.MessageFormat;\n\npublic class Main {\n    public static void main(String[] args) {\n        // TODO: Create template with placeholders\n        // TODO: Format with values\n        // TODO: Handle different data types\n    }\n}",
      "fullSolution": "import java.text.MessageFormat;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create template with placeholders\n        String template = \"Hello {0}, you have {1} new messages. Balance: ${2,number,#.##}\";\n\n        // Format with values\n        String result = MessageFormat.format(template, \"Alice\", 5, 123.456);\n        System.out.println(result);\n\n        // Different data types\n        String template2 = \"User {0} logged in at {1,time,short} on {1,date,short}\";\n        String result2 = MessageFormat.format(template2, \"Bob\", new java.util.Date());\n        System.out.println(result2);\n    }\n}",
      "expectedOutput": "Hello Alice, you have 5 new messages. Balance: $123.46\nUser Bob logged in at [time] on [date]",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers String formatting with MessageFormat in Java, an essential concept for building robust and maintainable applications. Understanding String formatting with MessageFormat helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of String formatting with MessageFormat\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating String formatting with MessageFormat\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of String formatting with MessageFormat\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement String formatting with MessageFormat in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use String formatting with MessageFormat to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply String formatting with MessageFormat to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing String formatting with MessageFormat in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing String formatting with MessageFormat</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of String formatting with MessageFormat</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse String formatting with MessageFormat when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Intermediate",
        "Strings",
        "Formatting"
      ]
    },
    {
      "id": 436,
      "title": "436. Text block templates",
      "description": "Learn how to use text blocks for multi-line strings",
      "initialCode": "public class Main {\n    public static void main(String[] args) {\n        // TODO: Create multi-line text block\n        // TODO: Use formatted() for substitution\n        // TODO: Print formatted output\n    }\n}",
      "fullSolution": "public class Main {\n    public static void main(String[] args) {\n        // Create multi-line text block (Java 15+, but we'll simulate)\n        String template = \"Dear %s,\\n\\n\" +\n                         \"Thank you for your order #%d.\\n\" +\n                         \"Total: $%.2f\\n\\n\" +\n                         \"Best regards\";\n\n        // Use String.format for substitution\n        String result = String.format(template, \"Alice\", 12345, 99.99);\n        System.out.println(result);\n\n        // Alternative with manual formatting\n        String name = \"Bob\";\n        int orderId = 67890;\n        double total = 149.50;\n        System.out.println(\"\\n--- Second Example ---\");\n        System.out.println(\"Dear \" + name + \",\");\n        System.out.println(\"\\nYour order #\" + orderId + \" is ready.\");\n        System.out.println(\"Total: $\" + String.format(\"%.2f\", total));\n    }\n}",
      "expectedOutput": "Dear Alice,\n\nThank you for your order #12345.\nTotal: $99.99\n\nBest regards\n\n--- Second Example ---\nDear Bob,\n\nYour order #67890 is ready.\nTotal: $149.50",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Text block templates in Java, an essential concept for building robust and maintainable applications. Understanding Text block templates helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Text block templates\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Text block templates\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Text block templates\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Text block templates in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Text block templates to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Text block templates to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Text block templates in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Text block templates</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Text block templates</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Text block templates when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Intermediate",
        "Strings",
        "Formatting"
      ]
    },
    {
      "id": 437,
      "title": "437. Simple retry with exponential backoff",
      "description": "Learn how to implement retry logic with exponential backoff",
      "initialCode": "public class Main {\n    private static int attempt = 0;\n\n    public static void main(String[] args) throws Exception {\n        // TODO: Implement retry with exponential backoff\n        // TODO: Max retries: 3\n        // TODO: Backoff: 100ms, 200ms, 400ms\n    }\n\n    private static void unreliableOperation() throws Exception {\n        attempt++;\n        if (attempt < 3) {\n            throw new Exception(\"Temporary failure\");\n        }\n        System.out.println(\"Success on attempt \" + attempt);\n    }\n}",
      "fullSolution": "public class Main {\n    private static int attempt = 0;\n\n    public static void main(String[] args) {\n        int maxRetries = 3;\n        int baseDelay = 100;  // milliseconds\n\n        for (int i = 0; i < maxRetries; i++) {\n            try {\n                unreliableOperation();\n                break;  // Success, exit loop\n            } catch (Exception e) {\n                System.out.println(\"Attempt \" + (i + 1) + \" failed: \" + e.getMessage());\n\n                if (i < maxRetries - 1) {\n                    // Exponential backoff: 100ms, 200ms, 400ms\n                    int delay = baseDelay * (1 << i);  // 2^i\n                    System.out.println(\"Retrying in \" + delay + \"ms...\");\n                    try {\n                        Thread.sleep(delay);\n                    } catch (InterruptedException ie) {\n                        Thread.currentThread().interrupt();\n                        break;\n                    }\n                } else {\n                    System.out.println(\"Max retries reached\");\n                }\n            }\n        }\n    }\n\n    private static void unreliableOperation() throws Exception {\n        attempt++;\n        if (attempt < 3) {\n            throw new Exception(\"Temporary failure\");\n        }\n        System.out.println(\"Success on attempt \" + attempt);\n    }\n}",
      "expectedOutput": "Attempt 1 failed: Temporary failure\nRetrying in 100ms...\nAttempt 2 failed: Temporary failure\nRetrying in 200ms...\nSuccess on attempt 3",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Simple retry with exponential backoff in Java, an essential concept for building robust and maintainable applications. Understanding Simple retry with exponential backoff helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Simple retry with exponential backoff\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Simple retry with exponential backoff\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Simple retry with exponential backoff\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Simple retry with exponential backoff in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Simple retry with exponential backoff to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Simple retry with exponential backoff to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Simple retry with exponential backoff in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Simple retry with exponential backoff</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Simple retry with exponential backoff</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Simple retry with exponential backoff when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Advanced",
        "Error Handling",
        "Patterns"
      ]
    },
    {
      "id": 438,
      "title": "438. Retry with max attempts",
      "description": "Learn how to create a reusable retry method",
      "initialCode": "import java.util.function.Supplier;\n\npublic class Main {\n    public static void main(String[] args) {\n        // TODO: Create retry method\n        // TODO: Use Supplier for operation\n        // TODO: Call retry method\n    }\n\n    private static int attempt = 0;\n\n    private static String unreliableOperation() {\n        attempt++;\n        if (attempt < 2) {\n            throw new RuntimeException(\"Failure\");\n        }\n        return \"Success\";\n    }\n}",
      "fullSolution": "import java.util.function.Supplier;\n\npublic class Main {\n    public static void main(String[] args) {\n        attempt = 0;\n\n        // Use retry method\n        try {\n            String result = retry(() -> unreliableOperation(), 3);\n            System.out.println(\"Result: \" + result);\n        } catch (Exception e) {\n            System.out.println(\"Failed after retries: \" + e.getMessage());\n        }\n    }\n\n    private static int attempt = 0;\n\n    private static String unreliableOperation() {\n        attempt++;\n        System.out.println(\"Attempt \" + attempt);\n        if (attempt < 2) {\n            throw new RuntimeException(\"Failure\");\n        }\n        return \"Success\";\n    }\n\n    private static <T> T retry(Supplier<T> operation, int maxAttempts) {\n        RuntimeException lastException = null;\n\n        for (int i = 0; i < maxAttempts; i++) {\n            try {\n                return operation.get();\n            } catch (RuntimeException e) {\n                lastException = e;\n                if (i < maxAttempts - 1) {\n                    System.out.println(\"Retry \" + (i + 1) + \" after failure\");\n                }\n            }\n        }\n\n        throw new RuntimeException(\"Max attempts reached\", lastException);\n    }\n}",
      "expectedOutput": "Attempt 1\nRetry 1 after failure\nAttempt 2\nResult: Success",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Retry with max attempts in Java, an essential concept for building robust and maintainable applications. Understanding Retry with max attempts helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Retry with max attempts\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Retry with max attempts\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Retry with max attempts\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Retry with max attempts in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Retry with max attempts to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Retry with max attempts to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Retry with max attempts in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Retry with max attempts</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Retry with max attempts</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Retry with max attempts when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Advanced",
        "Error Handling",
        "Patterns"
      ]
    },
    {
      "id": 439,
      "title": "439. HashMap with LRU eviction",
      "description": "Learn how to implement an LRU cache using LinkedHashMap",
      "initialCode": "import java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        // TODO: Create LRU cache with max size 3\n        // TODO: Override removeEldestEntry\n        // TODO: Test cache eviction\n    }\n}",
      "fullSolution": "import java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create LRU cache with max size 3\n        int maxSize = 3;\n        Map<String, String> cache = new LinkedHashMap<String, String>(16, 0.75f, true) {\n            @Override\n            protected boolean removeEldestEntry(Map.Entry<String, String> eldest) {\n                return size() > maxSize;\n            }\n        };\n\n        // Test cache eviction\n        cache.put(\"A\", \"Value A\");\n        cache.put(\"B\", \"Value B\");\n        cache.put(\"C\", \"Value C\");\n        System.out.println(\"Cache: \" + cache.keySet());\n\n        cache.put(\"D\", \"Value D\");  // Should evict A\n        System.out.println(\"After D: \" + cache.keySet());\n\n        cache.get(\"B\");  // Access B (makes it most recently used)\n        cache.put(\"E\", \"Value E\");  // Should evict C (not B)\n        System.out.println(\"After E: \" + cache.keySet());\n    }\n}",
      "expectedOutput": "Cache: [A, B, C]\nAfter D: [B, C, D]\nAfter E: [B, D, E]",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers HashMap with LRU eviction in Java, an essential concept for building robust and maintainable applications. Understanding HashMap with LRU eviction helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of HashMap with LRU eviction\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating HashMap with LRU eviction\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of HashMap with LRU eviction\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement HashMap with LRU eviction in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use HashMap with LRU eviction to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply HashMap with LRU eviction to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing HashMap with LRU eviction in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing HashMap with LRU eviction</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of HashMap with LRU eviction</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse HashMap with LRU eviction when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Advanced",
        "Performance",
        "Collections"
      ]
    },
    {
      "id": 440,
      "title": "440. Time-based cache expiration",
      "description": "Learn how to implement TTL (Time To Live) cache",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    static class CacheEntry {\n        String value;\n        long expiryTime;\n\n        CacheEntry(String value, long ttlMillis) {\n            this.value = value;\n            this.expiryTime = System.currentTimeMillis() + ttlMillis;\n        }\n\n        boolean isExpired() {\n            return System.currentTimeMillis() > expiryTime;\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        // TODO: Create cache map\n        // TODO: Put values with TTL\n        // TODO: Check expiration\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    static class CacheEntry {\n        String value;\n        long expiryTime;\n\n        CacheEntry(String value, long ttlMillis) {\n            this.value = value;\n            this.expiryTime = System.currentTimeMillis() + ttlMillis;\n        }\n\n        boolean isExpired() {\n            return System.currentTimeMillis() > expiryTime;\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        Map<String, CacheEntry> cache = new HashMap<>();\n\n        // Put values with TTL\n        cache.put(\"key1\", new CacheEntry(\"value1\", 1000));  // 1 second TTL\n        cache.put(\"key2\", new CacheEntry(\"value2\", 5000));  // 5 second TTL\n\n        // Immediate access\n        CacheEntry entry = cache.get(\"key1\");\n        if (entry != null && !entry.isExpired()) {\n            System.out.println(\"key1: \" + entry.value);\n        }\n\n        // Wait and check expiration\n        Thread.sleep(1100);\n        entry = cache.get(\"key1\");\n        if (entry == null || entry.isExpired()) {\n            System.out.println(\"key1: expired\");\n        }\n\n        entry = cache.get(\"key2\");\n        if (entry != null && !entry.isExpired()) {\n            System.out.println(\"key2: \" + entry.value);\n        }\n    }\n}",
      "expectedOutput": "key1: value1\nkey1: expired\nkey2: value2",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Time-based cache expiration in Java, an essential concept for building robust and maintainable applications. Understanding Time-based cache expiration helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Time-based cache expiration\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Time-based cache expiration\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Time-based cache expiration\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Time-based cache expiration in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Time-based cache expiration to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Time-based cache expiration to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Time-based cache expiration in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Time-based cache expiration</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Time-based cache expiration</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Time-based cache expiration when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Advanced",
        "Performance",
        "Collections"
      ]
    },
    {
      "id": 441,
      "title": "441. Token bucket rate limiter",
      "description": "Learn how to implement a token bucket rate limiter",
      "initialCode": "public class Main {\n    static class TokenBucket {\n        private int tokens;\n        private final int capacity;\n        private final int refillRate;\n        private long lastRefill;\n\n        public TokenBucket(int capacity, int refillRate) {\n            this.capacity = capacity;\n            this.refillRate = refillRate;\n            this.tokens = capacity;\n            this.lastRefill = System.currentTimeMillis();\n        }\n\n        // TODO: Implement refill method\n        // TODO: Implement tryConsume method\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        // TODO: Create bucket with capacity 3, refill 1/sec\n        // TODO: Test token consumption\n    }\n}",
      "fullSolution": "public class Main {\n    static class TokenBucket {\n        private int tokens;\n        private final int capacity;\n        private final int refillRate;\n        private long lastRefill;\n\n        public TokenBucket(int capacity, int refillRate) {\n            this.capacity = capacity;\n            this.refillRate = refillRate;\n            this.tokens = capacity;\n            this.lastRefill = System.currentTimeMillis();\n        }\n\n        private void refill() {\n            long now = System.currentTimeMillis();\n            long timePassed = now - lastRefill;\n            int tokensToAdd = (int) (timePassed * refillRate / 1000);\n\n            if (tokensToAdd > 0) {\n                tokens = Math.min(capacity, tokens + tokensToAdd);\n                lastRefill = now;\n            }\n        }\n\n        public boolean tryConsume(int tokensNeeded) {\n            refill();\n            if (tokens >= tokensNeeded) {\n                tokens -= tokensNeeded;\n                return true;\n            }\n            return false;\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        TokenBucket bucket = new TokenBucket(3, 1);  // 3 capacity, 1 token/sec\n\n        // Consume all tokens\n        for (int i = 0; i < 4; i++) {\n            System.out.println(\"Request \" + (i + 1) + \": \" + bucket.tryConsume(1));\n        }\n\n        // Wait for refill\n        Thread.sleep(1100);\n        System.out.println(\"After 1s: \" + bucket.tryConsume(1));\n    }\n}",
      "expectedOutput": "Request 1: true\nRequest 2: true\nRequest 3: true\nRequest 4: false\nAfter 1s: true",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Token bucket rate limiter in Java, an essential concept for building robust and maintainable applications. Understanding Token bucket rate limiter helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Token bucket rate limiter\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Token bucket rate limiter\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Token bucket rate limiter\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Token bucket rate limiter in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Token bucket rate limiter to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Token bucket rate limiter to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Token bucket rate limiter in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Token bucket rate limiter</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Token bucket rate limiter</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Token bucket rate limiter when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Advanced",
        "Concurrency",
        "Patterns"
      ]
    },
    {
      "id": 442,
      "title": "442. Sliding window rate limiter",
      "description": "Learn how to implement sliding window rate limiting",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    static class SlidingWindowRateLimiter {\n        private final int maxRequests;\n        private final long windowMillis;\n        private final Deque<Long> requestTimes = new LinkedList<>();\n\n        public SlidingWindowRateLimiter(int maxRequests, long windowMillis) {\n            this.maxRequests = maxRequests;\n            this.windowMillis = windowMillis;\n        }\n\n        // TODO: Implement allowRequest method\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        // TODO: Create limiter (3 requests per second)\n        // TODO: Test rate limiting\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    static class SlidingWindowRateLimiter {\n        private final int maxRequests;\n        private final long windowMillis;\n        private final Deque<Long> requestTimes = new LinkedList<>();\n\n        public SlidingWindowRateLimiter(int maxRequests, long windowMillis) {\n            this.maxRequests = maxRequests;\n            this.windowMillis = windowMillis;\n        }\n\n        public boolean allowRequest() {\n            long now = System.currentTimeMillis();\n\n            // Remove requests outside window\n            while (!requestTimes.isEmpty() && now - requestTimes.peekFirst() > windowMillis) {\n                requestTimes.pollFirst();\n            }\n\n            // Check if under limit\n            if (requestTimes.size() < maxRequests) {\n                requestTimes.addLast(now);\n                return true;\n            }\n\n            return false;\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        SlidingWindowRateLimiter limiter = new SlidingWindowRateLimiter(3, 1000);\n\n        // Make requests\n        for (int i = 0; i < 4; i++) {\n            System.out.println(\"Request \" + (i + 1) + \": \" + limiter.allowRequest());\n        }\n\n        Thread.sleep(1100);\n        System.out.println(\"After 1s: \" + limiter.allowRequest());\n    }\n}",
      "expectedOutput": "Request 1: true\nRequest 2: true\nRequest 3: true\nRequest 4: false\nAfter 1s: true",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Sliding window rate limiter in Java, an essential concept for building robust and maintainable applications. Understanding Sliding window rate limiter helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Sliding window rate limiter\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Sliding window rate limiter\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Sliding window rate limiter\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Sliding window rate limiter in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Sliding window rate limiter to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Sliding window rate limiter to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Sliding window rate limiter in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Sliding window rate limiter</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Sliding window rate limiter</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Sliding window rate limiter when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Advanced",
        "Concurrency",
        "Patterns"
      ]
    },
    {
      "id": 443,
      "title": "443. Chain of Responsibility pattern",
      "description": "Learn how to implement the Chain of Responsibility pattern",
      "initialCode": "public class Main {\n    abstract static class Handler {\n        protected Handler next;\n\n        public void setNext(Handler next) {\n            this.next = next;\n        }\n\n        public abstract void handle(String request);\n    }\n\n    // TODO: Create concrete handlers\n    // TODO: Chain handlers together\n    // TODO: Process requests\n\n    public static void main(String[] args) {\n    }\n}",
      "fullSolution": "public class Main {\n    abstract static class Handler {\n        protected Handler next;\n\n        public void setNext(Handler next) {\n            this.next = next;\n        }\n\n        public abstract void handle(String request);\n    }\n\n    static class AuthHandler extends Handler {\n        public void handle(String request) {\n            if (request.contains(\"auth\")) {\n                System.out.println(\"AuthHandler: Authenticated\");\n            } else if (next != null) {\n                next.handle(request);\n            }\n        }\n    }\n\n    static class LogHandler extends Handler {\n        public void handle(String request) {\n            System.out.println(\"LogHandler: Logged request\");\n            if (next != null) {\n                next.handle(request);\n            }\n        }\n    }\n\n    static class ProcessHandler extends Handler {\n        public void handle(String request) {\n            System.out.println(\"ProcessHandler: Processed \" + request);\n        }\n    }\n\n    public static void main(String[] args) {\n        // Chain handlers together\n        Handler auth = new AuthHandler();\n        Handler log = new LogHandler();\n        Handler process = new ProcessHandler();\n\n        auth.setNext(log);\n        log.setNext(process);\n\n        // Process requests\n        auth.handle(\"auth:user123\");\n        System.out.println();\n        auth.handle(\"data:xyz\");\n    }\n}",
      "expectedOutput": "AuthHandler: Authenticated\nLogHandler: Logged request\nProcessHandler: Processed auth:user123\n\nLogHandler: Logged request\nProcessHandler: Processed data:xyz",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Chain of Responsibility pattern in Java, an essential concept for building robust and maintainable applications. Understanding Chain of Responsibility pattern helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Chain of Responsibility pattern\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Chain of Responsibility pattern\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Chain of Responsibility pattern\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Chain of Responsibility pattern in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Chain of Responsibility pattern to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Chain of Responsibility pattern to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Chain of Responsibility pattern in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Chain of Responsibility pattern</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Chain of Responsibility pattern</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Chain of Responsibility pattern when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Advanced",
        "OOP",
        "Design Patterns"
      ]
    },
    {
      "id": 444,
      "title": "444. Logging chain with multiple handlers",
      "description": "Learn how to create a logging chain using Chain of Responsibility",
      "initialCode": "public class Main {\n    enum LogLevel { INFO, WARNING, ERROR }\n\n    abstract static class Logger {\n        protected LogLevel level;\n        protected Logger next;\n\n        public Logger(LogLevel level) {\n            this.level = level;\n        }\n\n        public void setNext(Logger next) {\n            this.next = next;\n        }\n\n        // TODO: Implement log method with chain\n    }\n\n    // TODO: Create ConsoleLogger, FileLogger, ErrorLogger\n    // TODO: Chain loggers by level\n\n    public static void main(String[] args) {\n    }\n}",
      "fullSolution": "public class Main {\n    enum LogLevel { INFO, WARNING, ERROR }\n\n    abstract static class Logger {\n        protected LogLevel level;\n        protected Logger next;\n\n        public Logger(LogLevel level) {\n            this.level = level;\n        }\n\n        public void setNext(Logger next) {\n            this.next = next;\n        }\n\n        public void log(LogLevel messageLevel, String message) {\n            if (messageLevel.ordinal() >= level.ordinal()) {\n                write(message);\n            }\n            if (next != null) {\n                next.log(messageLevel, message);\n            }\n        }\n\n        protected abstract void write(String message);\n    }\n\n    static class ConsoleLogger extends Logger {\n        public ConsoleLogger(LogLevel level) {\n            super(level);\n        }\n\n        protected void write(String message) {\n            System.out.println(\"[Console] \" + message);\n        }\n    }\n\n    static class FileLogger extends Logger {\n        public FileLogger(LogLevel level) {\n            super(level);\n        }\n\n        protected void write(String message) {\n            System.out.println(\"[File] \" + message);\n        }\n    }\n\n    static class ErrorLogger extends Logger {\n        public ErrorLogger(LogLevel level) {\n            super(level);\n        }\n\n        protected void write(String message) {\n            System.err.println(\"[Error] \" + message);\n        }\n    }\n\n    public static void main(String[] args) {\n        // Chain loggers by level\n        Logger console = new ConsoleLogger(LogLevel.INFO);\n        Logger file = new FileLogger(LogLevel.WARNING);\n        Logger error = new ErrorLogger(LogLevel.ERROR);\n\n        console.setNext(file);\n        file.setNext(error);\n\n        // Test different log levels\n        console.log(LogLevel.INFO, \"Application started\");\n        console.log(LogLevel.WARNING, \"Low memory\");\n        console.log(LogLevel.ERROR, \"Database connection failed\");\n    }\n}",
      "expectedOutput": "[Console] Application started\n[Console] Low memory\n[File] Low memory\n[Console] Database connection failed\n[File] Database connection failed\n[Error] Database connection failed",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Logging chain with multiple handlers in Java, an essential concept for building robust and maintainable applications. Understanding Logging chain with multiple handlers helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Logging chain with multiple handlers\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Logging chain with multiple handlers\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Logging chain with multiple handlers\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Logging chain with multiple handlers in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Logging chain with multiple handlers to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Logging chain with multiple handlers to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Logging chain with multiple handlers in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Logging chain with multiple handlers</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Logging chain with multiple handlers</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Logging chain with multiple handlers when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Advanced",
        "OOP",
        "Design Patterns"
      ]
    },
    {
      "id": 445,
      "title": "445. Command pattern for undo/redo",
      "description": "Learn how to implement Command pattern with undo/redo",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    interface Command {\n        void execute();\n        void undo();\n    }\n\n    static class Calculator {\n        private int value = 0;\n\n        // TODO: Implement add and subtract methods\n    }\n\n    // TODO: Create AddCommand and SubtractCommand\n    // TODO: Implement undo/redo with command history\n\n    public static void main(String[] args) {\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    interface Command {\n        void execute();\n        void undo();\n    }\n\n    static class Calculator {\n        private int value = 0;\n\n        public void add(int amount) {\n            value += amount;\n        }\n\n        public void subtract(int amount) {\n            value -= amount;\n        }\n\n        public int getValue() {\n            return value;\n        }\n    }\n\n    static class AddCommand implements Command {\n        private Calculator calculator;\n        private int amount;\n\n        public AddCommand(Calculator calculator, int amount) {\n            this.calculator = calculator;\n            this.amount = amount;\n        }\n\n        public void execute() {\n            calculator.add(amount);\n        }\n\n        public void undo() {\n            calculator.subtract(amount);\n        }\n    }\n\n    static class SubtractCommand implements Command {\n        private Calculator calculator;\n        private int amount;\n\n        public SubtractCommand(Calculator calculator, int amount) {\n            this.calculator = calculator;\n            this.amount = amount;\n        }\n\n        public void execute() {\n            calculator.subtract(amount);\n        }\n\n        public void undo() {\n            calculator.add(amount);\n        }\n    }\n\n    public static void main(String[] args) {\n        Calculator calc = new Calculator();\n        Stack<Command> history = new Stack<>();\n\n        // Execute commands\n        Command add5 = new AddCommand(calc, 5);\n        add5.execute();\n        history.push(add5);\n        System.out.println(\"After +5: \" + calc.getValue());\n\n        Command sub3 = new SubtractCommand(calc, 3);\n        sub3.execute();\n        history.push(sub3);\n        System.out.println(\"After -3: \" + calc.getValue());\n\n        // Undo\n        history.pop().undo();\n        System.out.println(\"After undo: \" + calc.getValue());\n\n        history.pop().undo();\n        System.out.println(\"After undo: \" + calc.getValue());\n    }\n}",
      "expectedOutput": "After +5: 5\nAfter -3: 2\nAfter undo: 5\nAfter undo: 0",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Command pattern for undo/redo in Java, an essential concept for building robust and maintainable applications. Understanding Command pattern for undo/redo helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Command pattern for undo/redo\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Command pattern for undo/redo\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Command pattern for undo/redo\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Command pattern for undo/redo in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Command pattern for undo/redo to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Command pattern for undo/redo to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Command pattern for undo/redo in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Command pattern for undo/redo</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Command pattern for undo/redo</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Command pattern for undo/redo when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Advanced",
        "OOP",
        "Design Patterns"
      ]
    },
    {
      "id": 446,
      "title": "446. Command queue with execution",
      "description": "Learn how to use Command pattern with a queue",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    interface Command {\n        void execute();\n    }\n\n    // TODO: Create Task receiver class\n    // TODO: Create concrete commands\n    // TODO: Implement command queue executor\n\n    public static void main(String[] args) {\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    interface Command {\n        void execute();\n    }\n\n    static class Task {\n        public void print(String message) {\n            System.out.println(\"Task: \" + message);\n        }\n\n        public void save(String data) {\n            System.out.println(\"Saved: \" + data);\n        }\n    }\n\n    static class PrintCommand implements Command {\n        private Task task;\n        private String message;\n\n        public PrintCommand(Task task, String message) {\n            this.task = task;\n            this.message = message;\n        }\n\n        public void execute() {\n            task.print(message);\n        }\n    }\n\n    static class SaveCommand implements Command {\n        private Task task;\n        private String data;\n\n        public SaveCommand(Task task, String data) {\n            this.task = task;\n            this.data = data;\n        }\n\n        public void execute() {\n            task.save(data);\n        }\n    }\n\n    static class CommandQueue {\n        private Queue<Command> queue = new LinkedList<>();\n\n        public void addCommand(Command command) {\n            queue.offer(command);\n        }\n\n        public void executeAll() {\n            while (!queue.isEmpty()) {\n                Command command = queue.poll();\n                command.execute();\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Task task = new Task();\n        CommandQueue commandQueue = new CommandQueue();\n\n        // Queue commands\n        commandQueue.addCommand(new PrintCommand(task, \"Hello\"));\n        commandQueue.addCommand(new SaveCommand(task, \"data.txt\"));\n        commandQueue.addCommand(new PrintCommand(task, \"Done\"));\n\n        // Execute all\n        System.out.println(\"Executing queued commands:\");\n        commandQueue.executeAll();\n    }\n}",
      "expectedOutput": "Executing queued commands:\nTask: Hello\nSaved: data.txt\nTask: Done",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Command queue with execution in Java, an essential concept for building robust and maintainable applications. Understanding Command queue with execution helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Command queue with execution\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Command queue with execution\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Command queue with execution\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Command queue with execution in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Command queue with execution to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Command queue with execution to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Command queue with execution in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Command queue with execution</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Command queue with execution</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Command queue with execution when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Advanced",
        "OOP",
        "Design Patterns"
      ]
    },
    {
      "id": 447,
      "title": "447. State machine with enum states",
      "description": "Learn how to implement a state machine using enums",
      "initialCode": "public class Main {\n    enum State { DRAFT, PUBLISHED, ARCHIVED }\n\n    static class Document {\n        private State state = State.DRAFT;\n\n        // TODO: Implement publish method\n        // TODO: Implement archive method\n        // TODO: Add state validation\n    }\n\n    public static void main(String[] args) {\n    }\n}",
      "fullSolution": "public class Main {\n    enum State { DRAFT, PUBLISHED, ARCHIVED }\n\n    static class Document {\n        private State state = State.DRAFT;\n\n        public void publish() {\n            if (state == State.DRAFT) {\n                state = State.PUBLISHED;\n                System.out.println(\"Document published\");\n            } else {\n                System.out.println(\"Can only publish from DRAFT state\");\n            }\n        }\n\n        public void archive() {\n            if (state == State.PUBLISHED) {\n                state = State.ARCHIVED;\n                System.out.println(\"Document archived\");\n            } else {\n                System.out.println(\"Can only archive from PUBLISHED state\");\n            }\n        }\n\n        public State getState() {\n            return state;\n        }\n    }\n\n    public static void main(String[] args) {\n        Document doc = new Document();\n        System.out.println(\"Initial state: \" + doc.getState());\n\n        doc.publish();\n        System.out.println(\"State: \" + doc.getState());\n\n        doc.archive();\n        System.out.println(\"State: \" + doc.getState());\n\n        // Invalid transition\n        doc.publish();\n    }\n}",
      "expectedOutput": "Initial state: DRAFT\nDocument published\nState: PUBLISHED\nDocument archived\nState: ARCHIVED\nCan only publish from DRAFT state",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers State machine with enum states in Java, an essential concept for building robust and maintainable applications. Understanding State machine with enum states helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of State machine with enum states\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating State machine with enum states\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of State machine with enum states\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement State machine with enum states in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use State machine with enum states to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply State machine with enum states to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing State machine with enum states in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing State machine with enum states</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of State machine with enum states</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse State machine with enum states when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Advanced",
        "OOP",
        "Design Patterns"
      ]
    },
    {
      "id": 448,
      "title": "448. State pattern with behavior",
      "description": "Learn how to implement State pattern with behavior delegation",
      "initialCode": "public class Main {\n    interface State {\n        void handle(Context context);\n    }\n\n    static class Context {\n        private State state;\n\n        // TODO: Implement setState and request methods\n    }\n\n    // TODO: Create ConcreteStates\n    // TODO: Implement state-specific behavior\n\n    public static void main(String[] args) {\n    }\n}",
      "fullSolution": "public class Main {\n    interface State {\n        void handle(Context context);\n    }\n\n    static class Context {\n        private State state;\n\n        public Context(State initialState) {\n            this.state = initialState;\n        }\n\n        public void setState(State state) {\n            this.state = state;\n        }\n\n        public void request() {\n            state.handle(this);\n        }\n    }\n\n    static class StartState implements State {\n        public void handle(Context context) {\n            System.out.println(\"StartState: Transitioning to Running\");\n            context.setState(new RunningState());\n        }\n    }\n\n    static class RunningState implements State {\n        public void handle(Context context) {\n            System.out.println(\"RunningState: Transitioning to Stop\");\n            context.setState(new StopState());\n        }\n    }\n\n    static class StopState implements State {\n        public void handle(Context context) {\n            System.out.println(\"StopState: Already stopped\");\n        }\n    }\n\n    public static void main(String[] args) {\n        Context context = new Context(new StartState());\n\n        context.request();\n        context.request();\n        context.request();\n    }\n}",
      "expectedOutput": "StartState: Transitioning to Running\nRunningState: Transitioning to Stop\nStopState: Already stopped",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers State pattern with behavior in Java, an essential concept for building robust and maintainable applications. Understanding State pattern with behavior helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of State pattern with behavior\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating State pattern with behavior\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of State pattern with behavior\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement State pattern with behavior in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use State pattern with behavior to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply State pattern with behavior to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing State pattern with behavior in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing State pattern with behavior</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of State pattern with behavior</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse State pattern with behavior when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Advanced",
        "OOP",
        "Design Patterns"
      ]
    },
    {
      "id": 449,
      "title": "449. Fluent builder with validation",
      "description": "Learn how to create fluent builders with validation",
      "initialCode": "public class Main {\n    static class User {\n        private String name;\n        private int age;\n        private String email;\n\n        private User() {}\n\n        // TODO: Create Builder class\n        // TODO: Implement fluent methods\n        // TODO: Add validation in build()\n    }\n\n    public static void main(String[] args) {\n    }\n}",
      "fullSolution": "public class Main {\n    static class User {\n        private String name;\n        private int age;\n        private String email;\n\n        private User() {}\n\n        public static Builder builder() {\n            return new Builder();\n        }\n\n        static class Builder {\n            private String name;\n            private int age;\n            private String email;\n\n            public Builder name(String name) {\n                this.name = name;\n                return this;\n            }\n\n            public Builder age(int age) {\n                this.age = age;\n                return this;\n            }\n\n            public Builder email(String email) {\n                this.email = email;\n                return this;\n            }\n\n            public User build() {\n                // Validation\n                if (name == null || name.isEmpty()) {\n                    throw new IllegalStateException(\"Name is required\");\n                }\n                if (age < 0 || age > 150) {\n                    throw new IllegalStateException(\"Invalid age\");\n                }\n\n                User user = new User();\n                user.name = this.name;\n                user.age = this.age;\n                user.email = this.email;\n                return user;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"User{name='\" + name + \"', age=\" + age + \", email='\" + email + \"'}\";\n        }\n    }\n\n    public static void main(String[] args) {\n        User user = User.builder()\n            .name(\"Alice\")\n            .age(30)\n            .email(\"alice@example.com\")\n            .build();\n\n        System.out.println(user);\n\n        // Invalid user\n        try {\n            User.builder().age(200).build();\n        } catch (IllegalStateException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
      "expectedOutput": "User{name='Alice', age=30, email='alice@example.com'}\nError: Name is required",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Fluent builder with validation in Java, an essential concept for building robust and maintainable applications. Understanding Fluent builder with validation helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Fluent builder with validation\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Fluent builder with validation\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Fluent builder with validation\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Fluent builder with validation in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Fluent builder with validation to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Fluent builder with validation to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Fluent builder with validation in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Fluent builder with validation</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Fluent builder with validation</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Fluent builder with validation when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Intermediate",
        "OOP",
        "Design Patterns"
      ]
    },
    {
      "id": 450,
      "title": "450. Builder with nested builders",
      "description": "Learn how to create builders for nested objects",
      "initialCode": "public class Main {\n    static class Address {\n        private String street;\n        private String city;\n\n        // TODO: Create Address.Builder\n    }\n\n    static class Person {\n        private String name;\n        private Address address;\n\n        // TODO: Create Person.Builder\n        // TODO: Support nested Address.Builder\n    }\n\n    public static void main(String[] args) {\n    }\n}",
      "fullSolution": "public class Main {\n    static class Address {\n        private String street;\n        private String city;\n\n        private Address() {}\n\n        static class Builder {\n            private String street;\n            private String city;\n\n            public Builder street(String street) {\n                this.street = street;\n                return this;\n            }\n\n            public Builder city(String city) {\n                this.city = city;\n                return this;\n            }\n\n            public Address build() {\n                Address addr = new Address();\n                addr.street = this.street;\n                addr.city = this.city;\n                return addr;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return street + \", \" + city;\n        }\n    }\n\n    static class Person {\n        private String name;\n        private Address address;\n\n        private Person() {}\n\n        public static Builder builder() {\n            return new Builder();\n        }\n\n        static class Builder {\n            private String name;\n            private Address.Builder addressBuilder = new Address.Builder();\n\n            public Builder name(String name) {\n                this.name = name;\n                return this;\n            }\n\n            public Builder street(String street) {\n                addressBuilder.street(street);\n                return this;\n            }\n\n            public Builder city(String city) {\n                addressBuilder.city(city);\n                return this;\n            }\n\n            public Person build() {\n                Person person = new Person();\n                person.name = this.name;\n                person.address = addressBuilder.build();\n                return person;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"Person{name='\" + name + \"', address=\" + address + \"}\";\n        }\n    }\n\n    public static void main(String[] args) {\n        Person person = Person.builder()\n            .name(\"Alice\")\n            .street(\"123 Main St\")\n            .city(\"New York\")\n            .build();\n\n        System.out.println(person);\n    }\n}",
      "expectedOutput": "Person{name='Alice', address=123 Main St, New York}",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Builder with nested builders in Java, an essential concept for building robust and maintainable applications. Understanding Builder with nested builders helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Builder with nested builders\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Builder with nested builders\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Builder with nested builders\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Builder with nested builders in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Builder with nested builders to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Builder with nested builders to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Builder with nested builders in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Builder with nested builders</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Builder with nested builders</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Builder with nested builders when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Advanced",
        "OOP",
        "Design Patterns"
      ]
    },
    {
      "id": 451,
      "title": "451. Observer pattern with listeners",
      "description": "Learn how to implement the Observer pattern for event handling",
      "initialCode": "import java.util.*;\n\npublic class Main {\n    interface Observer {\n        void update(String message);\n    }\n\n    static class Subject {\n        private List<Observer> observers = new ArrayList<>();\n\n        // TODO: Implement attach, detach, notify methods\n    }\n\n    // TODO: Create concrete observer\n    // TODO: Test observer pattern\n\n    public static void main(String[] args) {\n    }\n}",
      "fullSolution": "import java.util.*;\n\npublic class Main {\n    interface Observer {\n        void update(String message);\n    }\n\n    static class Subject {\n        private List<Observer> observers = new ArrayList<>();\n\n        public void attach(Observer observer) {\n            observers.add(observer);\n        }\n\n        public void detach(Observer observer) {\n            observers.remove(observer);\n        }\n\n        public void notifyObservers(String message) {\n            for (Observer observer : observers) {\n                observer.update(message);\n            }\n        }\n    }\n\n    static class EmailNotifier implements Observer {\n        private String name;\n\n        public EmailNotifier(String name) {\n            this.name = name;\n        }\n\n        public void update(String message) {\n            System.out.println(name + \" received email: \" + message);\n        }\n    }\n\n    static class SMSNotifier implements Observer {\n        private String name;\n\n        public SMSNotifier(String name) {\n            this.name = name;\n        }\n\n        public void update(String message) {\n            System.out.println(name + \" received SMS: \" + message);\n        }\n    }\n\n    public static void main(String[] args) {\n        Subject subject = new Subject();\n\n        Observer email = new EmailNotifier(\"Alice\");\n        Observer sms = new SMSNotifier(\"Bob\");\n\n        subject.attach(email);\n        subject.attach(sms);\n\n        subject.notifyObservers(\"New message available\");\n\n        subject.detach(email);\n        subject.notifyObservers(\"Another update\");\n    }\n}",
      "expectedOutput": "Alice received email: New message available\nBob received SMS: New message available\nBob received SMS: Another update",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Observer pattern with listeners in Java, an essential concept for building robust and maintainable applications. Understanding Observer pattern with listeners helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Observer pattern with listeners\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Observer pattern with listeners\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Observer pattern with listeners\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Observer pattern with listeners in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Observer pattern with listeners to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Observer pattern with listeners to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Observer pattern with listeners in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Observer pattern with listeners</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Observer pattern with listeners</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Observer pattern with listeners when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Advanced",
        "OOP",
        "Design Patterns"
      ]
    },
    {
      "id": 452,
      "title": "452. Event-driven system with typed events",
      "description": "Learn how to create a typed event system",
      "initialCode": "import java.util.*;\nimport java.util.function.Consumer;\n\npublic class Main {\n    static class Event {\n        private final String type;\n        private final Object data;\n\n        public Event(String type, Object data) {\n            this.type = type;\n            this.data = data;\n        }\n\n        public String getType() { return type; }\n        public Object getData() { return data; }\n    }\n\n    static class EventBus {\n        private Map<String, List<Consumer<Event>>> listeners = new HashMap<>();\n\n        // TODO: Implement on, emit, off methods\n    }\n\n    public static void main(String[] args) {\n    }\n}",
      "fullSolution": "import java.util.*;\nimport java.util.function.Consumer;\n\npublic class Main {\n    static class Event {\n        private final String type;\n        private final Object data;\n\n        public Event(String type, Object data) {\n            this.type = type;\n            this.data = data;\n        }\n\n        public String getType() { return type; }\n        public Object getData() { return data; }\n    }\n\n    static class EventBus {\n        private Map<String, List<Consumer<Event>>> listeners = new HashMap<>();\n\n        public void on(String eventType, Consumer<Event> listener) {\n            listeners.computeIfAbsent(eventType, k -> new ArrayList<>()).add(listener);\n        }\n\n        public void emit(Event event) {\n            List<Consumer<Event>> eventListeners = listeners.get(event.getType());\n            if (eventListeners != null) {\n                for (Consumer<Event> listener : eventListeners) {\n                    listener.accept(event);\n                }\n            }\n        }\n\n        public void off(String eventType, Consumer<Event> listener) {\n            List<Consumer<Event>> eventListeners = listeners.get(eventType);\n            if (eventListeners != null) {\n                eventListeners.remove(listener);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        EventBus bus = new EventBus();\n\n        // Register listeners\n        bus.on(\"user.login\", event -> {\n            System.out.println(\"User logged in: \" + event.getData());\n        });\n\n        bus.on(\"user.logout\", event -> {\n            System.out.println(\"User logged out: \" + event.getData());\n        });\n\n        // Emit events\n        bus.emit(new Event(\"user.login\", \"alice\"));\n        bus.emit(new Event(\"user.logout\", \"alice\"));\n        bus.emit(new Event(\"unknown\", \"ignored\"));\n    }\n}",
      "expectedOutput": "User logged in: alice\nUser logged out: alice",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Event-driven system with typed events in Java, an essential concept for building robust and maintainable applications. Understanding Event-driven system with typed events helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Event-driven system with typed events\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Event-driven system with typed events\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Event-driven system with typed events\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Event-driven system with typed events in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Event-driven system with typed events to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Event-driven system with typed events to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Event-driven system with typed events in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Event-driven system with typed events</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Event-driven system with typed events</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Event-driven system with typed events when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Advanced",
        "OOP",
        "Design Patterns"
      ]
    },
    {
      "id": 453,
      "title": "453. Dependency Injection - Constructor Injection",
      "description": "Implement a constructor-based dependency injection pattern where dependencies are provided through the constructor.",
      "initialCode": "public class Main {\n    // TODO: Create a Logger interface with a log(String message) method\n\n    // TODO: Create ConsoleLogger class implementing Logger\n\n    // TODO: Create UserService class that takes Logger in constructor\n\n    public static void main(String[] args) {\n        // TODO: Create a ConsoleLogger instance\n        // TODO: Inject it into UserService via constructor\n        // TODO: Call registerUser(\"Alice\") on the service\n    }\n}",
      "fullSolution": "public class Main {\n    interface Logger {\n        void log(String message);\n    }\n\n    static class ConsoleLogger implements Logger {\n        public void log(String message) {\n            System.out.println(\"[LOG] \" + message);\n        }\n    }\n\n    static class UserService {\n        private final Logger logger;\n\n        public UserService(Logger logger) {\n            this.logger = logger;\n        }\n\n        public void registerUser(String username) {\n            logger.log(\"Registering user: \" + username);\n        }\n    }\n\n    public static void main(String[] args) {\n        Logger logger = new ConsoleLogger();\n        UserService service = new UserService(logger);\n        service.registerUser(\"Alice\");\n    }\n}",
      "expectedOutput": "[LOG] Registering user: Alice",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Dependency Injection - Constructor Injection in Java, an essential concept for building robust and maintainable applications. Understanding Dependency Injection - Constructor Injection helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Dependency Injection - Constructor Injection\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Dependency Injection - Constructor Injection\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Dependency Injection - Constructor Injection\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Dependency Injection - Constructor Injection in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Dependency Injection - Constructor Injection to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Dependency Injection - Constructor Injection to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Dependency Injection - Constructor Injection in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Dependency Injection - Constructor Injection</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Dependency Injection - Constructor Injection</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Dependency Injection - Constructor Injection when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Design Patterns",
        "OOP",
        "Best Practices"
      ]
    },
    {
      "id": 454,
      "title": "454. Dependency Injection - Setter Injection",
      "description": "Implement setter-based dependency injection where dependencies can be set after object creation.",
      "initialCode": "public class Main {\n    // TODO: Create Database interface with query(String sql) method\n\n    // TODO: Create MockDatabase implementing Database\n\n    // TODO: Create Repository class with setDatabase(Database db) setter\n\n    public static void main(String[] args) {\n        // TODO: Create Repository instance\n        // TODO: Inject MockDatabase using setter\n        // TODO: Call findUser() method\n    }\n}",
      "fullSolution": "public class Main {\n    interface Database {\n        String query(String sql);\n    }\n\n    static class MockDatabase implements Database {\n        public String query(String sql) {\n            return \"Mock result for: \" + sql;\n        }\n    }\n\n    static class Repository {\n        private Database database;\n\n        public void setDatabase(Database database) {\n            this.database = database;\n        }\n\n        public void findUser() {\n            String result = database.query(\"SELECT * FROM users\");\n            System.out.println(result);\n        }\n    }\n\n    public static void main(String[] args) {\n        Repository repo = new Repository();\n        repo.setDatabase(new MockDatabase());\n        repo.findUser();\n    }\n}",
      "expectedOutput": "Mock result for: SELECT * FROM users",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Dependency Injection - Setter Injection in Java, an essential concept for building robust and maintainable applications. Understanding Dependency Injection - Setter Injection helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Dependency Injection - Setter Injection\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Dependency Injection - Setter Injection\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Dependency Injection - Setter Injection\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Dependency Injection - Setter Injection in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Dependency Injection - Setter Injection to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Dependency Injection - Setter Injection to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Dependency Injection - Setter Injection in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Dependency Injection - Setter Injection</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Dependency Injection - Setter Injection</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Dependency Injection - Setter Injection when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Design Patterns",
        "OOP",
        "Best Practices"
      ]
    },
    {
      "id": 455,
      "title": "455. Factory Method - Product Creation",
      "description": "Implement the Factory Method pattern to create different types of products without specifying their concrete classes.",
      "initialCode": "public class Main {\n    // TODO: Create Animal interface with speak() method\n\n    // TODO: Create Dog and Cat classes implementing Animal\n\n    // TODO: Create AnimalFactory with static createAnimal(String type) method\n\n    public static void main(String[] args) {\n        // TODO: Use factory to create a dog and call speak()\n        // TODO: Use factory to create a cat and call speak()\n    }\n}",
      "fullSolution": "public class Main {\n    interface Animal {\n        void speak();\n    }\n\n    static class Dog implements Animal {\n        public void speak() {\n            System.out.println(\"Woof!\");\n        }\n    }\n\n    static class Cat implements Animal {\n        public void speak() {\n            System.out.println(\"Meow!\");\n        }\n    }\n\n    static class AnimalFactory {\n        public static Animal createAnimal(String type) {\n            if (type.equals(\"dog\")) {\n                return new Dog();\n            } else if (type.equals(\"cat\")) {\n                return new Cat();\n            }\n            throw new IllegalArgumentException(\"Unknown type\");\n        }\n    }\n\n    public static void main(String[] args) {\n        Animal dog = AnimalFactory.createAnimal(\"dog\");\n        dog.speak();\n        Animal cat = AnimalFactory.createAnimal(\"cat\");\n        cat.speak();\n    }\n}",
      "expectedOutput": "Woof!\nMeow!",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Factory Method - Product Creation in Java, an essential concept for building robust and maintainable applications. Understanding Factory Method - Product Creation helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Factory Method - Product Creation\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Factory Method - Product Creation\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Factory Method - Product Creation\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Factory Method - Product Creation in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Factory Method - Product Creation to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Factory Method - Product Creation to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Factory Method - Product Creation in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Factory Method - Product Creation</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Factory Method - Product Creation</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Factory Method - Product Creation when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Design Patterns",
        "OOP",
        "Creational Patterns"
      ]
    },
    {
      "id": 456,
      "title": "456. Factory Method - Parameterized Factories",
      "description": "Create a parameterized factory that uses configuration to determine which object to create.",
      "initialCode": "public class Main {\n    // TODO: Create Vehicle interface with drive() method\n\n    // TODO: Create Car and Bike classes implementing Vehicle\n\n    // TODO: Create VehicleFactory with createVehicle(int wheels) method\n\n    public static void main(String[] args) {\n        // TODO: Create vehicle with 4 wheels and call drive()\n        // TODO: Create vehicle with 2 wheels and call drive()\n    }\n}",
      "fullSolution": "public class Main {\n    interface Vehicle {\n        void drive();\n    }\n\n    static class Car implements Vehicle {\n        public void drive() {\n            System.out.println(\"Driving a car\");\n        }\n    }\n\n    static class Bike implements Vehicle {\n        public void drive() {\n            System.out.println(\"Riding a bike\");\n        }\n    }\n\n    static class VehicleFactory {\n        public static Vehicle createVehicle(int wheels) {\n            if (wheels == 4) {\n                return new Car();\n            } else if (wheels == 2) {\n                return new Bike();\n            }\n            throw new IllegalArgumentException(\"Invalid wheels\");\n        }\n    }\n\n    public static void main(String[] args) {\n        Vehicle car = VehicleFactory.createVehicle(4);\n        car.drive();\n        Vehicle bike = VehicleFactory.createVehicle(2);\n        bike.drive();\n    }\n}",
      "expectedOutput": "Driving a car\nRiding a bike",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Factory Method - Parameterized Factories in Java, an essential concept for building robust and maintainable applications. Understanding Factory Method - Parameterized Factories helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Factory Method - Parameterized Factories\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Factory Method - Parameterized Factories\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Factory Method - Parameterized Factories\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Factory Method - Parameterized Factories in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Factory Method - Parameterized Factories to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Factory Method - Parameterized Factories to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Factory Method - Parameterized Factories in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Factory Method - Parameterized Factories</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Factory Method - Parameterized Factories</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Factory Method - Parameterized Factories when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Design Patterns",
        "OOP",
        "Creational Patterns"
      ]
    },
    {
      "id": 457,
      "title": "457. Abstract Factory - Family of Products",
      "description": "Implement Abstract Factory pattern to create families of related objects without specifying concrete classes.",
      "initialCode": "public class Main {\n    // TODO: Create Button and Checkbox interfaces\n\n    // TODO: Create WindowsButton, WindowsCheckbox classes\n\n    // TODO: Create GUIFactory interface with createButton() and createCheckbox()\n\n    // TODO: Create WindowsFactory implementing GUIFactory\n\n    public static void main(String[] args) {\n        // TODO: Create WindowsFactory and use it to create button and checkbox\n        // TODO: Call render() on both\n    }\n}",
      "fullSolution": "public class Main {\n    interface Button {\n        void render();\n    }\n\n    interface Checkbox {\n        void render();\n    }\n\n    static class WindowsButton implements Button {\n        public void render() {\n            System.out.println(\"Windows Button\");\n        }\n    }\n\n    static class WindowsCheckbox implements Checkbox {\n        public void render() {\n            System.out.println(\"Windows Checkbox\");\n        }\n    }\n\n    interface GUIFactory {\n        Button createButton();\n        Checkbox createCheckbox();\n    }\n\n    static class WindowsFactory implements GUIFactory {\n        public Button createButton() {\n            return new WindowsButton();\n        }\n        public Checkbox createCheckbox() {\n            return new WindowsCheckbox();\n        }\n    }\n\n    public static void main(String[] args) {\n        GUIFactory factory = new WindowsFactory();\n        Button btn = factory.createButton();\n        btn.render();\n        Checkbox chk = factory.createCheckbox();\n        chk.render();\n    }\n}",
      "expectedOutput": "Windows Button\nWindows Checkbox",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Abstract Factory - Family of Products in Java, an essential concept for building robust and maintainable applications. Understanding Abstract Factory - Family of Products helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Abstract Factory - Family of Products\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Abstract Factory - Family of Products\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Abstract Factory - Family of Products\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Abstract Factory - Family of Products in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Abstract Factory - Family of Products to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Abstract Factory - Family of Products to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Abstract Factory - Family of Products in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Abstract Factory - Family of Products</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Abstract Factory - Family of Products</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Abstract Factory - Family of Products when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Design Patterns",
        "OOP",
        "Creational Patterns"
      ]
    },
    {
      "id": 458,
      "title": "458. Abstract Factory - Multiple Families",
      "description": "Extend Abstract Factory to support multiple product families with consistent interfaces.",
      "initialCode": "public class Main {\n    // TODO: Create Theme interface with getColor() method\n\n    // TODO: Create DarkTheme and LightTheme classes\n\n    // TODO: Create ThemeFactory interface with createTheme() method\n\n    // TODO: Create DarkThemeFactory and LightThemeFactory\n\n    public static void main(String[] args) {\n        // TODO: Use DarkThemeFactory to create and print dark theme color\n        // TODO: Use LightThemeFactory to create and print light theme color\n    }\n}",
      "fullSolution": "public class Main {\n    interface Theme {\n        String getColor();\n    }\n\n    static class DarkTheme implements Theme {\n        public String getColor() {\n            return \"Dark: #000000\";\n        }\n    }\n\n    static class LightTheme implements Theme {\n        public String getColor() {\n            return \"Light: #FFFFFF\";\n        }\n    }\n\n    interface ThemeFactory {\n        Theme createTheme();\n    }\n\n    static class DarkThemeFactory implements ThemeFactory {\n        public Theme createTheme() {\n            return new DarkTheme();\n        }\n    }\n\n    static class LightThemeFactory implements ThemeFactory {\n        public Theme createTheme() {\n            return new LightTheme();\n        }\n    }\n\n    public static void main(String[] args) {\n        ThemeFactory darkFactory = new DarkThemeFactory();\n        System.out.println(darkFactory.createTheme().getColor());\n\n        ThemeFactory lightFactory = new LightThemeFactory();\n        System.out.println(lightFactory.createTheme().getColor());\n    }\n}",
      "expectedOutput": "Dark: #000000\nLight: #FFFFFF",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Abstract Factory - Multiple Families in Java, an essential concept for building robust and maintainable applications. Understanding Abstract Factory - Multiple Families helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Abstract Factory - Multiple Families\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Abstract Factory - Multiple Families\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Abstract Factory - Multiple Families\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Abstract Factory - Multiple Families in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Abstract Factory - Multiple Families to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Abstract Factory - Multiple Families to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Abstract Factory - Multiple Families in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Abstract Factory - Multiple Families</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Abstract Factory - Multiple Families</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Abstract Factory - Multiple Families when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Design Patterns",
        "OOP",
        "Creational Patterns"
      ]
    },
    {
      "id": 459,
      "title": "459. Singleton - Thread-Safe Implementation",
      "description": "Implement a thread-safe Singleton pattern using synchronized lazy initialization.",
      "initialCode": "public class Main {\n    // TODO: Create ConfigManager singleton class\n    // TODO: Add private static volatile instance variable\n    // TODO: Add private constructor\n    // TODO: Add synchronized getInstance() method\n    // TODO: Add getSetting(String key) method that returns \"value_\" + key\n\n    public static void main(String[] args) {\n        // TODO: Get singleton instance and call getSetting(\"db_host\")\n    }\n}",
      "fullSolution": "public class Main {\n    static class ConfigManager {\n        private static volatile ConfigManager instance;\n\n        private ConfigManager() {}\n\n        public static synchronized ConfigManager getInstance() {\n            if (instance == null) {\n                instance = new ConfigManager();\n            }\n            return instance;\n        }\n\n        public String getSetting(String key) {\n            return \"value_\" + key;\n        }\n    }\n\n    public static void main(String[] args) {\n        ConfigManager config = ConfigManager.getInstance();\n        System.out.println(config.getSetting(\"db_host\"));\n    }\n}",
      "expectedOutput": "value_db_host",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Singleton - Thread-Safe Implementation in Java, an essential concept for building robust and maintainable applications. Understanding Singleton - Thread-Safe Implementation helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Singleton - Thread-Safe Implementation\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Singleton - Thread-Safe Implementation\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Singleton - Thread-Safe Implementation\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Singleton - Thread-Safe Implementation in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Singleton - Thread-Safe Implementation to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Singleton - Thread-Safe Implementation to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Singleton - Thread-Safe Implementation in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Singleton - Thread-Safe Implementation</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Singleton - Thread-Safe Implementation</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Singleton - Thread-Safe Implementation when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Design Patterns",
        "Concurrency",
        "Creational Patterns"
      ]
    },
    {
      "id": 460,
      "title": "460. Singleton - Double-Checked Locking",
      "description": "Implement Singleton with double-checked locking for better performance in multi-threaded scenarios.",
      "initialCode": "public class Main {\n    // TODO: Create Logger singleton with double-checked locking\n    // TODO: Add private static volatile instance\n    // TODO: Add private constructor\n    // TODO: Add getInstance() with double-checked locking pattern\n    // TODO: Add log(String msg) method\n\n    public static void main(String[] args) {\n        // TODO: Get instance and log \"Application started\"\n    }\n}",
      "fullSolution": "public class Main {\n    static class Logger {\n        private static volatile Logger instance;\n\n        private Logger() {}\n\n        public static Logger getInstance() {\n            if (instance == null) {\n                synchronized (Logger.class) {\n                    if (instance == null) {\n                        instance = new Logger();\n                    }\n                }\n            }\n            return instance;\n        }\n\n        public void log(String msg) {\n            System.out.println(\"[LOG] \" + msg);\n        }\n    }\n\n    public static void main(String[] args) {\n        Logger logger = Logger.getInstance();\n        logger.log(\"Application started\");\n    }\n}",
      "expectedOutput": "[LOG] Application started",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Singleton - Double-Checked Locking in Java, an essential concept for building robust and maintainable applications. Understanding Singleton - Double-Checked Locking helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Singleton - Double-Checked Locking\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Singleton - Double-Checked Locking\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Singleton - Double-Checked Locking\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Singleton - Double-Checked Locking in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Singleton - Double-Checked Locking to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Singleton - Double-Checked Locking to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Singleton - Double-Checked Locking in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Singleton - Double-Checked Locking</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Singleton - Double-Checked Locking</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Singleton - Double-Checked Locking when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Design Patterns",
        "Concurrency",
        "Creational Patterns"
      ]
    },
    {
      "id": 461,
      "title": "461. Prototype - Cloning Objects",
      "description": "Implement the Prototype pattern to create new objects by cloning existing instances.",
      "initialCode": "public class Main {\n    // TODO: Create Document class with String content field\n    // TODO: Add constructor and clone() method\n    // TODO: Add getContent() and setContent() methods\n\n    public static void main(String[] args) {\n        // TODO: Create original document with \"Original\"\n        // TODO: Clone it and set cloned content to \"Cloned\"\n        // TODO: Print both contents\n    }\n}",
      "fullSolution": "public class Main {\n    static class Document {\n        private String content;\n\n        public Document(String content) {\n            this.content = content;\n        }\n\n        public Document clone() {\n            return new Document(this.content);\n        }\n\n        public String getContent() {\n            return content;\n        }\n\n        public void setContent(String content) {\n            this.content = content;\n        }\n    }\n\n    public static void main(String[] args) {\n        Document original = new Document(\"Original\");\n        Document cloned = original.clone();\n        cloned.setContent(\"Cloned\");\n\n        System.out.println(original.getContent());\n        System.out.println(cloned.getContent());\n    }\n}",
      "expectedOutput": "Original\nCloned",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Prototype - Cloning Objects in Java, an essential concept for building robust and maintainable applications. Understanding Prototype - Cloning Objects helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Prototype - Cloning Objects\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Prototype - Cloning Objects\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Prototype - Cloning Objects\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Prototype - Cloning Objects in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Prototype - Cloning Objects to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Prototype - Cloning Objects to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Prototype - Cloning Objects in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Prototype - Cloning Objects</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Prototype - Cloning Objects</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Prototype - Cloning Objects when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Design Patterns",
        "OOP",
        "Creational Patterns"
      ]
    },
    {
      "id": 462,
      "title": "462. Prototype - Deep vs Shallow Copy",
      "description": "Understand the difference between shallow and deep copying when cloning objects with nested structures.",
      "initialCode": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    // TODO: Create Team class with List<String> members\n    // TODO: Add shallowCopy() and deepCopy() methods\n    // TODO: Add addMember(String name) method\n\n    public static void main(String[] args) {\n        // TODO: Create team with member \"Alice\"\n        // TODO: Deep copy it and add \"Bob\" to copy\n        // TODO: Print both team sizes\n    }\n}",
      "fullSolution": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    static class Team {\n        private List<String> members;\n\n        public Team() {\n            this.members = new ArrayList<>();\n        }\n\n        public Team shallowCopy() {\n            Team copy = new Team();\n            copy.members = this.members;\n            return copy;\n        }\n\n        public Team deepCopy() {\n            Team copy = new Team();\n            copy.members = new ArrayList<>(this.members);\n            return copy;\n        }\n\n        public void addMember(String name) {\n            members.add(name);\n        }\n\n        public int getSize() {\n            return members.size();\n        }\n    }\n\n    public static void main(String[] args) {\n        Team original = new Team();\n        original.addMember(\"Alice\");\n\n        Team copy = original.deepCopy();\n        copy.addMember(\"Bob\");\n\n        System.out.println(original.getSize());\n        System.out.println(copy.getSize());\n    }\n}",
      "expectedOutput": "1\n2",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Prototype - Deep vs Shallow Copy in Java, an essential concept for building robust and maintainable applications. Understanding Prototype - Deep vs Shallow Copy helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Prototype - Deep vs Shallow Copy\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Prototype - Deep vs Shallow Copy\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Prototype - Deep vs Shallow Copy\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Prototype - Deep vs Shallow Copy in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Prototype - Deep vs Shallow Copy to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Prototype - Deep vs Shallow Copy to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Prototype - Deep vs Shallow Copy in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Prototype - Deep vs Shallow Copy</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Prototype - Deep vs Shallow Copy</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Prototype - Deep vs Shallow Copy when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Design Patterns",
        "OOP",
        "Creational Patterns"
      ]
    },
    {
      "id": 463,
      "title": "463. Adapter - Class Adapter",
      "description": "Implement the Adapter pattern to make incompatible interfaces work together using inheritance.",
      "initialCode": "public class Main {\n    // TODO: Create MediaPlayer interface with play(String filename) method\n\n    // TODO: Create LegacyAudioPlayer with playAudio(String file) method\n\n    // TODO: Create AudioAdapter extending LegacyAudioPlayer and implementing MediaPlayer\n\n    public static void main(String[] args) {\n        // TODO: Create adapter and call play(\"song.mp3\")\n    }\n}",
      "fullSolution": "public class Main {\n    interface MediaPlayer {\n        void play(String filename);\n    }\n\n    static class LegacyAudioPlayer {\n        public void playAudio(String file) {\n            System.out.println(\"Playing: \" + file);\n        }\n    }\n\n    static class AudioAdapter extends LegacyAudioPlayer implements MediaPlayer {\n        public void play(String filename) {\n            playAudio(filename);\n        }\n    }\n\n    public static void main(String[] args) {\n        MediaPlayer player = new AudioAdapter();\n        player.play(\"song.mp3\");\n    }\n}",
      "expectedOutput": "Playing: song.mp3",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Adapter - Class Adapter in Java, an essential concept for building robust and maintainable applications. Understanding Adapter - Class Adapter helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Adapter - Class Adapter\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Adapter - Class Adapter\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Adapter - Class Adapter\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Adapter - Class Adapter in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Adapter - Class Adapter to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Adapter - Class Adapter to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Adapter - Class Adapter in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Adapter - Class Adapter</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Adapter - Class Adapter</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Adapter - Class Adapter when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Design Patterns",
        "OOP",
        "Structural Patterns"
      ]
    },
    {
      "id": 464,
      "title": "464. Adapter - Object Adapter",
      "description": "Implement the Adapter pattern using composition instead of inheritance for greater flexibility.",
      "initialCode": "public class Main {\n    // TODO: Create Printer interface with print(String text) method\n\n    // TODO: Create LegacyPrinter with printDocument(String doc) method\n\n    // TODO: Create PrinterAdapter using composition to wrap LegacyPrinter\n\n    public static void main(String[] args) {\n        // TODO: Create LegacyPrinter\n        // TODO: Wrap it in adapter and call print(\"Hello\")\n    }\n}",
      "fullSolution": "public class Main {\n    interface Printer {\n        void print(String text);\n    }\n\n    static class LegacyPrinter {\n        public void printDocument(String doc) {\n            System.out.println(\"Document: \" + doc);\n        }\n    }\n\n    static class PrinterAdapter implements Printer {\n        private LegacyPrinter legacyPrinter;\n\n        public PrinterAdapter(LegacyPrinter legacyPrinter) {\n            this.legacyPrinter = legacyPrinter;\n        }\n\n        public void print(String text) {\n            legacyPrinter.printDocument(text);\n        }\n    }\n\n    public static void main(String[] args) {\n        LegacyPrinter legacy = new LegacyPrinter();\n        Printer printer = new PrinterAdapter(legacy);\n        printer.print(\"Hello\");\n    }\n}",
      "expectedOutput": "Document: Hello",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Adapter - Object Adapter in Java, an essential concept for building robust and maintainable applications. Understanding Adapter - Object Adapter helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Adapter - Object Adapter\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Adapter - Object Adapter\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Adapter - Object Adapter\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Adapter - Object Adapter in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Adapter - Object Adapter to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Adapter - Object Adapter to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Adapter - Object Adapter in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Adapter - Object Adapter</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Adapter - Object Adapter</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Adapter - Object Adapter when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Design Patterns",
        "OOP",
        "Structural Patterns"
      ]
    },
    {
      "id": 465,
      "title": "465. Decorator - Dynamic Behavior",
      "description": "Implement the Decorator pattern to add behavior to objects dynamically without modifying their structure.",
      "initialCode": "public class Main {\n    // TODO: Create Coffee interface with getCost() and getDescription() methods\n\n    // TODO: Create SimpleCoffee implementing Coffee\n\n    // TODO: Create MilkDecorator wrapping Coffee and adding functionality\n\n    public static void main(String[] args) {\n        // TODO: Create SimpleCoffee, wrap with MilkDecorator\n        // TODO: Print description and cost\n    }\n}",
      "fullSolution": "public class Main {\n    interface Coffee {\n        double getCost();\n        String getDescription();\n    }\n\n    static class SimpleCoffee implements Coffee {\n        public double getCost() {\n            return 2.0;\n        }\n        public String getDescription() {\n            return \"Simple coffee\";\n        }\n    }\n\n    static class MilkDecorator implements Coffee {\n        private Coffee coffee;\n\n        public MilkDecorator(Coffee coffee) {\n            this.coffee = coffee;\n        }\n\n        public double getCost() {\n            return coffee.getCost() + 0.5;\n        }\n\n        public String getDescription() {\n            return coffee.getDescription() + \" + milk\";\n        }\n    }\n\n    public static void main(String[] args) {\n        Coffee coffee = new SimpleCoffee();\n        coffee = new MilkDecorator(coffee);\n        System.out.println(coffee.getDescription() + \": $\" + coffee.getCost());\n    }\n}",
      "expectedOutput": "Simple coffee + milk: $2.5",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Decorator - Dynamic Behavior in Java, an essential concept for building robust and maintainable applications. Understanding Decorator - Dynamic Behavior helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Decorator - Dynamic Behavior\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Decorator - Dynamic Behavior\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Decorator - Dynamic Behavior\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Decorator - Dynamic Behavior in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Decorator - Dynamic Behavior to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Decorator - Dynamic Behavior to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Decorator - Dynamic Behavior in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Decorator - Dynamic Behavior</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Decorator - Dynamic Behavior</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Decorator - Dynamic Behavior when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Design Patterns",
        "OOP",
        "Structural Patterns"
      ]
    },
    {
      "id": 466,
      "title": "466. Decorator - Wrapper Chains",
      "description": "Chain multiple decorators to combine behaviors dynamically at runtime.",
      "initialCode": "public class Main {\n    // TODO: Create Message interface with getContent() method\n\n    // TODO: Create TextMessage implementing Message\n\n    // TODO: Create EncryptDecorator and CompressDecorator\n\n    public static void main(String[] args) {\n        // TODO: Create TextMessage, wrap with both decorators\n        // TODO: Print final content\n    }\n}",
      "fullSolution": "public class Main {\n    interface Message {\n        String getContent();\n    }\n\n    static class TextMessage implements Message {\n        private String text;\n        public TextMessage(String text) {\n            this.text = text;\n        }\n        public String getContent() {\n            return text;\n        }\n    }\n\n    static class EncryptDecorator implements Message {\n        private Message message;\n        public EncryptDecorator(Message message) {\n            this.message = message;\n        }\n        public String getContent() {\n            return \"[encrypted:\" + message.getContent() + \"]\";\n        }\n    }\n\n    static class CompressDecorator implements Message {\n        private Message message;\n        public CompressDecorator(Message message) {\n            this.message = message;\n        }\n        public String getContent() {\n            return \"[compressed:\" + message.getContent() + \"]\";\n        }\n    }\n\n    public static void main(String[] args) {\n        Message msg = new TextMessage(\"Hello\");\n        msg = new EncryptDecorator(msg);\n        msg = new CompressDecorator(msg);\n        System.out.println(msg.getContent());\n    }\n}",
      "expectedOutput": "[compressed:[encrypted:Hello]]",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Decorator - Wrapper Chains in Java, an essential concept for building robust and maintainable applications. Understanding Decorator - Wrapper Chains helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Decorator - Wrapper Chains\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Decorator - Wrapper Chains\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Decorator - Wrapper Chains\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Decorator - Wrapper Chains in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Decorator - Wrapper Chains to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Decorator - Wrapper Chains to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Decorator - Wrapper Chains in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Decorator - Wrapper Chains</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Decorator - Wrapper Chains</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Decorator - Wrapper Chains when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Design Patterns",
        "OOP",
        "Structural Patterns"
      ]
    },
    {
      "id": 467,
      "title": "467. Facade - Simplified Interface",
      "description": "Implement the Facade pattern to provide a simplified interface to a complex subsystem.",
      "initialCode": "public class Main {\n    // TODO: Create CPU, Memory, HardDrive classes with simple methods\n\n    // TODO: Create ComputerFacade that coordinates all subsystems\n    // TODO: Add start() method that uses all components\n\n    public static void main(String[] args) {\n        // TODO: Create facade and call start()\n    }\n}",
      "fullSolution": "public class Main {\n    static class CPU {\n        public void freeze() { System.out.println(\"CPU frozen\"); }\n        public void execute() { System.out.println(\"CPU executing\"); }\n    }\n\n    static class Memory {\n        public void load() { System.out.println(\"Memory loaded\"); }\n    }\n\n    static class HardDrive {\n        public void read() { System.out.println(\"HardDrive read\"); }\n    }\n\n    static class ComputerFacade {\n        private CPU cpu;\n        private Memory memory;\n        private HardDrive hardDrive;\n\n        public ComputerFacade() {\n            this.cpu = new CPU();\n            this.memory = new Memory();\n            this.hardDrive = new HardDrive();\n        }\n\n        public void start() {\n            cpu.freeze();\n            memory.load();\n            hardDrive.read();\n            cpu.execute();\n        }\n    }\n\n    public static void main(String[] args) {\n        ComputerFacade computer = new ComputerFacade();\n        computer.start();\n    }\n}",
      "expectedOutput": "CPU frozen\nMemory loaded\nHardDrive read\nCPU executing",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Facade - Simplified Interface in Java, an essential concept for building robust and maintainable applications. Understanding Facade - Simplified Interface helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Facade - Simplified Interface\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Facade - Simplified Interface\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Facade - Simplified Interface\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Facade - Simplified Interface in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Facade - Simplified Interface to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Facade - Simplified Interface to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Facade - Simplified Interface in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Facade - Simplified Interface</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Facade - Simplified Interface</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Facade - Simplified Interface when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Design Patterns",
        "OOP",
        "Structural Patterns"
      ]
    },
    {
      "id": 468,
      "title": "468. Facade - Subsystem Coordination",
      "description": "Use Facade to coordinate multiple subsystems and manage their interactions.",
      "initialCode": "public class Main {\n    // TODO: Create Authentication, Authorization, Logger classes\n\n    // TODO: Create SecurityFacade coordinating all security subsystems\n    // TODO: Add login(user, pass) method\n\n    public static void main(String[] args) {\n        // TODO: Create facade and call login(\"admin\", \"pass\")\n    }\n}",
      "fullSolution": "public class Main {\n    static class Authentication {\n        public boolean verify(String user, String pass) {\n            System.out.println(\"Authenticating \" + user);\n            return true;\n        }\n    }\n\n    static class Authorization {\n        public void grantAccess(String user) {\n            System.out.println(\"Granting access to \" + user);\n        }\n    }\n\n    static class Logger {\n        public void log(String msg) {\n            System.out.println(\"Log: \" + msg);\n        }\n    }\n\n    static class SecurityFacade {\n        private Authentication auth;\n        private Authorization authz;\n        private Logger logger;\n\n        public SecurityFacade() {\n            this.auth = new Authentication();\n            this.authz = new Authorization();\n            this.logger = new Logger();\n        }\n\n        public void login(String user, String pass) {\n            if (auth.verify(user, pass)) {\n                authz.grantAccess(user);\n                logger.log(user + \" logged in\");\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        SecurityFacade security = new SecurityFacade();\n        security.login(\"admin\", \"pass\");\n    }\n}",
      "expectedOutput": "Authenticating admin\nGranting access to admin\nLog: admin logged in",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Facade - Subsystem Coordination in Java, an essential concept for building robust and maintainable applications. Understanding Facade - Subsystem Coordination helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Facade - Subsystem Coordination\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Facade - Subsystem Coordination\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Facade - Subsystem Coordination\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Facade - Subsystem Coordination in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Facade - Subsystem Coordination to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Facade - Subsystem Coordination to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Facade - Subsystem Coordination in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Facade - Subsystem Coordination</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Facade - Subsystem Coordination</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Facade - Subsystem Coordination when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Design Patterns",
        "OOP",
        "Structural Patterns"
      ]
    },
    {
      "id": 469,
      "title": "469. Proxy - Lazy Loading",
      "description": "Implement the Proxy pattern to defer expensive object creation until actually needed.",
      "initialCode": "public class Main {\n    // TODO: Create Image interface with display() method\n\n    // TODO: Create RealImage with expensive constructor\n\n    // TODO: Create ImageProxy that loads RealImage on first display()\n\n    public static void main(String[] args) {\n        // TODO: Create proxy, call display() twice\n    }\n}",
      "fullSolution": "public class Main {\n    interface Image {\n        void display();\n    }\n\n    static class RealImage implements Image {\n        private String filename;\n\n        public RealImage(String filename) {\n            this.filename = filename;\n            loadFromDisk();\n        }\n\n        private void loadFromDisk() {\n            System.out.println(\"Loading \" + filename);\n        }\n\n        public void display() {\n            System.out.println(\"Displaying \" + filename);\n        }\n    }\n\n    static class ImageProxy implements Image {\n        private String filename;\n        private RealImage realImage;\n\n        public ImageProxy(String filename) {\n            this.filename = filename;\n        }\n\n        public void display() {\n            if (realImage == null) {\n                realImage = new RealImage(filename);\n            }\n            realImage.display();\n        }\n    }\n\n    public static void main(String[] args) {\n        Image image = new ImageProxy(\"photo.jpg\");\n        image.display();\n        image.display();\n    }\n}",
      "expectedOutput": "Loading photo.jpg\nDisplaying photo.jpg\nDisplaying photo.jpg",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Proxy - Lazy Loading in Java, an essential concept for building robust and maintainable applications. Understanding Proxy - Lazy Loading helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Proxy - Lazy Loading\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Proxy - Lazy Loading\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Proxy - Lazy Loading\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Proxy - Lazy Loading in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Proxy - Lazy Loading to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Proxy - Lazy Loading to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Proxy - Lazy Loading in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Proxy - Lazy Loading</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Proxy - Lazy Loading</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Proxy - Lazy Loading when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Design Patterns",
        "OOP",
        "Structural Patterns"
      ]
    },
    {
      "id": 470,
      "title": "470. Proxy - Access Control",
      "description": "Use Proxy pattern to control access to sensitive operations based on permissions.",
      "initialCode": "public class Main {\n    // TODO: Create Document interface with edit() method\n\n    // TODO: Create RealDocument implementing Document\n\n    // TODO: Create ProtectedDocument proxy with role-based access\n\n    public static void main(String[] args) {\n        // TODO: Create proxy for \"admin\" and \"guest\"\n        // TODO: Try edit() on both\n    }\n}",
      "fullSolution": "public class Main {\n    interface Document {\n        void edit();\n    }\n\n    static class RealDocument implements Document {\n        public void edit() {\n            System.out.println(\"Editing document\");\n        }\n    }\n\n    static class ProtectedDocument implements Document {\n        private RealDocument realDocument;\n        private String role;\n\n        public ProtectedDocument(String role) {\n            this.realDocument = new RealDocument();\n            this.role = role;\n        }\n\n        public void edit() {\n            if (role.equals(\"admin\")) {\n                realDocument.edit();\n            } else {\n                System.out.println(\"Access denied\");\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Document adminDoc = new ProtectedDocument(\"admin\");\n        adminDoc.edit();\n\n        Document guestDoc = new ProtectedDocument(\"guest\");\n        guestDoc.edit();\n    }\n}",
      "expectedOutput": "Editing document\nAccess denied",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Proxy - Access Control in Java, an essential concept for building robust and maintainable applications. Understanding Proxy - Access Control helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Proxy - Access Control\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Proxy - Access Control\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Proxy - Access Control\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Proxy - Access Control in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Proxy - Access Control to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Proxy - Access Control to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Proxy - Access Control in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Proxy - Access Control</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Proxy - Access Control</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Proxy - Access Control when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Design Patterns",
        "OOP",
        "Structural Patterns"
      ]
    },
    {
      "id": 471,
      "title": "471. Template Method - Algorithm Skeleton",
      "description": "Implement Template Method pattern to define algorithm skeleton while letting subclasses override specific steps.",
      "initialCode": "public class Main {\n    // TODO: Create abstract DataProcessor with process() template method\n    // TODO: Add abstract readData() and processData() methods\n\n    // TODO: Create CSVProcessor extending DataProcessor\n\n    public static void main(String[] args) {\n        // TODO: Create CSVProcessor and call process()\n    }\n}",
      "fullSolution": "public class Main {\n    static abstract class DataProcessor {\n        public final void process() {\n            readData();\n            processData();\n            System.out.println(\"Data saved\");\n        }\n\n        protected abstract void readData();\n        protected abstract void processData();\n    }\n\n    static class CSVProcessor extends DataProcessor {\n        protected void readData() {\n            System.out.println(\"Reading CSV\");\n        }\n\n        protected void processData() {\n            System.out.println(\"Processing CSV\");\n        }\n    }\n\n    public static void main(String[] args) {\n        DataProcessor processor = new CSVProcessor();\n        processor.process();\n    }\n}",
      "expectedOutput": "Reading CSV\nProcessing CSV\nData saved",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Template Method - Algorithm Skeleton in Java, an essential concept for building robust and maintainable applications. Understanding Template Method - Algorithm Skeleton helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Template Method - Algorithm Skeleton\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Template Method - Algorithm Skeleton\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Template Method - Algorithm Skeleton\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Template Method - Algorithm Skeleton in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Template Method - Algorithm Skeleton to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Template Method - Algorithm Skeleton to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Template Method - Algorithm Skeleton in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Template Method - Algorithm Skeleton</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Template Method - Algorithm Skeleton</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Template Method - Algorithm Skeleton when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Design Patterns",
        "OOP",
        "Behavioral Patterns"
      ]
    },
    {
      "id": 472,
      "title": "472. Template Method - Hooks",
      "description": "Add optional hook methods to Template Method pattern for fine-grained customization.",
      "initialCode": "public class Main {\n    // TODO: Create abstract Report with generate() template method\n    // TODO: Add hook method shouldIncludeHeader() with default true\n    // TODO: Add abstract methods for header and body\n\n    // TODO: Create SimpleReport that skips header\n\n    public static void main(String[] args) {\n        // TODO: Create SimpleReport and call generate()\n    }\n}",
      "fullSolution": "public class Main {\n    static abstract class Report {\n        public final void generate() {\n            if (shouldIncludeHeader()) {\n                printHeader();\n            }\n            printBody();\n        }\n\n        protected boolean shouldIncludeHeader() {\n            return true;\n        }\n\n        protected abstract void printHeader();\n        protected abstract void printBody();\n    }\n\n    static class SimpleReport extends Report {\n        protected boolean shouldIncludeHeader() {\n            return false;\n        }\n\n        protected void printHeader() {\n            System.out.println(\"Header\");\n        }\n\n        protected void printBody() {\n            System.out.println(\"Body content\");\n        }\n    }\n\n    public static void main(String[] args) {\n        Report report = new SimpleReport();\n        report.generate();\n    }\n}",
      "expectedOutput": "Body content",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Template Method - Hooks in Java, an essential concept for building robust and maintainable applications. Understanding Template Method - Hooks helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Template Method - Hooks\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Template Method - Hooks\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Template Method - Hooks\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Template Method - Hooks in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Template Method - Hooks to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Template Method - Hooks to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Template Method - Hooks in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Template Method - Hooks</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Template Method - Hooks</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Template Method - Hooks when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Design Patterns",
        "OOP",
        "Behavioral Patterns"
      ]
    },
    {
      "id": 473,
      "title": "473. Strategy - Interchangeable Algorithms",
      "description": "Implement Strategy pattern to define family of algorithms and make them interchangeable.",
      "initialCode": "public class Main {\n    // TODO: Create SortStrategy interface with sort(int[] arr) method\n\n    // TODO: Create BubbleSort and QuickSort strategies\n\n    // TODO: Create Sorter class that uses a strategy\n\n    public static void main(String[] args) {\n        // TODO: Create sorter with BubbleSort and sort array\n    }\n}",
      "fullSolution": "public class Main {\n    interface SortStrategy {\n        void sort(int[] arr);\n    }\n\n    static class BubbleSort implements SortStrategy {\n        public void sort(int[] arr) {\n            System.out.println(\"Bubble sorting\");\n        }\n    }\n\n    static class QuickSort implements SortStrategy {\n        public void sort(int[] arr) {\n            System.out.println(\"Quick sorting\");\n        }\n    }\n\n    static class Sorter {\n        private SortStrategy strategy;\n\n        public Sorter(SortStrategy strategy) {\n            this.strategy = strategy;\n        }\n\n        public void setStrategy(SortStrategy strategy) {\n            this.strategy = strategy;\n        }\n\n        public void sort(int[] arr) {\n            strategy.sort(arr);\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {3, 1, 2};\n        Sorter sorter = new Sorter(new BubbleSort());\n        sorter.sort(arr);\n    }\n}",
      "expectedOutput": "Bubble sorting",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Strategy - Interchangeable Algorithms in Java, an essential concept for building robust and maintainable applications. Understanding Strategy - Interchangeable Algorithms helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Strategy - Interchangeable Algorithms\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Strategy - Interchangeable Algorithms\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Strategy - Interchangeable Algorithms\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Strategy - Interchangeable Algorithms in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Strategy - Interchangeable Algorithms to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Strategy - Interchangeable Algorithms to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Strategy - Interchangeable Algorithms in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Strategy - Interchangeable Algorithms</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Strategy - Interchangeable Algorithms</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Strategy - Interchangeable Algorithms when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Design Patterns",
        "OOP",
        "Behavioral Patterns"
      ]
    },
    {
      "id": 474,
      "title": "474. Strategy - Runtime Selection",
      "description": "Demonstrate changing strategies at runtime based on conditions or user input.",
      "initialCode": "public class Main {\n    // TODO: Create CompressionStrategy interface\n\n    // TODO: Create ZipCompression and RarCompression strategies\n\n    // TODO: Create FileCompressor that switches strategies based on file size\n\n    public static void main(String[] args) {\n        // TODO: Compress files of different sizes\n    }\n}",
      "fullSolution": "public class Main {\n    interface CompressionStrategy {\n        void compress(String file);\n    }\n\n    static class ZipCompression implements CompressionStrategy {\n        public void compress(String file) {\n            System.out.println(\"ZIP: \" + file);\n        }\n    }\n\n    static class RarCompression implements CompressionStrategy {\n        public void compress(String file) {\n            System.out.println(\"RAR: \" + file);\n        }\n    }\n\n    static class FileCompressor {\n        public void compress(String file, int size) {\n            CompressionStrategy strategy;\n            if (size < 100) {\n                strategy = new ZipCompression();\n            } else {\n                strategy = new RarCompression();\n            }\n            strategy.compress(file);\n        }\n    }\n\n    public static void main(String[] args) {\n        FileCompressor compressor = new FileCompressor();\n        compressor.compress(\"small.txt\", 50);\n        compressor.compress(\"large.txt\", 500);\n    }\n}",
      "expectedOutput": "ZIP: small.txt\nRAR: large.txt",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Strategy - Runtime Selection in Java, an essential concept for building robust and maintainable applications. Understanding Strategy - Runtime Selection helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Strategy - Runtime Selection\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Strategy - Runtime Selection\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Strategy - Runtime Selection\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Strategy - Runtime Selection in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Strategy - Runtime Selection to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Strategy - Runtime Selection to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Strategy - Runtime Selection in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Strategy - Runtime Selection</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Strategy - Runtime Selection</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Strategy - Runtime Selection when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Design Patterns",
        "OOP",
        "Behavioral Patterns"
      ]
    },
    {
      "id": 475,
      "title": "475. Memento - State Capture and Restore",
      "description": "Implement Memento pattern to capture and restore object state without violating encapsulation.",
      "initialCode": "public class Main {\n    // TODO: Create Editor class with text and getMemento()/restore(memento) methods\n\n    // TODO: Create Memento class to store state\n\n    // TODO: Create History class to manage mementos\n\n    public static void main(String[] args) {\n        // TODO: Edit text, save state, edit again, then undo\n    }\n}",
      "fullSolution": "public class Main {\n    static class Editor {\n        private String text;\n\n        public void setText(String text) {\n            this.text = text;\n        }\n\n        public String getText() {\n            return text;\n        }\n\n        public Memento save() {\n            return new Memento(text);\n        }\n\n        public void restore(Memento memento) {\n            this.text = memento.getState();\n        }\n    }\n\n    static class Memento {\n        private final String state;\n\n        public Memento(String state) {\n            this.state = state;\n        }\n\n        public String getState() {\n            return state;\n        }\n    }\n\n    static class History {\n        private Memento memento;\n\n        public void save(Editor editor) {\n            memento = editor.save();\n        }\n\n        public void undo(Editor editor) {\n            editor.restore(memento);\n        }\n    }\n\n    public static void main(String[] args) {\n        Editor editor = new Editor();\n        History history = new History();\n\n        editor.setText(\"Version 1\");\n        history.save(editor);\n\n        editor.setText(\"Version 2\");\n        System.out.println(editor.getText());\n\n        history.undo(editor);\n        System.out.println(editor.getText());\n    }\n}",
      "expectedOutput": "Version 2\nVersion 1",
      "tutorial": "<p class=\"mb-4 text-gray-300\">This lesson covers Memento - State Capture and Restore in Java, an essential concept for building robust and maintainable applications. Understanding Memento - State Capture and Restore helps you write cleaner code, improve performance, and follow industry best practices. This pattern is widely used in enterprise Java development and is fundamental to creating scalable, production-ready software that can handle real-world requirements effectively.\n<h4 class=\"font-semibold text-gray-200 mb-2\">Basic Pattern</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Basic implementation of Memento - State Capture and Restore\npublic class Example {\n    public void demonstrate() {\n        // Implementation here\n        System.out.println(\"Demonstrating Memento - State Capture and Restore\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Advanced Usage</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">// Advanced implementation with additional features\npublic class AdvancedExample {\n    private String config;\n    public AdvancedExample(String config) {\n        this.config = config;\n    }\n    public void process() {\n        // Advanced processing logic\n        System.out.println(\"Processing with: \" + config);\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Complete Example</h4>\n<div class=\"code-block-wrapper\"><pre class=\"tutorial-code-block\">import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        // Complete working example\n        System.out.println(\"Complete example of Memento - State Capture and Restore\");\n        Example basic = new Example();\n        basic.demonstrate();\n        AdvancedExample advanced = new AdvancedExample(\"production\");\n        advanced.process();\n        System.out.println(\"Example completed successfully\");\n    }\n}</pre></div>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Common Use Cases</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li><strong>Production applications</strong>: Implement Memento - State Capture and Restore in enterprise applications for better maintainability</li>\n<li><strong>Code organization</strong>: Use Memento - State Capture and Restore to structure code more effectively and improve readability</li>\n<li><strong>Performance optimization</strong>: Apply Memento - State Capture and Restore to enhance application performance and resource usage</li>\n<li><strong>Best practices</strong>: Follow industry standards by properly implementing Memento - State Capture and Restore in your projects</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">Best Practices</h4>\n<ul class=\"list-disc list-inside mb-4 text-gray-300\">\n<li>Always validate inputs and handle edge cases when implementing Memento - State Capture and Restore</li>\n<li>Follow naming conventions and code style guidelines for consistency</li>\n<li>Add comprehensive error handling and logging for production deployments</li>\n<li>Write unit tests to verify correct implementation of Memento - State Capture and Restore</li>\n<li>Document your code clearly to help other developers understand the implementation</li>\n</ul>\n<h4 class=\"font-semibold text-gray-200 mb-2\">When to Use</h4>\nUse Memento - State Capture and Restore when building applications that require this specific functionality, when you need to improve code quality and maintainability, when working on enterprise projects with specific requirements, or when following architectural patterns that benefit from this approach. This is essential for creating professional, production-ready software.</p>",
      "language": "java",
      "tags": [
        "Design Patterns",
        "OOP",
        "Behavioral Patterns"
      ]
    }
  ]
}