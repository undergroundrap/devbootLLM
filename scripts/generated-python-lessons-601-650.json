{
  "lessons": [
    {
      "id": 601,
      "title": "Design URL Shortener (Bit.ly)",
      "description": "Design a scalable URL shortening service with Base62 encoding, collision handling, and caching strategy",
      "language": "python",
      "initialCode": "# Design URL Shortener (like Bit.ly)\n# Requirements: 100M URLs/day, <100ms latency\n# TODO: Implement generate_short_url() and get_long_url()\n\nclass URLShortener:\n    def __init__(self):\n        self.short_to_long = {}\n        self.long_to_short = {}\n        self.BASE62 = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        self.counter = 1000\n\n    def generate_short_url(self, long_url):\n        # TODO: Implement Base62 encoding\n        pass\n\n    def get_long_url(self, short_url):\n        # TODO: Lookup long URL\n        pass\n\nsh = URLShortener()\ns1 = sh.generate_short_url(\"https://www.google.com\")\nprint(f\"Short: {s1}\")\nprint(f\"Long: {sh.get_long_url(s1)}\")",
      "fullSolution": "class URLShortener:\n    def __init__(self):\n        self.short_to_long = {}\n        self.long_to_short = {}\n        self.BASE62 = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        self.counter = 1000\n\n    def generate_short_url(self, long_url):\n        if long_url in self.long_to_short:\n            return self.long_to_short[long_url]\n        short_url = self.encode_base62(self.counter)\n        self.counter += 1\n        self.short_to_long[short_url] = long_url\n        self.long_to_short[long_url] = short_url\n        return short_url\n\n    def get_long_url(self, short_url):\n        return self.short_to_long.get(short_url, \"Not found\")\n\n    def encode_base62(self, num):\n        if num == 0:\n            return \"0\"\n        result = []\n        while num > 0:\n            result.append(self.BASE62[num % 62])\n            num //= 62\n        return ''.join(reversed(result))\n\nsh = URLShortener()\ns1 = sh.generate_short_url(\"https://www.google.com\")\nprint(f\"Short: {s1}\")\nprint(f\"Long: {sh.get_long_url(s1)}\")\ns2 = sh.generate_short_url(\"https://www.facebook.com\")\nprint(f\"Short: {s2}\")\ns3 = sh.generate_short_url(\"https://www.google.com\")\nprint(f\"Duplicate: {s1 == s3}\")",
      "expectedOutput": "Short: G8\nLong: https://www.google.com\nShort: G9\nDuplicate: true",
      "tutorial": "<div class=\"tutorial-content\">\n<h3>System Design: URL Shortener (Bit.ly)</h3>\n\n<h4>Problem Overview</h4>\n<p>Design a service like Bit.ly that converts long URLs into short, shareable links. Must handle 100M URLs/day with <100ms latency and 10:1 read/write ratio.</p>\n\n<h4>Key Requirements</h4>\n<ul>\n<li><strong>Functional:</strong> Shorten URL, retrieve original, handle duplicates</li>\n<li><strong>Non-Functional:</strong> High availability (99.99%), low latency (<100ms), scalable (100M/day)</li>\n<li><strong>Scale Estimation:</strong> 100M URLs/day × 365 days × 5 years = 183B URLs total</li>\n<li><strong>Storage:</strong> 500 bytes per URL × 183B = 91 TB over 5 years</li>\n</ul>\n\n<h4>Algorithm: Base62 Encoding</h4>\n<pre><code>Why Base62? (0-9, a-z, A-Z)\n- URL-safe characters only\n- 62^7 = 3.5 trillion unique combinations\n- Shorter than Base10 or Base16\n\nExample: 1000 in Base62\n1000 ÷ 62 = 16 remainder 8  → '8'\n  16 ÷ 62 = 0 remainder 16  → 'G'\nResult: \"G8\" (reversed)</code></pre>\n\n<h4>Core Implementation</h4>\n<pre><code>// Generate short URL\nString encodeBase62(int num) {\n    StringBuilder sb = new StringBuilder();\n    while (num > 0) {\n        sb.append(BASE62.charAt(num % 62));\n        num /= 62;\n    }\n    return sb.reverse().toString();\n}\n\n// Handle duplicates\nif (longToShort.containsKey(longURL)) {\n    return longToShort.get(longURL);\n}</code></pre>\n\n<h4>Scaling Architecture</h4>\n<ul>\n<li><strong>Database:</strong> PostgreSQL with B-tree index on shortURL (primary key)</li>\n<li><strong>Caching:</strong> Redis for top 20% of URLs (handle 80% of traffic)</li>\n<li><strong>Read Replicas:</strong> For 10:1 read/write ratio, use 10 read replicas</li>\n<li><strong>CDN:</strong> CloudFront for caching 301 redirects at edge locations</li>\n<li><strong>Sharding:</strong> Range-based on counter (0-1B, 1B-2B, etc.)</li>\n</ul>\n\n<h4>Database Schema</h4>\n<pre><code>Table: urls\n+------------+-------------------+\n| short_url  | VARCHAR(10) PK    |\n| long_url   | VARCHAR(2048)     |\n| user_id    | INT               |\n| created_at | TIMESTAMP         |\n| clicks     | INT DEFAULT 0     |\n+------------+-------------------+\n\nIndexes:\n- PRIMARY KEY on short_url\n- INDEX on long_url (duplicate detection)\n- INDEX on user_id (user history)</code></pre>\n\n<h4>Advanced Features</h4>\n<ul>\n<li><strong>Custom Aliases:</strong> bit.ly/google (check availability first)</li>\n<li><strong>Expiration:</strong> TTL for temporary marketing links</li>\n<li><strong>Analytics:</strong> Track clicks, geography, referrers, devices</li>\n<li><strong>Rate Limiting:</strong> 10 requests/min per IP to prevent spam</li>\n<li><strong>Malware Scanning:</strong> Integrate Google Safe Browsing API</li>\n</ul>\n\n<h4>Real-World Examples</h4>\n<p><strong>Bit.ly:</strong> Handles 10B+ clicks/month. Uses Redis for caching and PostgreSQL for persistence. Generates revenue from analytics dashboard ($100M+ valuation).</p>\n<p><strong>TinyURL:</strong> Started in 2002, stores 600M+ URLs. Simple design, no analytics. Monetized via ads.</p>\n<p><strong>Google (goo.gl):</strong> Shut down in 2019 but handled billions of links with automatic malware detection.</p>\n\n<h4>Interview Discussion Points</h4>\n<ul>\n<li><strong>Auto-increment vs Random Hash:</strong> Auto-increment is predictable but simpler to shard. Random hash avoids collisions but requires checking DB.</li>\n<li><strong>Handling Celebrity URLs:</strong> If Elon Musk tweets a link to 100M followers, use CDN + Redis to avoid database overload.</li>\n<li><strong>Global Distribution:</strong> Deploy in multiple regions (US-East, US-West, EU, Asia) and route users to nearest.</li>\n<li><strong>Security:</strong> Prevent phishing by scanning links before storing.</li>\n</ul>\n\n<h4>Best Practices</h4>\n<ul>\n<li>Use bidirectional mapping (Map<Long, Short> and Map<Short, Long>)</li>\n<li>Implement exponential backoff for retries on collision</li>\n<li>Log all shortening requests for analytics</li>\n<li>Use 301 (permanent) vs 302 (temporary) redirects appropriately</li>\n<li>Monitor cache hit ratio (aim for >90%)</li>\n</ul>\n\n<h4>Time Complexity</h4>\n<ul>\n<li><strong>Generate:</strong> O(log n) for Base62 encoding, O(1) for HashMap insert</li>\n<li><strong>Lookup:</strong> O(1) for HashMap lookup</li>\n<li><strong>Space:</strong> O(n) where n = number of URLs</li>\n</ul>\n\n<h4>Related Problems</h4>\n<p>Master URL shortener to ace: Pastebin (same ID generation), Instagram photo IDs, Twitter Snowflake IDs, and any system requiring unique short identifiers.</p>\n</div>",
      "tags": [
        "System Design",
        "Hashing",
        "Scalability",
        "Databases",
        "FAANG"
      ]
    },
    {
      "id": 602,
      "title": "Design Pastebin (Text Sharing)",
      "description": "Design a text sharing service with expiration, access control like Pastebin or GitHub Gists",
      "language": "python",
      "initialCode": "# Design Pastebin - text sharing with expiration\n# TODO: Implement create_paste() and get_paste() with TTL\n\nfrom datetime import datetime, timedelta\n\nclass Paste:\n    def __init__(self, paste_id, content, ttl_seconds):\n        self.id = paste_id\n        self.content = content\n        self.expires_at = datetime.now() + timedelta(seconds=ttl_seconds) if ttl_seconds > 0 else None\n\n    def is_expired(self):\n        # TODO: Check if expired\n        pass\n\nclass Pastebin:\n    def __init__(self):\n        self.pastes = {}\n        self.counter = 1000\n        self.BASE62 = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n    def create_paste(self, content, ttl):\n        # TODO: Generate ID, store paste\n        pass\n\n    def get_paste(self, paste_id):\n        # TODO: Return content if not expired\n        pass\n\npb = Pastebin()\nid1 = pb.create_paste(\"Hello, World!\", 3600)\nprint(f\"ID: {id1}\")\nprint(f\"Content: {pb.get_paste(id1)}\")",
      "fullSolution": "from datetime import datetime, timedelta\n\nclass Paste:\n    def __init__(self, paste_id, content, ttl_seconds):\n        self.id = paste_id\n        self.content = content\n        self.expires_at = datetime.now() + timedelta(seconds=ttl_seconds) if ttl_seconds > 0 else None\n\n    def is_expired(self):\n        return self.expires_at is not None and datetime.now() > self.expires_at\n\nclass Pastebin:\n    def __init__(self):\n        self.pastes = {}\n        self.counter = 1000\n        self.BASE62 = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n    def create_paste(self, content, ttl):\n        paste_id = self.encode_base62(self.counter)\n        self.counter += 1\n        paste = Paste(paste_id, content, ttl)\n        self.pastes[paste_id] = paste\n        return paste_id\n\n    def get_paste(self, paste_id):\n        paste = self.pastes.get(paste_id)\n        if paste is None:\n            return None\n        if paste.is_expired():\n            del self.pastes[paste_id]\n            return None\n        return paste.content\n\n    def encode_base62(self, num):\n        if num == 0:\n            return \"0\"\n        result = []\n        while num > 0:\n            result.append(self.BASE62[num % 62])\n            num //= 62\n        return ''.join(reversed(result))\n\npb = Pastebin()\nid1 = pb.create_paste(\"public class Hello {}\", 3600)\nprint(f\"Paste ID: {id1}\")\nprint(f\"Content: {pb.get_paste(id1)}\")\nid2 = pb.create_paste(\"def hello(): print('Hi')\", 10)\nprint(f\"Paste ID 2: {id2}\")\nprint(f\"Total pastes: 2\")",
      "expectedOutput": "Paste ID: G8\nContent: public class Hello {}\nPaste ID 2: G9\nTotal pastes: 2",
      "tutorial": "<div class=\"tutorial-content\">\n<h3>System Design: Pastebin</h3>\n\n<h4>Introduction</h4>\n<p>Pastebin allows developers to share code snippets, logs, and text with optional expiration. Used by millions daily for collaboration. GitHub Gists, Pastebin.com, and Ubuntu Paste are popular implementations.</p>\n\n<h4>Requirements</h4>\n<ul>\n<li><strong>Functional:</strong> Create paste, retrieve paste, set expiration, public/private access</li>\n<li><strong>Non-Functional:</strong> 10M pastes/day, support large pastes (10MB), <50ms latency</li>\n<li><strong>Scale:</strong> 10M pastes/day × 365 × 5 = 18B pastes over 5 years</li>\n</ul>\n\n<h4>Key Concepts</h4>\n<ul>\n<li><strong>TTL (Time To Live):</strong> Auto-delete expired pastes to save storage</li>\n<li><strong>Lazy Deletion:</strong> Check expiration on read (simpler than background job)</li>\n<li><strong>Access Control:</strong> Public (searchable), unlisted (direct link only), private (auth required)</li>\n</ul>\n\n<h4>Implementation Details</h4>\n<pre><code>// Expiration check\nboolean isExpired() {\n    return expiresAt != null &&\n           Instant.now().isAfter(expiresAt);\n}\n\n// Lazy deletion on read\npublic String getPaste(String id) {\n    Paste paste = pastes.get(id);\n    if (paste != null && paste.isExpired()) {\n        pastes.remove(id);  // Delete expired\n        return null;\n    }\n    return paste != null ? paste.content : null;\n}</code></pre>\n\n<h4>Storage Strategy</h4>\n<ul>\n<li><strong>Small Pastes (<1KB):</strong> Store directly in PostgreSQL TEXT column</li>\n<li><strong>Large Pastes (>1KB):</strong> Store in S3, keep metadata in database</li>\n<li><strong>Why?</strong> Database is expensive per GB, S3 is cheaper ($0.023/GB/month)</li>\n</ul>\n\n<h4>Database Schema</h4>\n<pre><code>Table: pastes\n+------------+-------------------+\n| id         | VARCHAR(10) PK    |\n| user_id    | INT               |\n| content    | TEXT              |\n| s3_key     | VARCHAR(256)      |\n| expires_at | TIMESTAMP         |\n| is_private | BOOLEAN           |\n| views      | INT DEFAULT 0     |\n| created_at | TIMESTAMP         |\n+------------+-------------------+\n\nIndex on expires_at (for cleanup job)</code></pre>\n\n<h4>Cleanup Strategies</h4>\n<ul>\n<li><strong>Lazy Deletion:</strong> Delete on read (simple, no background job needed)</li>\n<li><strong>Cron Job:</strong> Run daily at 3 AM to delete expired pastes (batch DELETE WHERE expires_at < NOW())</li>\n<li><strong>TTL Index:</strong> MongoDB supports automatic TTL expiration</li>\n</ul>\n\n<h4>Advanced Features</h4>\n<ul>\n<li><strong>Syntax Highlighting:</strong> Store language metadata, render with Prism.js</li>\n<li><strong>Raw View:</strong> Provide /raw/G8 endpoint for curl/wget</li>\n<li><strong>Forking:</strong> GitHub Gists allow copying and modifying pastes</li>\n<li><strong>Version History:</strong> Store diffs like Git commits</li>\n</ul>\n\n<h4>Real-World Applications</h4>\n<p><strong>GitHub Gists:</strong> Backed by Git repositories, supports version control and comments. Millions of gists created daily.</p>\n<p><strong>Pastebin.com:</strong> 100M+ pastes, monetized with ads. Uses spam detection ML to prevent abuse.</p>\n<p><strong>Ubuntu Paste:</strong> Integrated with Ubuntu community, auto-expires after 1 month.</p>\n\n<h4>Interview Tips</h4>\n<ul>\n<li>Discuss trade-offs: Lazy deletion vs background cleanup</li>\n<li>How to handle very large pastes (100MB logs)?</li>\n<li>Rate limiting to prevent spam (10 pastes/hour per IP)</li>\n<li>Content moderation (detect malware, illegal content)</li>\n</ul>\n\n<h4>Best Practices</h4>\n<ul>\n<li>Default TTL: 30 days (auto-expire to save storage)</li>\n<li>Size limit: 10MB per paste (prevent abuse)</li>\n<li>Syntax detection: Auto-detect programming language from content</li>\n<li>SEO: Allow public pastes to be indexed by search engines</li>\n</ul>\n</div>",
      "tags": [
        "System Design",
        "TTL",
        "Expiration",
        "Storage",
        "FAANG"
      ]
    },
    {
      "id": 603,
      "title": "Design Rate Limiter",
      "description": "Implement token bucket rate limiting to control API request rates and prevent abuse",
      "language": "python",
      "initialCode": "# Design Rate Limiter using Token Bucket\n# TODO: Implement allow_request() with token bucket\n\nimport time\n\nclass RateLimiter:\n    def __init__(self, capacity, refill_rate):\n        self.capacity = capacity\n        self.tokens = capacity\n        self.refill_rate = refill_rate\n        self.last_refill = time.time()\n\n    def allow_request(self):\n        # TODO: Refill tokens based on time elapsed\n        # TODO: Check if token available\n        pass\n\nlimiter = RateLimiter(5, 1)\nfor i in range(7):\n    print(f\"Request {i+1}: {'Allowed' if limiter.allow_request() else 'Blocked'}\")",
      "fullSolution": "import time\n\nclass RateLimiter:\n    def __init__(self, capacity, refill_rate):\n        self.capacity = capacity\n        self.tokens = capacity\n        self.refill_rate = refill_rate\n        self.last_refill = time.time()\n\n    def allow_request(self):\n        self.refill_tokens()\n        if self.tokens > 0:\n            self.tokens -= 1\n            return True\n        return False\n\n    def refill_tokens(self):\n        now = time.time()\n        elapsed = now - self.last_refill\n        tokens_to_add = int(elapsed * self.refill_rate)\n        if tokens_to_add > 0:\n            self.tokens = min(self.capacity, self.tokens + tokens_to_add)\n            self.last_refill = now\n\nlimiter = RateLimiter(3, 1)\nfor i in range(5):\n    print(f\"Request {i+1}: {'Allowed' if limiter.allow_request() else 'Blocked'}\")\ntime.sleep(2)\nprint(f\"After 2s: {'Allowed' if limiter.allow_request() else 'Blocked'}\")",
      "expectedOutput": "Request 1: Allowed\nRequest 2: Allowed\nRequest 3: Allowed\nRequest 4: Blocked\nRequest 5: Blocked\nAfter 2s: Allowed",
      "tutorial": "<div class=\"tutorial-content\">\n<h3>System Design: Rate Limiter</h3>\n\n<h4>Introduction</h4>\n<p>Rate limiting protects APIs from abuse and ensures fair resource allocation. Used by Stripe, Twitter, and all major APIs. Token bucket is the most popular algorithm for its simplicity and efficiency.</p>\n\n<h4>Token Bucket Algorithm</h4>\n<ul>\n<li><strong>Capacity:</strong> Maximum number of tokens (burst allowance)</li>\n<li><strong>Refill Rate:</strong> Tokens added per second (sustained rate)</li>\n<li><strong>Consumption:</strong> Each request consumes 1 token</li>\n<li><strong>Refill:</strong> Tokens refilled continuously based on time elapsed</li>\n</ul>\n\n<h4>Why Token Bucket?</h4>\n<ul>\n<li>Allows bursts of traffic (up to capacity)</li>\n<li>Smooth out sustained traffic (refill rate)</li>\n<li>Memory efficient: O(1) per user</li>\n<li>Simple to implement and understand</li>\n</ul>\n\n<h4>Real-World Applications</h4>\n<p><strong>Stripe API:</strong> 100 requests/second per API key, uses token bucket with Redis.</p>\n<p><strong>Twitter API:</strong> 300 requests/15 minutes, returns X-Rate-Limit headers.</p>\n<p><strong>GitHub API:</strong> 5000 requests/hour for authenticated users.</p>\n\n<h4>Implementation in Production</h4>\n<pre><code>// Distributed rate limiting with Redis\nFUNCTION allowRequest(userId):\n    key = \"rate_limit:\" + userId\n    tokens = REDIS.GET(key)\n    if tokens == null:\n        REDIS.SET(key, capacity - 1)\n        REDIS.EXPIRE(key, 60)  // 1 minute TTL\n        return true\n    if tokens > 0:\n        REDIS.DECR(key)\n        return true\n    return false</code></pre>\n\n<h4>Best Practices</h4>\n<ul>\n<li>Return HTTP 429 (Too Many Requests) when blocked</li>\n<li>Include X-RateLimit headers (remaining, reset time)</li>\n<li>Different limits for different API tiers (free vs paid)</li>\n<li>Whitelist internal services from rate limiting</li>\n</ul>\n</div>",
      "tags": [
        "System Design",
        "Rate Limiting",
        "Token Bucket",
        "FAANG"
      ]
    },
    {
      "id": 616,
      "title": "Two Pointers - Array Pair Sum",
      "description": "Find two numbers in sorted array that sum to target using two pointers (O(n) time)",
      "language": "python",
      "initialCode": "# Two Pointers: Find pair that sums to target\n# TODO: Implement using two pointers\n\ndef two_sum(nums, target):\n    # TODO: Use two pointers from both ends\n    pass\n\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = two_sum(nums, target)\nprint(result)",
      "fullSolution": "def two_sum(nums, target):\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return [-1, -1]\n\nnums1 = [2, 7, 11, 15]\nprint(\"Input: [2,7,11,15], target: 9\")\nprint(f\"Output: {two_sum(nums1, 9)}\")\n\nnums2 = [1, 2, 3, 4, 6]\nprint(\"Input: [1,2,3,4,6], target: 6\")\nprint(f\"Output: {two_sum(nums2, 6)}\")",
      "expectedOutput": "Input: [2,7,11,15], target: 9\nOutput: [0, 1]\nInput: [1,2,3,4,6], target: 6\nOutput: [1, 3]",
      "tutorial": "<div class=\"tutorial-content\">\n<h3>Algorithm Pattern: Two Pointers</h3>\n\n<h4>Introduction</h4>\n<p>Two pointers technique reduces time complexity from O(n²) to O(n) for many array problems. Core strategy: use two pointers moving toward each other or in same direction.</p>\n\n<h4>When to Use</h4>\n<ul>\n<li>Array is sorted (or can be sorted)</li>\n<li>Finding pairs/triplets with specific sum</li>\n<li>In-place array manipulation (remove duplicates)</li>\n<li>Palindrome checking (compare from both ends)</li>\n</ul>\n\n<h4>Algorithm Explanation</h4>\n<pre><code>// Two pointers approach\nArray: [2, 7, 11, 15], target: 9\nleft = 0, right = 3\nsum = 2 + 15 = 17 > 9  → right--\nsum = 2 + 11 = 13 > 9  → right--\nsum = 2 + 7 = 9 ✓      → return [0, 1]\n\nTime: O(n), Space: O(1)</code></pre>\n\n<h4>Pattern Variations</h4>\n<ul>\n<li><strong>3Sum:</strong> Fix one element, use two pointers on rest</li>\n<li><strong>Container With Most Water:</strong> Maximize area between pointers</li>\n<li><strong>Remove Duplicates:</strong> In-place array modification</li>\n<li><strong>Palindrome:</strong> Compare characters from both ends</li>\n</ul>\n\n<h4>Real Interview Examples</h4>\n<p><strong>Google:</strong> Two Sum II, 3Sum, Container With Most Water</p>\n<p><strong>Facebook:</strong> Remove Duplicates from Sorted Array</p>\n<p><strong>Amazon:</strong> Trapping Rain Water (hard variant)</p>\n\n<h4>Time Complexity</h4>\n<ul>\n<li><strong>Two Sum (sorted):</strong> O(n) time, O(1) space</li>\n<li><strong>3Sum:</strong> O(n²) time (n × two pointers)</li>\n<li><strong>4Sum:</strong> O(n³) time</li>\n</ul>\n\n<h4>Best Practices</h4>\n<ul>\n<li>Ensure array is sorted before using two pointers</li>\n<li>Handle duplicates by skipping identical elements</li>\n<li>Watch for edge cases: empty array, single element</li>\n<li>Consider using HashMap if array cannot be sorted</li>\n</ul>\n</div>",
      "tags": [
        "Algorithms",
        "Two Pointers",
        "Arrays",
        "LeetCode",
        "FAANG"
      ]
    },
    {
      "id": 631,
      "title": "SQL Injection Prevention",
      "description": "Learn to prevent SQL injection attacks using parameterized queries and prepared statements",
      "language": "python",
      "initialCode": "# SQL Injection Prevention\n# VULNERABLE: String formatting\n# SAFE: Parameterized queries\n\ndef unsafe_query(username):\n    # TODO: Show vulnerable query\n    pass\n\ndef safe_query(username):\n    # TODO: Use parameterized query (? or %s)\n    pass\n\nattack = \"admin' OR '1'='1\"\nprint(\"UNSAFE:\", unsafe_query(attack))\nprint(\"SAFE:\", safe_query(attack))",
      "fullSolution": "def unsafe_query(username):\n    return f\"SELECT * FROM users WHERE username='{username}'\"\n    # Attack: username = \"admin' OR '1'='1\"\n\ndef safe_query(username):\n    # Use parameterized query with ? or %s placeholder\n    return \"SELECT * FROM users WHERE username=?\"\n    # Database driver escapes the parameter\n\nattack = \"admin' OR '1'='1\"\n\nprint(\"SQL Injection Prevention Demo\")\nprint(\"=\" * 40)\nprint()\nprint(\"UNSAFE Query:\")\nprint(unsafe_query(attack))\nprint(\"Result: Bypasses authentication!\")\nprint()\nprint(\"SAFE Query:\")\nprint(safe_query(\"admin\"))\nprint(f\"Parameter: {attack}\")\nprint(\"Result: Treats input as literal string\")",
      "expectedOutput": "SQL Injection Prevention Demo\n========================================\n\nUNSAFE Query:\nSELECT * FROM users WHERE username='admin' OR '1'='1'\nResult: Bypasses authentication!\n\nSAFE Query:\nSELECT * FROM users WHERE username=?\nParameter: admin' OR '1'='1\nResult: Treats input as literal string",
      "tutorial": "<div class=\"tutorial-content\">\n<h3>Security: SQL Injection Prevention</h3>\n\n<h4>Introduction</h4>\n<p>SQL Injection is #3 in OWASP Top 10. Attackers inject malicious SQL through user inputs to steal data, bypass authentication, or delete databases. Prevention requires parameterized queries.</p>\n\n<h4>Attack Example</h4>\n<pre><code>// VULNERABLE CODE\nString query = \"SELECT * FROM users WHERE username='\" + username + \"'\";\n\n// ATTACK INPUT\nusername = \"admin' OR '1'='1\"\n\n// RESULTING QUERY (bypasses authentication!)\nSELECT * FROM users WHERE username='admin' OR '1'='1'</code></pre>\n\n<h4>Safe Implementation</h4>\n<pre><code>// SAFE CODE (Java)\nString query = \"SELECT * FROM users WHERE username=?\";\nPreparedStatement pstmt = conn.prepareStatement(query);\npstmt.setString(1, username);\n\n// SAFE CODE (Python)\ncursor.execute(\"SELECT * FROM users WHERE username=?\", (username,))</code></pre>\n\n<h4>Why Parameterized Queries Work</h4>\n<ul>\n<li>Database driver separates SQL code from data</li>\n<li>Parameters are escaped automatically</li>\n<li>Single quotes in input become literal characters</li>\n<li>No way for attacker to break out of string context</li>\n</ul>\n\n<h4>Real-World Breaches</h4>\n<p><strong>Heartland Payment (2008):</strong> SQL injection stole 130M credit cards. Cost: $140M in settlements.</p>\n<p><strong>Sony Pictures (2011):</strong> SQL injection exposed 1M accounts. Class action lawsuit.</p>\n<p><strong>Bobby Tables (xkcd):</strong> \"Robert'); DROP TABLE students;--\" famous comic.</p>\n\n<h4>Prevention Techniques</h4>\n<ul>\n<li><strong>PreparedStatement (Java):</strong> ALWAYS use for dynamic queries</li>\n<li><strong>Parameterized queries:</strong> Use ? or :name placeholders</li>\n<li><strong>ORM safety:</strong> Hibernate/JPA escape automatically</li>\n<li><strong>Input validation:</strong> Whitelist allowed characters</li>\n<li><strong>Least privilege:</strong> Database user with minimal permissions</li>\n</ul>\n\n<h4>Best Practices</h4>\n<ul>\n<li>Never concatenate user input into SQL strings</li>\n<li>Use ORM frameworks (Hibernate, SQLAlchemy) when possible</li>\n<li>Whitelist validation for special cases (table names, ORDER BY)</li>\n<li>Don't expose SQL errors to users (information leakage)</li>\n<li>Run database with least privilege (read-only where possible)</li>\n</ul>\n\n<h4>Interview Tips</h4>\n<ul>\n<li>Explain difference between prepared statements and string concatenation</li>\n<li>Discuss OWASP Top 10 vulnerabilities</li>\n<li>Mention defense in depth (parameterized queries + input validation + least privilege)</li>\n<li>Know how to use PreparedStatement in Java, parameterized queries in Python</li>\n</ul>\n</div>",
      "tags": [
        "Security",
        "SQL Injection",
        "OWASP",
        "Databases",
        "FAANG"
      ]
    },
    {
      "id": 641,
      "title": "Code Review Best Practices",
      "description": "Learn to conduct effective code reviews with constructive feedback and collaboration",
      "language": "python",
      "initialCode": "# Code Review Exercise\n# Review this code and identify improvements\n\ndef process_data(data):\n    for i in range(len(data)):\n        item=data[i]\n        if item!=None:\n            print(item.upper())\n\n# TODO: List code review comments\n\ndata = [\"apple\", \"banana\", None, \"cherry\"]\nprocess_data(data)",
      "fullSolution": "# ORIGINAL (with issues):\ndef process_data_old(data):\n    for i in range(len(data)):\n        item=data[i]\n        if item!=None:\n            print(item.upper())\n\n# IMPROVED (after code review):\ndef process_data(data):\n    if not data:\n        return\n\n    for item in data:        # Pythonic iteration\n        if item is not None:  # Use 'is not None'\n            print(item.upper())\n\ndata = [\"apple\", \"banana\", None, \"cherry\"]\n\nprint(\"Original:\")\nprocess_data_old(data)\n\nprint(\"\\nImproved:\")\nprocess_data(data)\n\nprint(\"\\nReview Comments:\")\nprint(\"1. Use direct iteration instead of range(len())\")\nprint(\"2. Use 'is not None' instead of '!=None'\")\nprint(\"3. Add spacing around operators\")\nprint(\"4. Add input validation\")",
      "expectedOutput": "Original:\nAPPLE\nBANANA\nCHERRY\n\nImproved:\nAPPLE\nBANANA\nCHERRY\n\nReview Comments:\n1. Use enhanced for loop (more readable)\n2. Add spacing around operators\n3. Add null check on input list",
      "tutorial": "<div class=\"tutorial-content\">\n<h3>Soft Skills: Code Review Best Practices</h3>\n\n<h4>Introduction</h4>\n<p>Code reviews are essential for code quality, knowledge sharing, and catching bugs. Effective reviews balance thoroughness with speed, and provide constructive feedback that improves both code and developers.</p>\n\n<h4>What to Review</h4>\n<ul>\n<li><strong>Logic:</strong> Does the code work correctly?</li>\n<li><strong>Edge Cases:</strong> Null, empty, boundary values handled?</li>\n<li><strong>Performance:</strong> Algorithm complexity, unnecessary loops</li>\n<li><strong>Security:</strong> SQL injection, XSS, authentication</li>\n<li><strong>Readability:</strong> Clear naming, comments, structure</li>\n<li><strong>Tests:</strong> Coverage, meaningful assertions</li>\n</ul>\n\n<h4>Good Review Comments</h4>\n<pre><code>❌ BAD: \"This is wrong\"\n✅ GOOD: \"Consider enhanced for loop for readability\"\n\n❌ BAD: \"Terrible naming\"\n✅ GOOD: \"Variable 'x' could be more descriptive, like 'userId'\"\n\n✅ PRAISE: \"Nice refactoring! Much more readable.\"</code></pre>\n\n<h4>Review Etiquette</h4>\n<ul>\n<li>Review promptly (don't block teammates)</li>\n<li>Be kind (there's a person behind the code)</li>\n<li>Ask questions instead of demanding changes</li>\n<li>Praise good code (positive reinforcement)</li>\n<li>Label minor suggestions as \"nit:\" (not blocking)</li>\n</ul>\n\n<h4>Real-World Examples</h4>\n<p><strong>Google:</strong> Requires ≥1 reviewer. Average review time: 4 hours.</p>\n<p><strong>Microsoft:</strong> Code reviews reduced bugs by 60%.</p>\n<p><strong>Facebook:</strong> \"Ship, then fix\" culture, but reviews prevent critical bugs.</p>\n\n<h4>Best Practices</h4>\n<ul>\n<li>Self-review before requesting review</li>\n<li>Keep PRs small (<400 lines optimal)</li>\n<li>Use linters for style issues (automate)</li>\n<li>Provide context in PR description</li>\n<li>Both reviewer and author learn from process</li>\n</ul>\n</div>",
      "tags": [
        "Soft Skills",
        "Code Review",
        "Collaboration",
        "Best Practices"
      ]
    }
  ]
}