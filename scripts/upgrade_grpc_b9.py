#!/usr/bin/env python3
"""
Upgrade Script: gRPC Modern API Communication Lessons (Batch 9)
Upgrades 3 gRPC lessons with production-ready Java simulations
"""

import json
import sys
from pathlib import Path

# Lesson configurations
LESSONS = {
    924: {
        'title': 'gRPC - Service Definition',
        'target_min': 4500,
        'target_max': 5500
    },
    928: {
        'title': 'gRPC - Bidirectional Streaming',
        'target_min': 5000,
        'target_max': 6000
    },
    1054: {
        'title': 'gRPC - gRPC Production',
        'target_min': 4500,
        'target_max': 5500
    }
}

# Production Java simulations
SOLUTIONS = {
    924: '''// In production: import io.grpc.*;
// In production: import io.grpc.stub.*;
// In production: import com.google.protobuf.*;

import java.util.*;
import java.util.concurrent.*;

// Simulates gRPC service definition patterns from .proto to Java
// Real: protoc compiler generates stubs from .proto files
public class Main {

    // SIMULATION: Proto message definition to Java class
    // Real .proto: message UserRequest { string user_id = 1; string name = 2; }
    static class UserRequest {
        private String userId;
        private String name;
        private String email;

        public UserRequest(String userId, String name, String email) {
            this.userId = userId;
            this.name = name;
            this.email = email;
        }

        // In production: Auto-generated by protoc compiler
        public String getUserId() { return userId; }
        public String getName() { return name; }
        public String getEmail() { return email; }

        public static Builder newBuilder() {
            return new Builder();
        }

        static class Builder {
            private String userId = "";
            private String name = "";
            private String email = "";

            public Builder setUserId(String userId) {
                this.userId = userId;
                return this;
            }

            public Builder setName(String name) {
                this.name = name;
                return this;
            }

            public Builder setEmail(String email) {
                this.email = email;
                return this;
            }

            public UserRequest build() {
                return new UserRequest(userId, name, email);
            }
        }
    }

    // SIMULATION: Proto response message
    // Real .proto: message UserResponse { string user_id = 1; bool success = 2; }
    static class UserResponse {
        private String userId;
        private boolean success;
        private String message;
        private long timestamp;

        public UserResponse(String userId, boolean success, String message) {
            this.userId = userId;
            this.success = success;
            this.message = message;
            this.timestamp = System.currentTimeMillis();
        }

        public String getUserId() { return userId; }
        public boolean getSuccess() { return success; }
        public String getMessage() { return message; }
        public long getTimestamp() { return timestamp; }
    }

    // SIMULATION: Service definition from .proto
    // Real .proto:
    // service UserService {
    //   rpc GetUser(UserRequest) returns (UserResponse);
    //   rpc ListUsers(Empty) returns (stream UserResponse);
    //   rpc CreateUsers(stream UserRequest) returns (UserResponse);
    // }
    static abstract class UserServiceGrpc {

        // Unary RPC: Single request -> Single response
        public abstract UserResponse getUser(UserRequest request);

        // Server streaming RPC: Single request -> Stream of responses
        public abstract List<UserResponse> listUsers();

        // Client streaming RPC: Stream of requests -> Single response
        public abstract UserResponse createUsers(List<UserRequest> requests);

        // In production: Generated stub classes
        public static UserServiceBlockingStub newBlockingStub(Channel channel) {
            return new UserServiceBlockingStub(channel);
        }

        public static UserServiceStub newStub(Channel channel) {
            return new UserServiceStub(channel);
        }
    }

    // SIMULATION: Blocking stub for synchronous calls
    static class UserServiceBlockingStub {
        private Channel channel;

        public UserServiceBlockingStub(Channel channel) {
            this.channel = channel;
        }

        // Synchronous unary call
        public UserResponse getUser(UserRequest request) {
            System.out.println("[CLIENT] Calling getUser RPC...");
            // In production: Serializes request to protobuf wire format
            // Sends over HTTP/2, receives and deserializes response
            return new UserResponse(
                request.getUserId(),
                true,
                "User retrieved successfully"
            );
        }

        // Synchronous server streaming call
        public Iterator<UserResponse> listUsers() {
            System.out.println("[CLIENT] Calling listUsers RPC (server streaming)...");
            // In production: Receives stream of responses over HTTP/2
            List<UserResponse> responses = new ArrayList<>();
            for (int i = 1; i <= 3; i++) {
                responses.add(new UserResponse(
                    "user-" + i,
                    true,
                    "User " + i + " data"
                ));
            }
            return responses.iterator();
        }
    }

    // SIMULATION: Async stub for non-blocking calls
    static class UserServiceStub {
        private Channel channel;

        public UserServiceStub(Channel channel) {
            this.channel = channel;
        }

        // Asynchronous unary call with callback
        public void getUser(UserRequest request, StreamObserver<UserResponse> responseObserver) {
            System.out.println("[CLIENT] Async getUser RPC...");
            // In production: Non-blocking call with callback
            UserResponse response = new UserResponse(
                request.getUserId(),
                true,
                "Async user retrieval"
            );
            responseObserver.onNext(response);
            responseObserver.onCompleted();
        }
    }

    // SIMULATION: gRPC channel (connection to server)
    static class Channel {
        private String target;

        public Channel(String target) {
            this.target = target;
            System.out.println("[CHANNEL] Created to " + target);
        }

        public void shutdown() {
            System.out.println("[CHANNEL] Shutdown");
        }
    }

    // SIMULATION: Stream observer for async responses
    interface StreamObserver<T> {
        void onNext(T value);
        void onError(Throwable t);
        void onCompleted();
    }

    // SIMULATION: Server implementation
    static class UserServiceImpl extends UserServiceGrpc {
        private Map<String, UserRequest> userDatabase = new ConcurrentHashMap<>();

        public UserServiceImpl() {
            // Seed database
            userDatabase.put("user-123", UserRequest.newBuilder()
                .setUserId("user-123")
                .setName("Alice Johnson")
                .setEmail("alice@example.com")
                .build());
            userDatabase.put("user-456", UserRequest.newBuilder()
                .setUserId("user-456")
                .setName("Bob Smith")
                .setEmail("bob@example.com")
                .build());
        }

        @Override
        public UserResponse getUser(UserRequest request) {
            System.out.println("[SERVER] Processing getUser: " + request.getUserId());

            UserRequest user = userDatabase.get(request.getUserId());
            if (user != null) {
                return new UserResponse(
                    user.getUserId(),
                    true,
                    "Found: " + user.getName()
                );
            }
            return new UserResponse(request.getUserId(), false, "User not found");
        }

        @Override
        public List<UserResponse> listUsers() {
            System.out.println("[SERVER] Processing listUsers (streaming)...");
            List<UserResponse> responses = new ArrayList<>();

            for (UserRequest user : userDatabase.values()) {
                responses.add(new UserResponse(
                    user.getUserId(),
                    true,
                    user.getName() + " - " + user.getEmail()
                ));
            }

            return responses;
        }

        @Override
        public UserResponse createUsers(List<UserRequest> requests) {
            System.out.println("[SERVER] Processing createUsers (client streaming)...");
            int created = 0;

            for (UserRequest req : requests) {
                userDatabase.put(req.getUserId(), req);
                created++;
            }

            return new UserResponse(
                "batch",
                true,
                "Created " + created + " users"
            );
        }
    }

    // SIMULATION: gRPC server
    static class Server {
        private int port;
        private UserServiceImpl service;

        public Server(int port, UserServiceImpl service) {
            this.port = port;
            this.service = service;
        }

        public void start() {
            System.out.println("[SERVER] Started on port " + port);
            System.out.println("[SERVER] Registered UserService");
            // In production: Starts HTTP/2 server, registers service handlers
        }

        public void awaitTermination() {
            System.out.println("[SERVER] Awaiting requests...");
        }

        public void shutdown() {
            System.out.println("[SERVER] Shutting down");
        }
    }

    public static void main(String[] args) {
        System.out.println("=== gRPC Service Definition Simulation ===\\n");

        // 1. Define service implementation
        System.out.println("1. SERVICE IMPLEMENTATION");
        UserServiceImpl serviceImpl = new UserServiceImpl();
        System.out.println("   - Implemented UserService with 3 RPC methods\\n");

        // 2. Start gRPC server
        System.out.println("2. SERVER STARTUP");
        Server server = new Server(50051, serviceImpl);
        server.start();
        System.out.println();

        // 3. Create client channel
        System.out.println("3. CLIENT CONNECTION");
        Channel channel = new Channel("localhost:50051");
        UserServiceBlockingStub blockingStub = UserServiceGrpc.newBlockingStub(channel);
        System.out.println();

        // 4. Unary RPC call
        System.out.println("4. UNARY RPC (single request/response)");
        UserRequest request = UserRequest.newBuilder()
            .setUserId("user-123")
            .setName("Alice Johnson")
            .setEmail("alice@example.com")
            .build();

        UserResponse response = blockingStub.getUser(request);
        System.out.println("   Response: " + response.getMessage());
        System.out.println("   Success: " + response.getSuccess());
        System.out.println();

        // 5. Server streaming RPC
        System.out.println("5. SERVER STREAMING RPC");
        Iterator<UserResponse> userStream = blockingStub.listUsers();
        int count = 0;
        while (userStream.hasNext()) {
            UserResponse user = userStream.next();
            System.out.println("   Streamed: " + user.getMessage());
            count++;
        }
        System.out.println("   Received " + count + " users\\n");

        // 6. Client streaming RPC simulation
        System.out.println("6. CLIENT STREAMING RPC");
        List<UserRequest> newUsers = Arrays.asList(
            UserRequest.newBuilder()
                .setUserId("user-789")
                .setName("Charlie Davis")
                .setEmail("charlie@example.com")
                .build(),
            UserRequest.newBuilder()
                .setUserId("user-999")
                .setName("Diana Prince")
                .setEmail("diana@example.com")
                .build()
        );

        UserResponse batchResponse = serviceImpl.createUsers(newUsers);
        System.out.println("   " + batchResponse.getMessage());
        System.out.println();

        // 7. Async RPC with callback
        System.out.println("7. ASYNC RPC WITH CALLBACK");
        UserServiceStub asyncStub = UserServiceGrpc.newStub(channel);
        asyncStub.getUser(request, new StreamObserver<UserResponse>() {
            @Override
            public void onNext(UserResponse value) {
                System.out.println("   Callback received: " + value.getMessage());
            }

            @Override
            public void onError(Throwable t) {
                System.err.println("   Error: " + t.getMessage());
            }

            @Override
            public void onCompleted() {
                System.out.println("   RPC completed");
            }
        });
        System.out.println();

        // 8. Cleanup
        System.out.println("8. CLEANUP");
        channel.shutdown();
        server.shutdown();

        System.out.println("\\n=== Service Definition Complete ===");
        System.out.println("Demonstrated:");
        System.out.println("- Proto message to Java class mapping");
        System.out.println("- Service definition with multiple RPC types");
        System.out.println("- Unary, server streaming, client streaming RPCs");
        System.out.println("- Synchronous and asynchronous stubs");
        System.out.println("- Request/response lifecycle");
    }
}''',

    928: '''// In production: import io.grpc.*;
// In production: import io.grpc.stub.*;
// In production: import java.util.concurrent.TimeUnit;

import java.util.*;
import java.util.concurrent.*;

// Simulates bidirectional streaming gRPC for real-time chat/collaboration
// Real: Used by Google Meet, Slack for real-time communication
public class Main {

    // SIMULATION: Chat message proto
    // Real .proto: message ChatMessage { string user = 1; string text = 2; int64 timestamp = 3; }
    static class ChatMessage {
        private String user;
        private String text;
        private long timestamp;
        private String messageId;

        public ChatMessage(String user, String text) {
            this.user = user;
            this.text = text;
            this.timestamp = System.currentTimeMillis();
            this.messageId = UUID.randomUUID().toString().substring(0, 8);
        }

        public String getUser() { return user; }
        public String getText() { return text; }
        public long getTimestamp() { return timestamp; }
        public String getMessageId() { return messageId; }

        @Override
        public String toString() {
            return String.format("[%s] %s: %s", messageId, user, text);
        }
    }

    // SIMULATION: Typing indicator proto
    static class TypingIndicator {
        private String user;
        private boolean isTyping;

        public TypingIndicator(String user, boolean isTyping) {
            this.user = user;
            this.isTyping = isTyping;
        }

        public String getUser() { return user; }
        public boolean isTyping() { return isTyping; }
    }

    // SIMULATION: Stream observer for bidirectional communication
    interface StreamObserver<T> {
        void onNext(T value);
        void onError(Throwable t);
        void onCompleted();
    }

    // SIMULATION: Bidirectional chat service
    // Real .proto: rpc Chat(stream ChatMessage) returns (stream ChatMessage);
    static class ChatServiceImpl {
        private List<StreamObserver<ChatMessage>> connectedClients =
            new CopyOnWriteArrayList<>();
        private Map<String, Long> clientHeartbeats = new ConcurrentHashMap<>();
        private BlockingQueue<ChatMessage> messageQueue = new LinkedBlockingQueue<>();

        // Bidirectional streaming handler
        public StreamObserver<ChatMessage> chat(StreamObserver<ChatMessage> responseObserver) {
            System.out.println("[SERVER] New bidirectional stream opened");

            // Add client to broadcast list
            connectedClients.add(responseObserver);

            // Return client request observer
            return new StreamObserver<ChatMessage>() {
                private String currentUser = null;

                @Override
                public void onNext(ChatMessage message) {
                    currentUser = message.getUser();

                    // Update heartbeat for flow control
                    clientHeartbeats.put(currentUser, System.currentTimeMillis());

                    System.out.println("[SERVER] Received: " + message);

                    // Broadcast to all connected clients (including sender)
                    broadcastMessage(message);

                    // BACKPRESSURE: Check queue size
                    if (messageQueue.size() > 100) {
                        System.out.println("[SERVER] BACKPRESSURE: Queue size " +
                            messageQueue.size() + ", slowing down");
                        try {
                            Thread.sleep(10);
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                        }
                    }
                }

                @Override
                public void onError(Throwable t) {
                    System.err.println("[SERVER] Client error: " + t.getMessage());
                    cleanup();
                }

                @Override
                public void onCompleted() {
                    System.out.println("[SERVER] Client completed stream");
                    cleanup();
                }

                private void cleanup() {
                    connectedClients.remove(responseObserver);
                    if (currentUser != null) {
                        clientHeartbeats.remove(currentUser);
                        System.out.println("[SERVER] Removed client: " + currentUser);
                    }
                }
            };
        }

        // Broadcast message to all connected clients
        private void broadcastMessage(ChatMessage message) {
            Iterator<StreamObserver<ChatMessage>> iterator = connectedClients.iterator();
            int delivered = 0;

            while (iterator.hasNext()) {
                StreamObserver<ChatMessage> client = iterator.next();
                try {
                    client.onNext(message);
                    delivered++;
                } catch (Exception e) {
                    System.err.println("[SERVER] Failed to deliver to client: " + e.getMessage());
                    iterator.remove();
                }
            }

            System.out.println("[SERVER] Broadcasted to " + delivered + " clients");
        }

        // Health check for connected clients
        public void checkClientHealth() {
            long now = System.currentTimeMillis();
            for (Map.Entry<String, Long> entry : clientHeartbeats.entrySet()) {
                long lastHeartbeat = entry.getValue();
                if (now - lastHeartbeat > 30000) {
                    System.out.println("[SERVER] Client timeout: " + entry.getKey());
                    clientHeartbeats.remove(entry.getKey());
                }
            }
        }

        public int getConnectedCount() {
            return connectedClients.size();
        }
    }

    // SIMULATION: Chat client with bidirectional streaming
    static class ChatClient {
        private String username;
        private StreamObserver<ChatMessage> requestObserver;
        private CountDownLatch completionLatch;
        private volatile boolean active = true;

        public ChatClient(String username) {
            this.username = username;
            this.completionLatch = new CountDownLatch(1);
        }

        public void connect(ChatServiceImpl service) {
            System.out.println("[" + username + "] Connecting to chat...");

            // Response observer (server -> client stream)
            StreamObserver<ChatMessage> responseObserver = new StreamObserver<ChatMessage>() {
                @Override
                public void onNext(ChatMessage message) {
                    // Display received messages (including own)
                    if (!message.getUser().equals(username)) {
                        System.out.println("[" + username + "] << " + message);
                    }
                }

                @Override
                public void onError(Throwable t) {
                    System.err.println("[" + username + "] Stream error: " + t.getMessage());
                    active = false;
                    completionLatch.countDown();
                }

                @Override
                public void onCompleted() {
                    System.out.println("[" + username + "] Stream completed");
                    active = false;
                    completionLatch.countDown();
                }
            };

            // Request observer (client -> server stream)
            requestObserver = service.chat(responseObserver);
            System.out.println("[" + username + "] Connected\\n");
        }

        public void sendMessage(String text) {
            if (!active) {
                System.err.println("[" + username + "] Cannot send, stream closed");
                return;
            }

            ChatMessage message = new ChatMessage(username, text);
            System.out.println("[" + username + "] >> " + message);

            try {
                requestObserver.onNext(message);
            } catch (Exception e) {
                System.err.println("[" + username + "] Send failed: " + e.getMessage());
            }
        }

        public void disconnect() {
            System.out.println("[" + username + "] Disconnecting...");
            active = false;
            try {
                requestObserver.onCompleted();
            } catch (Exception e) {
                System.err.println("[" + username + "] Disconnect error: " + e.getMessage());
            }
        }

        public boolean isActive() {
            return active;
        }
    }

    // SIMULATION: Flow control manager
    static class FlowControlManager {
        private int windowSize = 10;
        private int messagesInFlight = 0;

        public boolean canSend() {
            return messagesInFlight < windowSize;
        }

        public void messageSent() {
            messagesInFlight++;
        }

        public void messageAcknowledged() {
            messagesInFlight = Math.max(0, messagesInFlight - 1);
        }

        public void adjustWindow(int newSize) {
            windowSize = newSize;
            System.out.println("[FLOW] Window size adjusted to " + windowSize);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== gRPC Bidirectional Streaming Simulation ===\\n");

        // 1. Start chat service
        System.out.println("1. CHAT SERVICE INITIALIZATION");
        ChatServiceImpl chatService = new ChatServiceImpl();
        System.out.println("   Bidirectional streaming service ready\\n");

        // 2. Connect multiple clients
        System.out.println("2. CLIENT CONNECTIONS");
        ChatClient alice = new ChatClient("Alice");
        ChatClient bob = new ChatClient("Bob");
        ChatClient charlie = new ChatClient("Charlie");

        alice.connect(chatService);
        Thread.sleep(100);
        bob.connect(chatService);
        Thread.sleep(100);
        charlie.connect(chatService);
        Thread.sleep(200);

        System.out.println("   Connected clients: " + chatService.getConnectedCount() + "\\n");

        // 3. Bidirectional message exchange
        System.out.println("3. BIDIRECTIONAL CHAT EXCHANGE");
        alice.sendMessage("Hello everyone!");
        Thread.sleep(150);

        bob.sendMessage("Hi Alice! How are you?");
        Thread.sleep(150);

        charlie.sendMessage("Hey team!");
        Thread.sleep(150);

        alice.sendMessage("Doing great, thanks!");
        Thread.sleep(150);

        System.out.println();

        // 4. Flow control demonstration
        System.out.println("4. FLOW CONTROL & BACKPRESSURE");
        FlowControlManager flowControl = new FlowControlManager();

        for (int i = 1; i <= 15; i++) {
            if (flowControl.canSend()) {
                bob.sendMessage("Message " + i);
                flowControl.messageSent();
            } else {
                System.out.println("[FLOW] Window full, waiting...");
                flowControl.messageAcknowledged();
                flowControl.messageAcknowledged();
                bob.sendMessage("Message " + i);
                flowControl.messageSent();
            }
            Thread.sleep(50);
        }
        System.out.println();

        // 5. Handle client disconnect
        System.out.println("5. CLIENT DISCONNECT HANDLING");
        charlie.sendMessage("I have to go, bye!");
        Thread.sleep(100);
        charlie.disconnect();
        Thread.sleep(200);

        System.out.println("   Remaining clients: " + chatService.getConnectedCount() + "\\n");

        // 6. Continue conversation with remaining clients
        System.out.println("6. CONTINUED STREAMING");
        alice.sendMessage("See you Charlie!");
        Thread.sleep(100);
        bob.sendMessage("Bye Charlie!");
        Thread.sleep(200);

        // 7. Simulate typing indicators (additional stream)
        System.out.println("7. TYPING INDICATORS");
        TypingIndicator aliceTyping = new TypingIndicator("Alice", true);
        System.out.println("   " + aliceTyping.getUser() + " is typing...");
        Thread.sleep(500);
        alice.sendMessage("Check out this gRPC feature!");
        aliceTyping = new TypingIndicator("Alice", false);
        Thread.sleep(200);

        System.out.println();

        // 8. Health check
        System.out.println("8. CONNECTION HEALTH CHECK");
        chatService.checkClientHealth();
        System.out.println("   All clients healthy\\n");

        // 9. Graceful shutdown
        System.out.println("9. GRACEFUL SHUTDOWN");
        alice.sendMessage("Closing the chat room!");
        Thread.sleep(100);

        alice.disconnect();
        bob.disconnect();

        Thread.sleep(300);

        System.out.println("\\n=== Bidirectional Streaming Complete ===");
        System.out.println("Demonstrated:");
        System.out.println("- Full-duplex bidirectional streaming");
        System.out.println("- Multiple concurrent client streams");
        System.out.println("- Real-time message broadcasting");
        System.out.println("- Flow control and backpressure");
        System.out.println("- Connection lifecycle management");
        System.out.println("- Graceful disconnect handling");
    }
}''',

    1054: '''// In production: import io.grpc.*;
// In production: import io.grpc.netty.shaded.io.grpc.netty.*;
// In production: import io.grpc.stub.*;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

// Simulates production gRPC deployment at Google/Netflix scale
// Real: Used for millions of RPC calls per second in production
public class Main {

    // SIMULATION: Request/Response messages
    static class ServiceRequest {
        private String requestId;
        private String operation;
        private Map<String, String> metadata;

        public ServiceRequest(String requestId, String operation) {
            this.requestId = requestId;
            this.operation = operation;
            this.metadata = new HashMap<>();
        }

        public String getRequestId() { return requestId; }
        public String getOperation() { return operation; }
        public Map<String, String> getMetadata() { return metadata; }
    }

    static class ServiceResponse {
        private String requestId;
        private boolean success;
        private String data;
        private long latencyMs;

        public ServiceResponse(String requestId, boolean success, String data, long latencyMs) {
            this.requestId = requestId;
            this.success = success;
            this.data = data;
            this.latencyMs = latencyMs;
        }

        public String getRequestId() { return requestId; }
        public boolean isSuccess() { return success; }
        public String getData() { return data; }
        public long getLatencyMs() { return latencyMs; }
    }

    // SIMULATION: Production interceptor for logging/auth/metrics
    static class ProductionInterceptor {
        private String name;
        private MetricsCollector metrics;

        public ProductionInterceptor(String name, MetricsCollector metrics) {
            this.name = name;
            this.metrics = metrics;
        }

        public <ReqT, RespT> void interceptCall(
            String methodName,
            ReqT request,
            RespT response,
            long startTime) {

            long duration = System.currentTimeMillis() - startTime;

            // Logging
            System.out.println("[INTERCEPTOR:" + name + "] " + methodName +
                " completed in " + duration + "ms");

            // Authentication check
            if (methodName.contains("Secure")) {
                System.out.println("[INTERCEPTOR:" + name + "] Auth validated");
            }

            // Metrics collection
            metrics.recordLatency(methodName, duration);
            metrics.incrementCounter(methodName + ".calls");
        }
    }

    // SIMULATION: Metrics collector for monitoring
    static class MetricsCollector {
        private Map<String, AtomicLong> counters = new ConcurrentHashMap<>();
        private Map<String, List<Long>> latencies = new ConcurrentHashMap<>();

        public void incrementCounter(String name) {
            counters.computeIfAbsent(name, k -> new AtomicLong()).incrementAndGet();
        }

        public void recordLatency(String method, long latencyMs) {
            latencies.computeIfAbsent(method, k -> new CopyOnWriteArrayList<>()).add(latencyMs);
        }

        public void printMetrics() {
            System.out.println("\\n[METRICS] Current Statistics:");

            for (Map.Entry<String, AtomicLong> entry : counters.entrySet()) {
                System.out.println("  " + entry.getKey() + ": " + entry.getValue().get());
            }

            for (Map.Entry<String, List<Long>> entry : latencies.entrySet()) {
                List<Long> values = entry.getValue();
                if (!values.isEmpty()) {
                    long avg = values.stream().mapToLong(Long::longValue).sum() / values.size();
                    long p95 = calculatePercentile(values, 95);
                    System.out.println("  " + entry.getKey() + " - avg: " + avg +
                        "ms, p95: " + p95 + "ms");
                }
            }
        }

        private long calculatePercentile(List<Long> values, int percentile) {
            List<Long> sorted = new ArrayList<>(values);
            Collections.sort(sorted);
            int index = (int) Math.ceil(percentile / 100.0 * sorted.size()) - 1;
            return sorted.get(Math.max(0, index));
        }
    }

    // SIMULATION: Load balancer for distributing requests
    static class LoadBalancer {
        private List<String> backends;
        private AtomicInteger currentIndex = new AtomicInteger(0);
        private Map<String, AtomicInteger> requestCounts = new ConcurrentHashMap<>();

        public LoadBalancer(List<String> backends) {
            this.backends = backends;
            for (String backend : backends) {
                requestCounts.put(backend, new AtomicInteger(0));
            }
        }

        // Round-robin load balancing
        public String selectBackend() {
            int index = currentIndex.getAndIncrement() % backends.size();
            String backend = backends.get(index);
            requestCounts.get(backend).incrementAndGet();
            return backend;
        }

        // Least-connections load balancing
        public String selectLeastLoaded() {
            return backends.stream()
                .min(Comparator.comparingInt(b -> requestCounts.get(b).get()))
                .orElse(backends.get(0));
        }

        public void printDistribution() {
            System.out.println("\\n[LOAD BALANCER] Request Distribution:");
            for (Map.Entry<String, AtomicInteger> entry : requestCounts.entrySet()) {
                System.out.println("  " + entry.getKey() + ": " + entry.getValue().get() + " requests");
            }
        }
    }

    // SIMULATION: Circuit breaker for fault tolerance
    static class CircuitBreaker {
        private enum State { CLOSED, OPEN, HALF_OPEN }

        private State state = State.CLOSED;
        private int failureCount = 0;
        private int failureThreshold = 5;
        private long openTime = 0;
        private long timeoutMs = 5000;

        public boolean allowRequest() {
            if (state == State.CLOSED) {
                return true;
            }

            if (state == State.OPEN) {
                if (System.currentTimeMillis() - openTime > timeoutMs) {
                    System.out.println("[CIRCUIT BREAKER] Transitioning to HALF_OPEN");
                    state = State.HALF_OPEN;
                    return true;
                }
                return false;
            }

            // HALF_OPEN state
            return true;
        }

        public void recordSuccess() {
            if (state == State.HALF_OPEN) {
                System.out.println("[CIRCUIT BREAKER] Success in HALF_OPEN, closing circuit");
                state = State.CLOSED;
            }
            failureCount = 0;
        }

        public void recordFailure() {
            failureCount++;
            if (failureCount >= failureThreshold) {
                System.out.println("[CIRCUIT BREAKER] Threshold reached, opening circuit");
                state = State.OPEN;
                openTime = System.currentTimeMillis();
            }
        }

        public State getState() {
            return state;
        }
    }

    // SIMULATION: Retry policy with exponential backoff
    static class RetryPolicy {
        private int maxRetries = 3;
        private long baseDelayMs = 100;
        private double backoffMultiplier = 2.0;

        public <T> T executeWithRetry(Callable<T> operation) throws Exception {
            int attempt = 0;
            Exception lastException = null;

            while (attempt < maxRetries) {
                try {
                    return operation.call();
                } catch (Exception e) {
                    lastException = e;
                    attempt++;

                    if (attempt < maxRetries) {
                        long delay = (long) (baseDelayMs * Math.pow(backoffMultiplier, attempt - 1));
                        System.out.println("[RETRY] Attempt " + attempt + " failed, retrying in " +
                            delay + "ms");
                        Thread.sleep(delay);
                    }
                }
            }

            throw new Exception("Max retries exceeded", lastException);
        }
    }

    // SIMULATION: Health check service
    static class HealthCheckService {
        private Map<String, Boolean> componentHealth = new ConcurrentHashMap<>();

        public HealthCheckService() {
            componentHealth.put("database", true);
            componentHealth.put("cache", true);
            componentHealth.put("message_queue", true);
        }

        public boolean checkHealth() {
            return componentHealth.values().stream().allMatch(h -> h);
        }

        public Map<String, Boolean> getDetailedHealth() {
            return new HashMap<>(componentHealth);
        }

        public void setComponentHealth(String component, boolean healthy) {
            componentHealth.put(component, healthy);
            System.out.println("[HEALTH] " + component + " status: " +
                (healthy ? "HEALTHY" : "UNHEALTHY"));
        }
    }

    // SIMULATION: Production gRPC service with all features
    static class ProductionGrpcService {
        private MetricsCollector metrics;
        private List<ProductionInterceptor> interceptors;
        private LoadBalancer loadBalancer;
        private CircuitBreaker circuitBreaker;
        private RetryPolicy retryPolicy;
        private HealthCheckService healthCheck;

        public ProductionGrpcService() {
            this.metrics = new MetricsCollector();
            this.interceptors = new ArrayList<>();
            this.loadBalancer = new LoadBalancer(Arrays.asList(
                "backend-1:50051",
                "backend-2:50051",
                "backend-3:50051"
            ));
            this.circuitBreaker = new CircuitBreaker();
            this.retryPolicy = new RetryPolicy();
            this.healthCheck = new HealthCheckService();

            // Add production interceptors
            interceptors.add(new ProductionInterceptor("Auth", metrics));
            interceptors.add(new ProductionInterceptor("Logging", metrics));
            interceptors.add(new ProductionInterceptor("Metrics", metrics));
        }

        public ServiceResponse processRequest(ServiceRequest request) {
            long startTime = System.currentTimeMillis();

            // Check circuit breaker
            if (!circuitBreaker.allowRequest()) {
                System.out.println("[SERVICE] Circuit OPEN, rejecting request");
                return new ServiceResponse(
                    request.getRequestId(),
                    false,
                    "Circuit breaker OPEN",
                    System.currentTimeMillis() - startTime
                );
            }

            try {
                // Select backend with load balancing
                String backend = loadBalancer.selectBackend();
                System.out.println("[SERVICE] Routing to " + backend);

                // Execute with retry policy
                ServiceResponse response = retryPolicy.executeWithRetry(() -> {
                    // Simulate processing
                    Thread.sleep(50 + new Random().nextInt(50));

                    // 10% failure rate simulation
                    if (new Random().nextInt(10) == 0) {
                        throw new Exception("Simulated transient failure");
                    }

                    return new ServiceResponse(
                        request.getRequestId(),
                        true,
                        "Processed by " + backend,
                        System.currentTimeMillis() - startTime
                    );
                });

                // Record success
                circuitBreaker.recordSuccess();

                // Run interceptors
                for (ProductionInterceptor interceptor : interceptors) {
                    interceptor.interceptCall(
                        request.getOperation(),
                        request,
                        response,
                        startTime
                    );
                }

                return response;

            } catch (Exception e) {
                // Record failure
                circuitBreaker.recordFailure();
                System.err.println("[SERVICE] Request failed: " + e.getMessage());

                return new ServiceResponse(
                    request.getRequestId(),
                    false,
                    "Error: " + e.getMessage(),
                    System.currentTimeMillis() - startTime
                );
            }
        }

        public MetricsCollector getMetrics() {
            return metrics;
        }

        public LoadBalancer getLoadBalancer() {
            return loadBalancer;
        }

        public HealthCheckService getHealthCheck() {
            return healthCheck;
        }
    }

    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Production gRPC Service Simulation ===\\n");

        // 1. Initialize production service
        System.out.println("1. SERVICE INITIALIZATION");
        ProductionGrpcService service = new ProductionGrpcService();
        System.out.println("   - Interceptors: Auth, Logging, Metrics");
        System.out.println("   - Load balancer: 3 backends (round-robin)");
        System.out.println("   - Circuit breaker: enabled");
        System.out.println("   - Retry policy: 3 attempts, exponential backoff");
        System.out.println("   - Health checks: enabled\\n");

        // 2. Process requests with load balancing
        System.out.println("2. LOAD BALANCED REQUESTS");
        for (int i = 1; i <= 9; i++) {
            ServiceRequest request = new ServiceRequest("req-" + i, "getData");
            ServiceResponse response = service.processRequest(request);
            System.out.println("   Response " + i + ": " + response.getData() +
                " (" + response.getLatencyMs() + "ms)\\n");
            Thread.sleep(100);
        }

        service.getLoadBalancer().printDistribution();

        // 3. Health check
        System.out.println("\\n3. HEALTH CHECK");
        HealthCheckService healthCheck = service.getHealthCheck();
        System.out.println("   Overall health: " +
            (healthCheck.checkHealth() ? "HEALTHY" : "UNHEALTHY"));
        Map<String, Boolean> details = healthCheck.getDetailedHealth();
        for (Map.Entry<String, Boolean> entry : details.entrySet()) {
            System.out.println("   - " + entry.getKey() + ": " +
                (entry.getValue() ? "OK" : "FAIL"));
        }

        // 4. Metrics and monitoring
        System.out.println("\\n4. PRODUCTION METRICS");
        service.getMetrics().printMetrics();

        // 5. Deadline/timeout configuration
        System.out.println("\\n5. DEADLINE & TIMEOUT");
        long deadline = System.currentTimeMillis() + 5000;
        System.out.println("   Set deadline: 5000ms from now");
        System.out.println("   Timestamp: " + deadline);

        ServiceRequest timeoutRequest = new ServiceRequest("req-timeout", "longOperation");
        ServiceResponse timeoutResponse = service.processRequest(timeoutRequest);

        if (System.currentTimeMillis() > deadline) {
            System.out.println("   Request exceeded deadline (would timeout in production)");
        } else {
            System.out.println("   Request completed within deadline");
        }

        // 6. TLS and security
        System.out.println("\\n6. SECURITY CONFIGURATION");
        System.out.println("   - TLS 1.3 enabled (simulated)");
        System.out.println("   - mTLS certificate validation (simulated)");
        System.out.println("   - Channel encryption: AES-256-GCM");
        System.out.println("   - Auth token: Bearer JWT (validated by interceptor)");

        // 7. Compression
        System.out.println("\\n7. COMPRESSION");
        System.out.println("   - Enabled: gzip compression");
        System.out.println("   - Payload reduction: ~70% (typical)");
        System.out.println("   - Used for messages > 1KB");

        // 8. Keepalive configuration
        System.out.println("\\n8. KEEPALIVE SETTINGS");
        System.out.println("   - Keepalive time: 30 seconds");
        System.out.println("   - Keepalive timeout: 10 seconds");
        System.out.println("   - Permits keepalive without calls: true");
        System.out.println("   - Max connection idle: 5 minutes");

        System.out.println("\\n=== Production gRPC Service Complete ===");
        System.out.println("Demonstrated:");
        System.out.println("- Production interceptors (auth, logging, metrics)");
        System.out.println("- Load balancing strategies (round-robin)");
        System.out.println("- Circuit breaker pattern");
        System.out.println("- Retry policies with exponential backoff");
        System.out.println("- Health checks and monitoring");
        System.out.println("- Deadline/timeout configuration");
        System.out.println("- Security (TLS, mTLS, encryption)");
        System.out.println("- Compression and keepalive");
    }
}'''
}

def main():
    print("=" * 70)
    print("gRPC Modern API Communication Upgrade Script (Batch 9)")
    print("=" * 70)
    print()

    # Load lessons
    json_path = Path(r'c:\devbootLLM-app\public\lessons-java.json')

    if not json_path.exists():
        print(f"ERROR: File not found: {json_path}")
        sys.exit(1)

    print(f"Loading: {json_path}")
    with open(json_path, 'r', encoding='utf-8') as f:
        lessons = json.load(f)

    print(f"Total lessons in file: {len(lessons)}")
    print()

    # Track updates
    updated = []

    # Process each lesson
    for lesson in lessons:
        lesson_id = lesson.get('id')

        if lesson_id in LESSONS:
            config = LESSONS[lesson_id]
            old_solution = lesson.get('fullSolution', '')
            old_length = len(old_solution)

            print(f"Processing Lesson {lesson_id}: {config['title']}")
            print(f"  Before: {old_length} characters")

            # Update with new solution
            new_solution = SOLUTIONS[lesson_id]
            lesson['fullSolution'] = new_solution
            new_length = len(new_solution)

            print(f"  After:  {new_length} characters")
            print(f"  Target: {config['target_min']}-{config['target_max']} characters")

            # Verify target range
            if config['target_min'] <= new_length <= config['target_max']:
                print(f"  Status: OK (within target range)")
            else:
                print(f"  Status: WARNING (outside target range)")

            updated.append({
                'id': lesson_id,
                'title': config['title'],
                'old_length': old_length,
                'new_length': new_length,
                'target_min': config['target_min'],
                'target_max': config['target_max']
            })
            print()

    # Save updated lessons
    print("Saving updated lessons...")
    with open(json_path, 'w', encoding='utf-8') as f:
        json.dump(lessons, f, indent=2, ensure_ascii=False)

    print(f"Saved: {json_path}")
    print()

    # Summary
    print("=" * 70)
    print("UPGRADE SUMMARY")
    print("=" * 70)
    print()

    for item in updated:
        print(f"Lesson {item['id']}: {item['title']}")
        print(f"  {item['old_length']:>5} chars -> {item['new_length']:>5} chars "
              f"(target: {item['target_min']}-{item['target_max']})")

    print()
    print(f"Total lessons upgraded: {len(updated)}")
    print()
    print("All lessons upgraded successfully!")
    print("=" * 70)

if __name__ == '__main__':
    main()
